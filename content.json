[{"title":"面向对象技术","date":"2020-03-14T14:11:28.661Z","path":"2020/03/14/面向对象技术/","text":"面试对象基础 UML设计模式","comments":true,"tags":[{"name":"面试对象基础","slug":"面试对象基础","permalink":"https://pandamin18436220.github.io/tags/%E9%9D%A2%E8%AF%95%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"},{"name":"UML","slug":"UML","permalink":"https://pandamin18436220.github.io/tags/UML/"},{"name":"设计模式","slug":"设计模式","permalink":"https://pandamin18436220.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"数据结构","date":"2020-03-14T13:56:05.637Z","path":"2020/03/14/数据结构/","text":"什么是数据结构 线性表栈和队列数组和广义表树图排序查找","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"https://pandamin18436220.github.io/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://pandamin18436220.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"https://pandamin18436220.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"队列","slug":"队列","permalink":"https://pandamin18436220.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"树","slug":"树","permalink":"https://pandamin18436220.github.io/tags/%E6%A0%91/"},{"name":"图","slug":"图","permalink":"https://pandamin18436220.github.io/tags/%E5%9B%BE/"},{"name":"排序","slug":"排序","permalink":"https://pandamin18436220.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"查找","slug":"查找","permalink":"https://pandamin18436220.github.io/tags/%E6%9F%A5%E6%89%BE/"}]},{"title":"计算机网络","date":"2020-03-14T13:47:02.833Z","path":"2020/03/14/计算机网络/","text":"计算机网络和因特网 应用层传输层网络层数据链路层物理层无线网络和移动网络多媒体网络计算机网络中的安全网络管理","comments":true,"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://pandamin18436220.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"存储","slug":"存储","permalink":"https://pandamin18436220.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"设备","slug":"设备","permalink":"https://pandamin18436220.github.io/tags/%E8%AE%BE%E5%A4%87/"},{"name":"文件","slug":"文件","permalink":"https://pandamin18436220.github.io/tags/%E6%96%87%E4%BB%B6/"},{"name":"作业","slug":"作业","permalink":"https://pandamin18436220.github.io/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"Linux学习","date":"2020-03-14T11:00:05.009Z","path":"2020/03/14/Linux学习/","text":"Linux的七个控制台 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆 运行级别2：多用户状态(没有NFS) 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 运行级别4：系统未使用，保留 运行级别5：X11控制台，登陆后进入图形GUI模式 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 Linux的命令(大小写严格区分)1[root@www~]# 命令 -[选项...(三者之间可以有任意多个空格)]参数 //命令[杀] -选项[温柔的] 参数[鸡] ----&gt;温柔的杀鸡 命令 作用 类比于windows ls (其参数是隐藏的:为当前所在的文件夹) 查看目录内容 dir ls /home/duan/ 查看目录/home/duan/下的内容 ls -l 显示目录内容的属性 ls -1 目录内容按行显示 ls -a 显示目录的所有内容 ls -s 显示目录和文件大小 ls -l1as 是将上四行一起执行 ls –help 此处有两个“-”,是只当选项是一个单词时用“–”，以与联合执行区别 data +%Y-%m-%d 显示当前时间 cal [月份 年份] 显示日历表 bc [scale=4 (保留四位小数)] 计数器 history 查看之前已经敲过的命令 [然后可以通过显示的序列:敲!+序列,可以执行该序列命令] clear 清屏 cls pwd 查看当前目录 whatis +命令 查看命令的作用(是什么) 命令 –help 介绍该命令用法(怎么做) Linux命令相关快捷键 ctrl+HOME:光标移至开头 ctrl+End:光标移至结尾 ctrl+U:删除光标前面的所有 ctrl+K:删除光标后面的所有 Esc+.:可以使用上一个命令的参数 ^参数1^参数2:使用参数2代替参数1 ctrl+p:使用历史命令 ctrl+shift+T:打开多个终端 ctrl+c:退出该命令 ctrl+d:关闭终端 Linux的归档权限与目录配置Linux的归档与目录管理Linux的磁盘与文件系统管理归档与文件系统的压缩与打包vim程序编辑器认识与学习BASH正规表达式与文件格式化处理学习Shell ScriptsLinux账号管理与ACL权限设定磁盘配额与进阶文件系统例行性工作排程程序管理与SELinux初探认识系统服务(daemons)认识与分析登录档 在Hadoop1.x时代,MapReduce同时处理业务逻辑运算和资源的调度，耦合性较大在Hadoop2.x时代，增加了Yarn。Yarn只负责资源调度，MapReduce只负责运算","comments":true,"tags":[{"name":"Linux","slug":"Linux","permalink":"https://pandamin18436220.github.io/tags/Linux/"},{"name":"命令操作","slug":"命令操作","permalink":"https://pandamin18436220.github.io/tags/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/"}]},{"title":"数据库","date":"2020-03-12T11:34:50.238Z","path":"2020/03/12/数据库/","text":"基本概念检索数据 排序检索数据过滤数据数据过滤用通配符进行过滤用正则表达式进行搜索创建计算字段使用数据处理函数汇总数据分组数据使用子查询连结表创建高级连结组合查询全文本搜索插入数据更新和删除数据创建和操纵表使用试图使用存储过程使用游标使用触发器管理事务处理全球化和本地化安全管理数据库维护改善性能","comments":true,"tags":[{"name":"数据库，MySQL","slug":"数据库，MySQL","permalink":"https://pandamin18436220.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8CMySQL/"}]},{"title":"入门Git","date":"2020-03-12T11:33:50.854Z","path":"2020/03/12/入门Git/","text":"初识GitHub 加入GitHUbGit速成向GitHub提交代码Git进阶Git分支详解GitHub常见几种操作","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://pandamin18436220.github.io/tags/Git/"},{"name":"常用工具","slug":"常用工具","permalink":"https://pandamin18436220.github.io/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"缓存中间件","date":"2020-03-12T11:30:34.810Z","path":"2020/03/12/缓存中间件/","text":"大数据概念大数据（big data），指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。 大数据的特点 Volume（大量）：截至2017年，人类生产的所有印刷材料的数据量是200PB，而历史上全人类总共说过的话的数据量大约是5EB。当前，典型个人计算机硬盘的容量为TB量级，而一些大企业的数据量已经接近EB量级。 Velocity（高速）：这是大数据区分于传统数据挖掘的最显著特征。根据IDC的“数字宇宙”的报告，预计到2020年，全球数据使用量将达到35.2ZB。在如此海量的数据面前，处理数据的效率就是企业的生命。 Variety（多样）：这种类型的多样性也让数据被分为结构化数据和非结构化数据。相对于以往便于存储的以数据库/文本为主的结构化数据，非结构化数据越来越多，包括网络日志、音频、视频、图片、地理位置信息等，这些多类型的数据对数据的处理能力提出了更高要求。 Value（低价值密度）：价值密度的高低与数据总量的大小成反比。比如，在一天监控视频中，我们只关心晚上在床上健身那一分钟，如何快速对有价值数据“提纯”成为目前大数据背景下待解决的难题。 大数据的应用 O2O：百度大数据+平台通过先进的线上线下打通技术和客流分析能力，助力商家精细化运营，提升销量。 零售：探索用户价值，提供个性化服务解决方案；贯穿网络与实体零售，携手创造极致体验。经典案例，子尿布+啤酒。 旅游：深度结合百度独有大数据能力与旅游行业需求，共建旅游产业智慧管理、智慧服务和智慧营销的未来。 商品广告推荐：给用户推荐访问过的商品广告类型 房产：大数据全面助力房地产行业，打造精准投策与营销，选出更合适的地，建造更合适的楼，卖给更合适的人。 保险：海量数据挖掘及风险预测，助力保险行业精准营销，提升精细化定价能力。 金融：多维度体现用户特征，帮助金融机构推荐优质客户，防范欺诈风险。 移动联通：移动联通：根据用户年龄、职业、消费情况，分析统计哪种套餐适合哪类人群。对市场人群精准定制。 人工智能 云计算的概念 为什么会需要“云”传统的应用正在变得越来越复杂：需要支持更多的用户，需要更强的计算能力，需要更加稳定安全等等，而为了支撑这些不断增长的需求，企业不得不去购买各类硬件设备（服务器，存储，带宽等等）和软件（数据库，中间件等等），另外还需要组建一个完整的运维团队来支持这些设备或软件的正常运作，这些维护工作就包括安装、配置、测试、运行、升级以及保证系统的安全等。便会发现支持这些应用的开销变得非常巨大，而且它们的费用会随着你应用的数量或规模的增加而不断提高。这也是为什么即使是在那些拥有很出色IT部门的大企业中，那些用户仍在不断抱怨他们所使用的系统难以满足他们的需求。而对于那些中小规模的企业，甚至个人创业者来说，创造软件产品的运维成本就更加难以承受了。 简而言之：云计算的资源是动态扩展且虚拟化的，通过互联网提供，终端用户不需要了解云中基础设施的细节，不必具有专业的云技术知识，也无须直接进行控制，只要关注自身真正需要什么样的资源以及如何通过网络来获得相应的服务即可。云计算，应运而生——更大、更快、更强 针对上述问题解决方案便是“云计算”！将应用部署到云端后，可以不必再关注那些令人头疼的硬件和软件问题，它们会由云服务提供商的专业团队去解决。使用的是共享的硬件，这意味着像使用一个工具一样去利用云服务（就像插上插座，你就能使用电一样简单）。只需要按照你的需要来支付相应的费用，而关于软件的更新，资源的按需扩展都能自动完成。 云计算的五点特点 大规模、分布式“云”一般具有相当的规模，一些知名的云供应商如Google云计算、Amazon、IBM、微软、阿里等也都拥能拥有上百万级的服务器规模。而依靠这些分布式的服务器所构建起来的“云”能够为使用者提供前所未有的计算能力。虚拟化云计算都会采用虚拟化技术，用户并不需要关注具体的硬件实体，只需要选择一家云服务提供商，注册一个账号，登陆到它们的云控制台，去购买和配置你需要的服务（比如 云服务器，云存储，CDN等等），再为你的应用做一些简单的配置之后，你就可以让你的应用对外服务了，这比传统的在企业的数据中心去部署一套应用要简单方便得多。而且你可以随时随地通过你的PC或移动设备来控制你的资源，这就好像是云服务商为每一个用户都提供了一个IDC(Internet Data Center)一样。高可用性和扩展性那些知名的云计算供应商一般都会采用数据多副本容错、计算节点同构可互换等措施来保障服务的高可靠性。基于云服务的应用可以持续对外提供服务（7*24小时），另外“云”的规模可以动态伸缩，来满足应用和用户规模增长的需要。按需服务，更加经济用户可以根据自己的需要来购买服务，甚至可以按使用量来进行精确计费。这能大大节省IT成本，而资源的整体利用率也将得到明显的改善。安全网络安全已经成为所有企业或个人创业者必须面对的问题，企业的IT团队或个人很难应对那些来自网络的恶意攻击，而使用云服务则可以借助更专业的安全团队来有效降低安全风险。 云计算可以分为IaaS、PaaS、SaaS、[DaaS四个]层次。(按照服务划分) IaaS: Infrastructure-as-a-Service(基础设施即服务)有了IaaS，你可以将硬件外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。一些大的IaaS公司包括Amazon, Microsoft, VMWare, Rackspace和Red Hat.不过这些公司又都有自己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。 PaaS: Platform-as-a-Service(平台即服务)第二层就是所谓的PaaS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资源。PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。一些大的PaaS提供者有Google App Engine,Microsoft Azure，Force.com,Heroku，Engine Yard。最近兴起的公司有AppFog,Mendix和Standing Cloud. SaaS: Software-as-a-Service(软件即服务)第三层也就是所谓SaaS。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器上的应用都可以通过网络来运行，就是SaaS了。你消费的服务完全是从网页如Netflix,MOG,Google Apps,Box.net,Dropbox或者苹果的iCloud那里进入这些分类。尽管这些网页服务是用作商务和娱乐或者两者都有，但这也算是云技术的一部分。 另外，越来越多的数据沉淀、抽象形成了新的服务——DaaS（Data as a Service，数据即服务）。 下面画一个图来对比一下：| 相关项目 | 云服务 || :—- | —-: || | DASS | SAAS | PAAS | IAAS || 服务对象 | 开发者和企业 | 企业 | 开发者 | 开发者和企业用户 || 成熟度 |发展较晚，成熟度较低|发展早，成熟度相对最高|起步较晚，成熟度低|在应用层成熟后兴起，成熟度较高||核心能力|实现数据共享|帮助企业优化业务流程|帮助开发者的产品快速活动某种功能|帮助企业/开发者快速拥有存储，计算等资源||发展现状|潜力最大，融资集中在早期|企业级市场活跃，融资集中在C轮及以上|潜力较大，但是市场总体量较小|竞争激烈，垂直领域亦有发展空间||主要玩家|互联网公司|互联网公司,传统软件公司及创业企业|互联网公司，创业企业|电信运营商，IT厂商，互联网公司，创业企业| Hadoop的概念 Hadoop是一个由Apache基金会所开发的分布式系统基础架构 主要解决，海量数据的存储和海量数据的分析计算问题。 广义上来说，hadoop通常是指一个更广泛的概念——hadoop生态圈 Hadoop组成 MapReduce 计算 Yarn 资源调度 HDFS 数据存储 Common 辅助工具 大数据技术生态系统 技术名词解释 Sqoop：sqoop是一款开源的工具，主要用于在Hadoop(Hive)与传统的数据库(mysql)间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL ,Oracle 等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。 Flume：Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。 Kafka：Kafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性： （1）通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。 （2）高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息 （3）支持通过Kafka服务器和消费机集群来分区消息。 （4）支持Hadoop并行数据加载。 Storm：Storm为分布式实时计算提供了一组通用原语，可被用于“流处理”之中，实时处理消息并更新数据库。这是管理队列及工作者集群的另一种方式。 Storm也可被用于“连续计算”（continuous computation），对数据流做连续查询，在计算时就将结果以流的形式输出给用户。 Spark：Spark是当前最流行的开源大数据内存计算框架。可以基于Hadoop上存储的大数据进行计算。 Oozie：Oozie是一个管理Hdoop作业（job）的工作流程调度管理系统。Oozie协调作业就是通过时间（频率）和有效数据触发当前的Oozie工作流程。 Hbase：HBase是一个分布式的、面向列的开源数据库。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。 Hive：hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。 R语言：R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。 Mahout:Apache Mahout是个可扩展的机器学习和数据挖掘库，当前Mahout支持主要的4个用例：推荐挖掘：搜集用户动作并以此给用户推荐可能喜欢的事物。聚集：收集文件并进行相关文件分组。分类：从现有的分类文档中学习，寻找文档中的相似特征，并为无标签的文档进行正确的归类。频繁项集挖掘：将一组项分组，并识别哪些个别项会经常一起出现。 ZooKeeper：Zookeeper是Google的Chubby一个开源的实现。它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、 分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 扩展我们在这里就不再展开了，我们不妨关注其他一些更有趣的话题。分布式系统阿里云介绍 课后答案","comments":true,"tags":[{"name":"缓存中间件","slug":"缓存中间件","permalink":"https://pandamin18436220.github.io/tags/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Redis","slug":"Redis","permalink":"https://pandamin18436220.github.io/tags/Redis/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://pandamin18436220.github.io/tags/MongoDB/"},{"name":"memcache","slug":"memcache","permalink":"https://pandamin18436220.github.io/tags/memcache/"}]},{"title":"前端学习","date":"2020-03-12T11:28:37.592Z","path":"2020/03/12/前端学习/","text":"HTML大数据（big data），指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。 CSS Volume（大量）：截至2017年，人类生产的所有印刷材料的数据量是200PB，而历史上全人类总共说过的话的数据量大约是5EB。当前，典型个人计算机硬盘的容量为TB量级，而一些大企业的数据量已经接近EB量级。 Velocity（高速）：这是大数据区分于传统数据挖掘的最显著特征。根据IDC的“数字宇宙”的报告，预计到2020年，全球数据使用量将达到35.2ZB。在如此海量的数据面前，处理数据的效率就是企业的生命。 Variety（多样）：这种类型的多样性也让数据被分为结构化数据和非结构化数据。相对于以往便于存储的以数据库/文本为主的结构化数据，非结构化数据越来越多，包括网络日志、音频、视频、图片、地理位置信息等，这些多类型的数据对数据的处理能力提出了更高要求。 Value（低价值密度）：价值密度的高低与数据总量的大小成反比。比如，在一天监控视频中，我们只关心晚上在床上健身那一分钟，如何快速对有价值数据“提纯”成为目前大数据背景下待解决的难题。 JavaScript O2O：百度大数据+平台通过先进的线上线下打通技术和客流分析能力，助力商家精细化运营，提升销量。 零售：探索用户价值，提供个性化服务解决方案；贯穿网络与实体零售，携手创造极致体验。经典案例，子尿布+啤酒。 旅游：深度结合百度独有大数据能力与旅游行业需求，共建旅游产业智慧管理、智慧服务和智慧营销的未来。 商品广告推荐：给用户推荐访问过的商品广告类型 房产：大数据全面助力房地产行业，打造精准投策与营销，选出更合适的地，建造更合适的楼，卖给更合适的人。 保险：海量数据挖掘及风险预测，助力保险行业精准营销，提升精细化定价能力。 金融：多维度体现用户特征，帮助金融机构推荐优质客户，防范欺诈风险。 移动联通：移动联通：根据用户年龄、职业、消费情况，分析统计哪种套餐适合哪类人群。对市场人群精准定制。 人工智能 云计算的概念 为什么会需要“云”传统的应用正在变得越来越复杂：需要支持更多的用户，需要更强的计算能力，需要更加稳定安全等等，而为了支撑这些不断增长的需求，企业不得不去购买各类硬件设备（服务器，存储，带宽等等）和软件（数据库，中间件等等），另外还需要组建一个完整的运维团队来支持这些设备或软件的正常运作，这些维护工作就包括安装、配置、测试、运行、升级以及保证系统的安全等。便会发现支持这些应用的开销变得非常巨大，而且它们的费用会随着你应用的数量或规模的增加而不断提高。这也是为什么即使是在那些拥有很出色IT部门的大企业中，那些用户仍在不断抱怨他们所使用的系统难以满足他们的需求。而对于那些中小规模的企业，甚至个人创业者来说，创造软件产品的运维成本就更加难以承受了。 简而言之：云计算的资源是动态扩展且虚拟化的，通过互联网提供，终端用户不需要了解云中基础设施的细节，不必具有专业的云技术知识，也无须直接进行控制，只要关注自身真正需要什么样的资源以及如何通过网络来获得相应的服务即可。云计算，应运而生——更大、更快、更强 针对上述问题解决方案便是“云计算”！将应用部署到云端后，可以不必再关注那些令人头疼的硬件和软件问题，它们会由云服务提供商的专业团队去解决。使用的是共享的硬件，这意味着像使用一个工具一样去利用云服务（就像插上插座，你就能使用电一样简单）。只需要按照你的需要来支付相应的费用，而关于软件的更新，资源的按需扩展都能自动完成。 云计算的五点特点 大规模、分布式“云”一般具有相当的规模，一些知名的云供应商如Google云计算、Amazon、IBM、微软、阿里等也都拥能拥有上百万级的服务器规模。而依靠这些分布式的服务器所构建起来的“云”能够为使用者提供前所未有的计算能力。虚拟化云计算都会采用虚拟化技术，用户并不需要关注具体的硬件实体，只需要选择一家云服务提供商，注册一个账号，登陆到它们的云控制台，去购买和配置你需要的服务（比如 云服务器，云存储，CDN等等），再为你的应用做一些简单的配置之后，你就可以让你的应用对外服务了，这比传统的在企业的数据中心去部署一套应用要简单方便得多。而且你可以随时随地通过你的PC或移动设备来控制你的资源，这就好像是云服务商为每一个用户都提供了一个IDC(Internet Data Center)一样。高可用性和扩展性那些知名的云计算供应商一般都会采用数据多副本容错、计算节点同构可互换等措施来保障服务的高可靠性。基于云服务的应用可以持续对外提供服务（7*24小时），另外“云”的规模可以动态伸缩，来满足应用和用户规模增长的需要。按需服务，更加经济用户可以根据自己的需要来购买服务，甚至可以按使用量来进行精确计费。这能大大节省IT成本，而资源的整体利用率也将得到明显的改善。安全网络安全已经成为所有企业或个人创业者必须面对的问题，企业的IT团队或个人很难应对那些来自网络的恶意攻击，而使用云服务则可以借助更专业的安全团队来有效降低安全风险。 云计算可以分为IaaS、PaaS、SaaS、[DaaS四个]层次。(按照服务划分) IaaS: Infrastructure-as-a-Service(基础设施即服务)有了IaaS，你可以将硬件外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。一些大的IaaS公司包括Amazon, Microsoft, VMWare, Rackspace和Red Hat.不过这些公司又都有自己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。 PaaS: Platform-as-a-Service(平台即服务)第二层就是所谓的PaaS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资源。PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。一些大的PaaS提供者有Google App Engine,Microsoft Azure，Force.com,Heroku，Engine Yard。最近兴起的公司有AppFog,Mendix和Standing Cloud. SaaS: Software-as-a-Service(软件即服务)第三层也就是所谓SaaS。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器上的应用都可以通过网络来运行，就是SaaS了。你消费的服务完全是从网页如Netflix,MOG,Google Apps,Box.net,Dropbox或者苹果的iCloud那里进入这些分类。尽管这些网页服务是用作商务和娱乐或者两者都有，但这也算是云技术的一部分。 另外，越来越多的数据沉淀、抽象形成了新的服务——DaaS（Data as a Service，数据即服务）。 下面画一个图来对比一下：| 相关项目 | 云服务 || :—- | —-: || | DASS | SAAS | PAAS | IAAS || 服务对象 | 开发者和企业 | 企业 | 开发者 | 开发者和企业用户 || 成熟度 |发展较晚，成熟度较低|发展早，成熟度相对最高|起步较晚，成熟度低|在应用层成熟后兴起，成熟度较高||核心能力|实现数据共享|帮助企业优化业务流程|帮助开发者的产品快速活动某种功能|帮助企业/开发者快速拥有存储，计算等资源||发展现状|潜力最大，融资集中在早期|企业级市场活跃，融资集中在C轮及以上|潜力较大，但是市场总体量较小|竞争激烈，垂直领域亦有发展空间||主要玩家|互联网公司|互联网公司,传统软件公司及创业企业|互联网公司，创业企业|电信运营商，IT厂商，互联网公司，创业企业| Hadoop的概念 Hadoop是一个由Apache基金会所开发的分布式系统基础架构 主要解决，海量数据的存储和海量数据的分析计算问题。 广义上来说，hadoop通常是指一个更广泛的概念——hadoop生态圈 Hadoop组成 MapReduce 计算 Yarn 资源调度 HDFS 数据存储 Common 辅助工具 大数据技术生态系统 技术名词解释 Sqoop：sqoop是一款开源的工具，主要用于在Hadoop(Hive)与传统的数据库(mysql)间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL ,Oracle 等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。 Flume：Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。 Kafka：Kafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性： （1）通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。 （2）高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息 （3）支持通过Kafka服务器和消费机集群来分区消息。 （4）支持Hadoop并行数据加载。 Storm：Storm为分布式实时计算提供了一组通用原语，可被用于“流处理”之中，实时处理消息并更新数据库。这是管理队列及工作者集群的另一种方式。 Storm也可被用于“连续计算”（continuous computation），对数据流做连续查询，在计算时就将结果以流的形式输出给用户。 Spark：Spark是当前最流行的开源大数据内存计算框架。可以基于Hadoop上存储的大数据进行计算。 Oozie：Oozie是一个管理Hdoop作业（job）的工作流程调度管理系统。Oozie协调作业就是通过时间（频率）和有效数据触发当前的Oozie工作流程。 Hbase：HBase是一个分布式的、面向列的开源数据库。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。 Hive：hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。 R语言：R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。 Mahout:Apache Mahout是个可扩展的机器学习和数据挖掘库，当前Mahout支持主要的4个用例：推荐挖掘：搜集用户动作并以此给用户推荐可能喜欢的事物。聚集：收集文件并进行相关文件分组。分类：从现有的分类文档中学习，寻找文档中的相似特征，并为无标签的文档进行正确的归类。频繁项集挖掘：将一组项分组，并识别哪些个别项会经常一起出现。 ZooKeeper：Zookeeper是Google的Chubby一个开源的实现。它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、 分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 扩展我们在这里就不再展开了，我们不妨关注其他一些更有趣的话题。分布式系统阿里云介绍 课后答案","comments":true,"tags":[{"name":"HTML","slug":"HTML","permalink":"https://pandamin18436220.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://pandamin18436220.github.io/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://pandamin18436220.github.io/tags/JavaScript/"}]},{"title":"Hadoop","date":"2020-03-12T11:25:59.855Z","path":"2020/03/12/hadoop/","text":"Hadoop的组成 版本 Common(辅助工具) HDFS(数据存储) Yarn(资源调度)【Hadoop2.x】 MapReduce(计算)【Hadoop2.x】 MapReduce(计算+资源调度) Hadoop1.x 有 有 无 无 有 Hadoop2.x 有 有 有 有 无 在Hadoop1.x时代,MapReduce同时处理业务逻辑运算和资源的调度，耦合性较大在Hadoop2.x时代，增加了Yarn。Yarn只负责资源调度，MapReduce只负责运算 HDFS架构概述 YARN架构概述 MapReduce架构概述 MapReduce将计算过程分为两个阶段：Map和Reduce Map阶段并行处理输入数据 Reduce阶段对Map结果进行汇总 大数据技术生态体系 hadoop环境搭建hadoop本地模式hadoop伪分布式hadoop完全分布式hadoop源码编译HDFSMapReduceYARN","comments":true,"tags":[{"name":"大数据","slug":"大数据","permalink":"https://pandamin18436220.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"hadoop","slug":"hadoop","permalink":"https://pandamin18436220.github.io/tags/hadoop/"},{"name":"HDFS","slug":"HDFS","permalink":"https://pandamin18436220.github.io/tags/HDFS/"},{"name":"MapReduce","slug":"MapReduce","permalink":"https://pandamin18436220.github.io/tags/MapReduce/"},{"name":"YARN","slug":"YARN","permalink":"https://pandamin18436220.github.io/tags/YARN/"}]},{"title":"读书笔记","date":"2020-03-12T09:45:41.143Z","path":"2020/03/12/读书推荐/","text":"《程序人生》十年风雨技术人的书单整理 你知道的越多，你不知道的越多 点赞再看，养成习惯 给岁月以文明，而不是给文明以岁月 本文 GitHub https://github.com/JavaFamily 上已经收录，有一线大厂面试点思维导图，也整理了很多我的文档，欢迎Star和完善，大家面试可以参照考点复习，希望我们一起有点东西。 前言王潇：格局决定了一个人的梦想，梦想反过来决定行为。 那格局是什么呢？ 格局是你能够看见的深度、广度和密度。 王潇认为，格局是一本本书搭建起来的，正如她所言：“读书让我知道世界很大，然后才知道推开门去看看这个世界。” 之前有一篇文章我写到了几乎是一个技术人从0到1的整个生涯了，其实大家发现根本就没有终点。 《程序人生》风雨十年-从大学到技术专家我做了啥？ 我们的一生其实也基本上都在学习，那提到学习，我第一时间想到的就是读书了。 记得帅丙在自己21岁的那个夏天，当时拿到了自己的第一笔实习工资1400块，因为是110块一天嘛，而且入职的第一个月也没上满，但是还是很开心，第一个月师傅就给了一个建议，买本书吧。 就这样我买了出社会之后的第一本技术书籍《Java核心卷一》，也是师傅推荐的，如获至宝。 到现在我的书架都茫茫当当了，但是这本书还是一直陪伴我左右，也是我印象最深刻的技术书籍，因为那感觉就像是初恋的味道，甜甜的。 为啥推荐大家读书呢，书籍的作者都是几年甚至几十年的经验，最后总结为一本书，那就算里面有错误的点，我想你花几十块，只用几个礼拜甚至几天就可以拜读人家十几年的经验，我觉得怎么算都是血赚？ 正文好了扯了这么多只是想要引出今天的主题，我会按照不同的类型把我知道的一些书籍，包括身边朋友推荐的书籍，都在这里列给大家，大家按需自取。 我还推荐了很多非技术的书籍，人文地理悬疑情感都会涉及，反正很多书我是真的很喜欢。 我上一篇提到的我亦师亦友的阿里技术专家朋友，他就是个很喜欢读书的人，说实话他的学校背景不好，刚开始出来也是在外包干活的，但是他有个习惯，就是看书，基本上闲暇时候，都能看到他看书的身影。 看他的动态也都是分享各类书籍，口吐芬芳，我要是个女人，估计他跑不掉了。 反正经常读书的人，你跟他说话，看他谈吐，自然就知道了，我经常说的那句：腹有诗书气自华 希望你能懂，不看真像网上的段子那样，看到美好的景色只能：卧* 下面是我截图的他的几条动态，这种谈吐我爱了❤ JavaJava核心技术·卷 I（原书第10版）| Core Java Volume 讲的很全面，书中的代码示例都很好，很适合Java入门。 但是作者不太厚道的是把现在没人用的GUI编程放在了第一卷，基本上10~13章是可以不用读的。 Java性能权威指南|Java Performance: The Definitive Guide 市面上介绍Java的书有很多，但专注于Java性能的并不多，能游刃有余地展示Java性能优化难点的更是凤毛麟角，本书即是其中之一。 通过使用JVM和Java平台，以及Java语言和应用程序接口，本书详尽讲解了Java性能调优的相关知识，帮助读者深入理解Java平台性能的各个方面，最终使程序如虎添翼。 实战Java高并发程序设计|葛一鸣 由部分段落的行文来看，搬了官方文档。 也有一些第一人称的叙述和思考，也能看出作者也是花了一点心思的。胜在比较基础，涉及到的知识点也还很全面（讲到了流水线计算和并发模型这些边边角角的），但是由于是编著，全书整体上不够统一和深入，适合作为学习高并发的第一本工具书。 Java 8实战 对Java8的新特性讲解的十分到位，尤其是lamdba表达式和流的操作。 再者对于Java8并发处理很有独到见解。对于并行数据处理和组合式异步编程还需要更深的思考才能更加掌握。 推荐给再用java8但没有去真正了解的人看，有很多你不知道的细节、原理和类库设计者的用心良苦在里面、内容没有很难，抽出几个小时就能看完，花费的时间和收获相比，性价比很高。 Java并发编程实战 先不谈本书的内容如何，光书名就足够吸引不少目光。“并发”这个词在Java世界里往往和“高级、核心”等字眼相联系起来，就冲着这两个字，都将勾起软件工程师们埋藏在心底那种对技术的探索欲和对高级API的驾驭感。 程序员嘛，多少都有点职业病。其实Java对“并发”优化从未停止过，从5.0到7.0，几乎每个版本的新特性里，都会针对前一版本在“并发”上有所改进。这种改进包括提供更丰富的API接口、JVM底层性能优化等诸多方面。 Thinking in Java 很美味的一本书，不仅有icecreamm，sundae，sandwich，还有burrito！真是越看越饿啊~ Effective Java中文版（第3版）|Effective Java Third Edition Java 高阶书籍，小白劝退。介绍了关于Java 编程的90个经验技巧。 作者功力非常强悍，导致这本书有时知识面迁移很广。总之，非常适合有一定Java开发经验的人阅读提升。 深入理解Java虚拟机（第3版）| 周志明 浅显易懂。最重要的是开启一扇理解虚拟机的大门。 内存管理机制与Java内存模型、高效并发这三章是特别实用的。 Java虚拟机规范（Java SE 8版）|爱飞翔、周志明 整本书就觉得第二章的方法字节码执行流程，第四章的前8节和第五章能看懂一些。其他的过于细致和琐碎了。 把Java字节码讲的很清楚了，本质上Java虚拟机就是通过字节码来构建的一套体系罢了。所以字节码说的非常细致深入。 数据&amp;大数据数据结构与算法分析|Data Structures and Algorithm Analysis in Java 数据结构是计算机的核心，这部书以java语言为基础，详细的介绍了基本数据结构、图、以及相关的排序、最短路径、最小生成树等问题。 但是有一些高级的数据结构并没有介绍，可以通过《数据结构与算法分析——C语言描述》来增加对这方面的了解。 MySQL必知必会 《MySQL必知必会》MySQL是世界上最受欢迎的数据库管理系统之一。 书中从介绍简单的数据检索开始，逐步深入一些复杂的内容，包括联结的使用、子查询、正则表达式和基于全文本的搜索、存储过程、游标、触发器、表约束，等等。通过重点突出的章节，条理清晰、系统而扼要地讲述了读者应该掌握的知识，使他们不经意间立刻功力大增。 数据库系统概念|Datebase System Concepts(Fifth Edition) 从大学读到现在，每次拿起都有新的收获。而且这本书还是对各个数据相关领域的概览，不仅仅是数据库本身。 高性能MySQL 对于想要了解MySQL性能提升的人来说，这是一本不可多得的书。 书中没有各种提升性能的秘籍，而是深入问题的核心，详细的解释了每种提升性能的原理，从而可以使你四两拨千斤。授之于鱼不如授之于渔，这本书做到了。 高可用MySQL 很实用的书籍，只可惜公司现有的业务和数据量还没有达到需要实践书中知识的地步。 利用Python进行数据分析|唐学韬 内容还是跟不上库的发展速度，建议结合里面讲的库的文档来看。 内容安排上我觉得还不错，作者是pandas的作者，所以对pandas的讲解和设计思路都讲得很清楚。除此以外，作者也是干过金融数据分析的，所以后面专门讲了时间序列和金融数据的分析。 HBase 看完影印版第一遍，开始以为会是大量讲API，实际上除了没有将HBase源代码，该讲的都讲了，CH8，9章留到最后看的，确实有点顿悟的感觉，接下来需要系统的看一遍Client API，然后深入代码，Come ON！ Programming Hive Hive工具书，Hive高级特性。 Hadoop in Practice| Alex Holmes 感觉比action那本要强 像是cookbook类型的 整个过完以后hadoop生态圈的各种都接触到了 这本书适合当参考手册用。 Hadoop技术内幕|董西成 其实国人能写这样的书，感觉还是不错的，不过感觉很多东西不太深入，感觉在深入之前，和先有整体，带着整体做深入会更好一点， jobclient,jobtracer,tasktracer之间的关系最好能系统化 Learning Spark 很不错，core的原理部分和api用途解释得很清楚，以前看文档和代码理解不了的地方豁然开朗。 不足的地方是后几章比较弱，mllib方面没有深入讲实现原理。graphx也没有涉及 ODPS权威指南 基本上还算一本不错的入门，虽然细节方面谈的不多，底层也不够深入，但毕竟是少有的ODPS书籍，且覆盖面很全，例子也还行。 数据之巅|徐子沛 从一个新的视角（数据）切入，写美国历史，统计学的发展贯穿其中，草蛇灰线，伏脉千里，读起来波澜壮阔。 消息队列&amp;RedisRabbitMQ实战 很多年前的书了，书中的例子现在已经不适用了，推荐官方教程。 一些基础还是适用，网上也没有太多讲rab的书籍，将就看下也行，我没用过所以…. Apache Kafka源码剖析|徐郡明 虽然还没看，但知道应该不差。我是看了作者的mybatis源码分析，再来看这本的，相信作者。 作者怎么有这么多时间，把框架研究的这么透彻，佩服，佩服。 深入理解Kafka：核心设计与实践原理|朱忠华 通俗易懂，图文并茂，用了很多图和示例讲解kafka的架构，从宏观入手，再讲到细节，比较好，值得推荐。 深入理解Kafka是市面上讲解Kafka核心原理最透彻的，全书都是挑了kafka最核心的细节在讲比如分区副本选举、分区从分配、kafka数据存储结构、时间轮、我认为是目前kafka相关书籍里最好的一本。 Kafka 认真刷了 kafka internal 那章，看了个talk，算是入了个门。 系统设计真是门艺术。 RocketMQ实战与原理解析|杨开元 对RocketMQ的脉络做了一个大概的说明吧，深入细节的东西还是需要自己看代码 Redis设计与实现|黄健宏 部分内容写得比较啰嗦，当然往好了说是对新手友好，不厌其烦地分析细节，但也让整本书变厚了😂，个人以为精炼语言可以减少20%的内容。 对于有心一窥redis实现原理的读者来说，本书展露了足够丰富的内容和细节，却不至于让冗长的实现代码吓跑读者——伪代码的意义在此。下一步是真正读源码了。 Redis 深度历险：核心原理与应用实践|钱文品 真心不错，数据结构原理+实际应用+单线程模型+集群（sentinel, codis, redis cluster）, 分布式锁等等讲的都十分透彻。 一本书的作用不就是系统性梳理，为读者打开一扇窗，读者想了解更多，可以自己通过这扇窗去Google。这本书的一个瑕疵是最后一章吧，写的仓促了。不过瑕不掩瑜。 技术综合TCP/IP详解 卷1：协议 读专业性书籍是一件很枯燥的事，我的建议就是把它作为一本手册，先浏览一遍，遇到问题再去详细查，高效。 Netty in Action 涉及到很多专业名词新概念看英文原版顺畅得多，第十五章 Choosing the right thread model 真是写得太好了。另外结合Ron Hitchens 写的《JAVA NIO》一起看对理解JAVA NIO和Netty还是很有帮助的 ZooKeeper 值得使用zookeeper的人员阅读, 对于zookeeper的内部机制及api进行了很详细的讲解, 后半部分深入地讲解了zookeeper中ensemble互相协作的流程, 及group等高级配置, 对zookeeper的高级应用及其它类似系统的设计都很有借鉴意义. 从Paxos到Zookeeper|倪超 分布式入门鼻祖，开始部分深入阐述cap和base理论，所有的分布式框架都是围绕这个理论的做平衡和取舍，中间 zk的原理、特性、实战也讲的非常清晰，同时讲cap理论在zk中是如何体现，更加深你对cap的理解. 深入理解Nginx（第2版）|陶辉 云里雾里的快速读了一遍，主要是读不懂，读完后的感受是设计的真好。 原本是抱着了解原理进而优化性能的想法来读的，却发现书中的内容都是讲源码，作者对源码的注释超级详细，非常适合开发者，但不适合使用者，给个五星好评是因为不想因为我这种菜鸡而埋没了高质量内容。 另外别人的代码写的真好看，即便是过程式语言程序也吊打我写的面向对象语言程序。 作者是zookeeper的活跃贡献者，而且是很资深的研究员，内容比较严谨而且较好的把握住了zk的精髓。书很薄，但是没有废话，选题是经过深思熟虑的。 深入剖析Tomcat 本书深入剖析Tomcat 4和Tomcat 5中的每个组件，并揭示其内部工作原理。通过学习本书，你将可以自行开发Tomcat组件，或者扩展已有的组件。 Tomcat是目前比较流行的Web服务器之一。作为一个开源和小型的轻量级应用服务器，Tomcat 易于使用，便于部署，但Tomcat本身是一个非常复杂的系统，包含了很多功能模块。这些功能模块构成了Tomcat的核心结构。本书从最基本的HTTP请求开始，直至使用JMX技术管理Tomcat中的应用程序，逐一剖析Tomcat的基本功能模块，并配以示例代码，使读者可以逐步实现自己的Web服务器。 深入理解计算机系统 | 布莱恩特 无论是内容还是纸张印刷，都是满分。计算机学科的集大成之作。引导你如何练内功的，算是高配版本的计算机导论，目的是釜底抽薪引出来操作系统、组成原理这些专业核心的课程。帮助我们按图索骥，点亮一个一个技能树。 架构探险分布式服务框架 | 李业兵 刚看前几章的时候，心里满脑子想得都是这特么贴一整页pom文件代码上来干鸡毛，又是骗稿费的，买亏了买亏了，后来到序列化那章开始，诶？还有那么点意思啊。 到服务注册中心和服务通讯，60块钱的书钱已经赚回来了。 知识是无价的，如果能花几十块钱帮你扫了几个盲区，那就是赚了。 深入分析JavaWeb技术内幕 | 许令波 与这本书相识大概是四年前是在老家的北方图书城里，当时看到目录的感觉是真的惊艳，对当时刚入行的自己来说，这简直就是为我量身定做的扫盲科普集啊。 但是可惜的是，这本书在后来却一直没机会读上。然后经过四年的打怪升级之后，这次的阅读体验依旧很好。 其中，java编译原理、 Servlet工作原理、 Tomcat、spring和iBatis这几章的收获很大。 前端jQuery 技术内幕| 高云 非常棒的一本书，大大降低了阅读jquery源码的难度（虽然还是非常难）。 Head First HTML与CSS（第2版） 翻了非常久的时间 断断续续 其实从头翻到尾 才发现一点都不难。 可我被自己的懒惰和畏难情绪给拖累了 简单说 我成了自己往前探索的负担。网页基础的语法基本都涵盖了 限于文本形态 知识点都没法像做题一样被反复地运用和复习到。通俗易懂 这不知算是多高的评价？ 作为入门真心算不错了 如果更有耐心 在翻完 HTML 后 对 CSS 部分最好是可以迅速过一遍 找案例练习估计更好 纸上得来终觉浅 总是这样。 JavaScript高级程序设计（第3版） JavaScript最基础的书籍，要看认真，慢慢地看，累计接近1000小时吧。而且对象与继承，性能优化，HTML5 api由于没有实践或缺乏代码阅读量导致看的很糊涂，不过以后可以遇到时再翻翻，或者看更专业的书。 深入理解ES6 Zakas的又一部杰作，他的作品最优秀的地方在于只是阐述，很少评价，这在帮助我们夯实基础时十分有意义，我也喜欢这种风格。 我是中英文参照阅读的，译本后半部分有一些文字上的纰漏，但是总体来说忠实原文，水平还是相当不错，希望再版时可以修复这些文字问题。 高性能JavaScript 还是挺不错的。尤其是对初学者。总结了好多程序方面的好习惯。 不过对于老手来说，这些常识已经深入骨髓了。 深入浅出Node.js|朴灵 本书是我看到现在对Node.JS技术原理和应用实践阐述的最深入，也最全面的一本书。鉴于作者也是淘宝的一位工程师，在技术总是国外好的大环境下，没有理由不给本书五颗星。 作者秉着授人于鱼不如授人于渔的精神，细致入微的从V8虚拟机，内存管理，字符串与Buffer的应用，异步编程的思路和原理这些基础的角度来解释Node.JS是如何工作的，比起市面上众多教你如何安装node，用几个包编写一些示例来比，本书绝对让人受益匪浅。 认真看完本书，几乎可以让你从一个Node的外行进阶到专家的水平。赞！ Vue跟React的技术栈的书不多，很多也是官方文档的照搬照抄，我觉得看官网吧哈哈。非技术类失踪的孩子 整本书的能量太密集了，像一个源源不断喷发的火山，读完怅然若失。最后几页，莱农从时间中回望，生命的真相被自己毫不留情的剖白，而即使是这样的时刻，她依然能再次在对莉拉的爱和嫉妒中被激发开始进行她最为重要、最可能留在时间之中的作品的创作，如此的勇气，诚实和坚韧……反正我已经喜欢她了。 而莉拉依然是个迷。她和莱农是相反的人，莱农会攫住一切填充自己，去成为，但莉拉对任何事情的投入都不会滋养自身，而是燃烧掉自己的一部分。 她的激情，超越一切的理解和视野与她的情绪化，她的恐惧，都让人困惑。莉拉是所有人的镜子，任何人在她面前都不得不面对自己；同时，是不是没有人，或者说莉拉没有允许任何人了解她？因为她在与外界和自己的对抗中也未能真正看见自己？ 人生|路遥 想着和平凡的世界一个调子，都是乡村，都是文革的尾巴，都是那点家长里短绝对真实。 我总觉得那是作者的真实写照，一切都是从自己的记忆中提炼出来的故事。 只不过根据高加林我总在思考劳动人民是否应该有文化，有文化了以后就开始痛苦，开始怀春悲秋，开始事逼，开始怨天尤人。 知识分子那些臭毛病显露无疑。 丝绸之路 | 彼得·弗兰科潘 书的颜值很高，厚厚的大开本，包装和纸张都不枉自己百元大洋。书名虽叫【丝绸之路】，但是读后发现其实是以中东为针，一路串起亚欧大陆各个文明两千多年间所发生的故事。 从史实、文化、宗教、政治、权力、金钱等多方面论述了以中亚和欧洲为主的发展史，信息量非常的大。每个章节的标题都用四个字直接道出当前世界的核心驱动，比如基督之路、铁蹄之路、西欧之路、纳粹之路、争霸之路。 视野广阔，大开大合，时间跨度可算是穿越千年中东。美中不足的是，中国作为丝绸之路东段上最为重要的国家，描述的篇幅却很少。 我的天才女友 | 埃莱娜·费兰特 来自意大利作家的小说，“那不勒斯”四部曲的第1部，讲述了两个女主人公莉拉和埃莱娜的少女时代。 相比七月与安生，跨度更大，情节也要丰富很多，但是作为一个男性阅读角度似乎get不到小说所评价那样优秀的点，代入感很好，时间已经过去好久，现在留在记忆中的还是如西西里的美丽传说般暖色调的意大利小镇上有两个小女生在平淡的生活。 长安十二时辰 | 马伯庸 开年第一单，阅读体验非常的好，完全是美国个人主义英雄大片的大唐版，而主人公张小敬身上却有着更多的坚忍和矛盾，中间有个片段，讲檀棋在元宵灯会的街上跟着张小敬，在万千盏灯笼一齐高高烛起，光彩明耀，火树银花中，看张小敬的背影显得很是落寞。 读完之后，这一幕仍然记忆犹新，靠整个故事的支撑，这一幕真的完全可以体会到落寞二字。 书中很认真的说了一些长安的城建和大唐的民俗，管制，可以看出来为了写出这本书，亲王的确是花费了不少心思的，很佩服。 一本非常非常适合改编成电影的小说（事实上也的确正在拍摄），值得推荐。 ps：2019年同名电视剧已经上线了… 布谷鸟的呼唤 | J·K·罗琳 大概三年前买的，今年回家整理新书架的时候发现了它，就带回杭州了。 故事情节比不上哈利波特，但是文笔是真的没得说，毕竟是能写出来哈利波特的人。 作为推理小说，怕是不及格，但是把它作为犯罪小说之类的非类型小说来看的话，其实阅读体验还是可以的。 欧洲：1453年以来的争霸之路 | 布伦丹·西姆斯 自文艺复兴之后，欧洲开始渐渐的走进地球文明的舞台正中心。 读到中间德意志民族的内政被周边国家的各种干涉，感觉德国和我们的兔子一样，是个多难的民族，所以统一之后思想家才会这么多，一战二战的德国，如果用兔子的一句话概括，我们走了一些弯路。 房思琪的初恋乐园 | 林奕含 正如文前李银河所说，林奕含属于老天爷赏口饭的那种人，非常有才华的、有灵气的一位年轻作者。我们应当感激，不用亲身经历，就可以看到世界的背面，难以想象出林每次去回忆，然后再去一步一步的描述出当时的心理活动，此间的痛苦。 最后，书中的话：忍耐不是美德，把忍耐当成美德是这个伪善的世界维持它扭曲的秩序的方式，生气才是美德。 毛泽东传 | 迪克·威尔逊 来自英国人的传记，可以当做记事表，而且就算有一些主观评价在里面，作为外国人难免有偏差，也不可信，毛公当称之为我等民族力挽狂澜第一人。 半小时漫画世界史 | 陈磊 和上一本中国史一样，阅读体验很轻松，如果是对这段历史毫无概念的话，真的砸墙推荐。但是如果是要有了一定的知识储备的话，那就没啥意思了，半小时也别指望能讲多深了。 巴黎和罗马真的是太值得去一次的了。 欧洲现代史：从文艺复兴到现在 | 约翰·梅里曼 耶鲁大学历史教授的课堂讲义，采用的是国别和编年混合风格，顺着历史发展的脉络逐一展开，又不失相互关联性，而不是简简单单的说几几年发生了什么，几月几日谁谁谁死了这些。 5个世纪中葡萄牙西班牙瑞典荷兰法国轮流崛起，俄国西化，德国统一，英国宗教改革，奥地利波兰土耳其相继衰落，文艺复兴，启蒙运动，航海时代，工业革命，世界大战，美苏冷战。 维多利亚女王拿破仑一世路易十四彼得大帝叶卡捷琳娜俾斯麦希特勒丘吉尔，当称人类群星闪耀时。 爱德华•巴纳德的堕落：毛姆短篇小说集1 | 毛姆 屯了毛姆这么多书，这次才是第一次看。 书的纸张倒是很有意思，600多页，却很轻。故事读起来倒像是个老朋友再和你讲故事，叨叨叨的从夏威夷讲到南美洲，又从西海岸讲到东南亚，讲故事的水平非常的高，几乎都是几段字下来，就把人带到了故事场景中。最喜欢的两篇是爱德华•巴纳德的堕落，赴宴之前，和最后的译后记。 一句顶一万句 | 刘震云 第八届茅盾文学奖获奖作品，叙事架构犹如一生二二生三三生万物绵绵不绝扩散开来，薄薄三百页，前后一百年，初看时以为《平凡的世界》，结局才发现是《百年孤独》，“生活是过以后，而不是过从前”。 生活的艺术家 | 李小龙 来自李小龙的一本散文集，是的，就是那个李小龙。 很难想到那个在电影里面喊着啊哒~的他，大学是专修哲学的。书中的文章大都是对于生活和哲学的思考，可以看到那个在大荧幕前面一秒五踢啊哒啊哒的背后，是一个冷静、理性、智慧、通达的李小龙。“我无法教你什么，只能帮助你探求你自己。除此之外，别无他法。” 穷查理宝典 | 查理芒格 查理芒格的思想集和演讲稿编，知识面跨学科，洞察力才能足够深，包括数学、物理、生物、历史、经济等这些硬学科，从而形成一个多学科的思维框架。 致富也不只是赚了多少钱那么简单，而是在道德品质、阅读能力和个人生活上全面提升的过程。应该专注于正在做的事情，多阅读，特别是传记，来和“伟人”交朋友，减少物欲，满足自己已经拥有的，不嫉妒别人。 汉密尔顿传 | 罗恩·切诺 我只能说汉密尔顿，这个被印在美元上的人，人生只能用精彩至极来形容了。 书中详细介绍了汉密尔顿在独立战争、费城制宪、宪法批准、首届国会以及建国初期等不同历史阶段中发挥的巨大作用，尤其是建国之初，在一切都没有先例的情况下，汉密尔顿为奠定美国联邦的政治体制、经济秩序和金融体系做出了巨大的贡献——建立美国信用体系，建立联邦银行，建立联邦税收体系，建立海关，建立海岸警卫队，以及促进制造业发展等。 在这本波澜壮阔的自传的最后，本以为能写上一大段对他的盖棺定论，然而却很平淡随意的用他写给艾丽萨的一封信作为了结尾，可能是不再需要作者去告诉书前的人他该如何评价，历史已经给出了答案。 “艾丽萨，你治愈了我此生因爱而生的伤痛。” 百年孤独|加西亚·马尔克斯 久负盛名的大作，读完只能说，果然只有这种书才配得上诺奖。 先前看《霍乱时期的爱情》，印象最深的就是华丽魔幻文笔和细腻的心理活动描写，到这本《百年孤独》，震撼的目瞪口呆，怎么能有人写得出这样的小说。 只能说，无论怎么列必读书籍，都绕不开此书。 月亮与六便士 毛大爷名气最具盛名的一本书，很易读的文学作品。 全篇小说都是从第一人称“我”的角度，对斯特里克兰德进行了主观的描写，从斯特里克兰德开始离家出走开始渐入佳境，毛姆在环球旅行中写作，以至于场景地点的代入感都非常强，带着读者登上塔希提岛上，在酒馆里和众人逐个聊起斯特里克兰德，“我”和读者一起，在一来一去的谈话中，了解到了这个天才最后的经历。后半生穷困潦倒的他在死的时候，肯定不会知道自己在死后的一个世纪，被称之为天才，画作也被收藏在美术馆作为镇馆之宝，流传百年。但他是自由的，没有遗憾的。 最后引用一段话，“只要在我的生活中能有变迁——变迁和无法预见的刺激，我是准备踏上怪石嶙峋的山崖，奔赴暗礁遍布的海滩的。” 股票作手回忆录|杰西·利弗莫尔 被誉为百年美股第一人，杰西·利弗莫尔的自传，五美元起家，到日赚一亿美金的投机之路，可以看到利弗莫尔在小的时候就对数字有着非常人的敏感和对波动线的记忆力，十多岁只身一人远走纽约，更见其杀伐果断之气。全书并没有讲操作细节，但是传主的做事风格很值得研究，时机、独立思考、判断、知错能改、以及鳄鱼般的耐心。 万历十五年 | 黄仁宇 一本表面上写历史，却涵盖当时的政治、经济、社会民俗、当世思想的大作，对中国历史上诸多王朝暗流下那道潜规则的分析和批判。格局之大，立意之高，实属罕见。 读罢全书，我们明白明王朝的覆灭是必然的，而后的满清，只不过是改朝换代，骨子里与前朝无异，灭亡也是迟早的。 我们的身上被锁住了一个牢固的枷锁，丢在泥坑，都在挣扎，越来越烂。 第五项修炼| 彼得·圣吉 前半部分理论，后半部分讲实战。捞干的来说，大局观的系统思考能力、增长极限和转移负担的自我超越能力、正向暗示的心智能力，拓展认知边界建立跨学科的思维架构能力。 海边的卡夫卡|村上春树 卡夫卡，舒伯特，艾希曼，琼尼沃克，乌鸦少年，短毛猫语，竹筴鱼雨，肠子迷宫，夏目漱石，雨月物语，俄狄浦斯。在这个世界上，不单调的东西让人很快厌倦，不让人厌倦的大多是单调的东西。 我的人生可以有把玩单调的时间，但没有忍受厌倦的余地,而大部分人分不出二者的差别。 孤独因你本身而千变万化。 白夜行|东野圭吾 把小说写成这样绝对是开挂了吧，除了连番登场的几十号人物，随处雕琢的大时代的背景也让人叹为观止。对人性的挖掘比起吉田修一还是弱一些，就是纯好看，从第一句开始吸住你逐渐往往里掉。 嫌疑人X的献身|东野圭吾 这个社会 每一个人都是时钟上的齿轮，为了自己的意愿，也不该牺牲掉他人，哪怕那是出于爱，一个错误尚且为错，付出更大的努力用更大错误也扭转不了的， 这毕竟不是数学的负负得正，逻辑之所以没法解决罪恶的问题，只因为最初就规避了人性。 追风筝的人|卡勒德·胡赛尼 为什么忠诚善良的人反而遭到这样的结局，面对阿米尔的污蔑，他和阿里选择离去。 当房屋需要他时，他又毅然决然的选择坚守，为了阿米尔能够得到父亲的赞许，哈桑却受到那样的凌辱，换来的却是懦弱的阿米尔的回避，身份，阶级，好可笑的头衔，生命与忠诚在那些虚无的名誉不值一提。 犹如草芥浮萍…. 恋情的终结 | 格雷厄姆 现在看的小说都不多了，而爱情小说更是少之又少，但幸运的是，这本和上一本霍乱时期的爱情一样，都是不可多得的大师之作。 小说情节简单来说就是爱上了个有妇之夫，然后阴差阳错私奔失败，接着分道扬镳直到多年之后的偶遇，最后女主患病而亡。 但文笔是真的细腻到不敢相信是个男人写的，书里穷尽了爱情中所有狂热的情感，狂热的爱，狂热的恨，狂热的猜疑，狂热的嫉妒，狂热的占有。 龙族I-IV|江南 我十六岁的时候，看《缥缈录》，心中念着那个拿着虎牙枪的少年。 如今我二十三岁了，看《龙族》，面对一堆白烂中二的吐槽不知所措。 就像拿枪的少年穿起了风衣，救美的英雄接受了金币。我看着商业化写作对一个作者的侵蚀和改变，这让我觉得难过极了。 三体I-Ⅲ|刘慈欣 《三体》就是那种让你在读完三部之后掩卷抬头，感觉眼中的世界都从此不一样了的书。 流浪地球|刘慈欣 觉得文笔胜于三体，且惊觉是三体之前的作品。 对于其中地球变轨后的生态变化仍存在疑惑，那段地球与木星擦肩表现力强,不错的作品。 全球通史 这种时间跨度如此之长的，有之前的《丝绸之路》和《人类简史》，但是无论是整体行文的架构、视野的宽度、以及分析思考的深度上来说，此书都要比这两本要优秀得多，尤其是到一战之前的部分。 幸亏之前大量零碎的知识点做背书，再遇此书建立整体体系，穿针引线，才有所体会到书前序中的”思接千载，视通万里”之感。 程序员的自我修养|俞甲子 / 石凡 / 潘爱民 讲的不错，将硬件与系统、机器层与实现层整合了起来，有了一个很清晰的视角。 颈椎病康复指南|董晓俊 出来打工不容易，大家照顾好自己。 活着|余华 为啥安利这个，大家懂就好了 我们一无所有|安东尼·马拉 艺术让我们不因真实而亡故，结构相当特别，像是在看电影。 讲述从苏联联邦到新俄罗斯近80年历史车轮下一些动人心魄的小人物微尘。 语言克制、平静，读来却十分疼痛，或是戏谑嘲讽像是苦中求乐，非常喜欢。 总结其实我觉得在我们现在这个浮躁的社会，大家闲暇时间都是刷抖音，逛淘宝，微博……他们都在一点点吞噬你的碎片时间，如果你尝试着去用碎片的时间看看书，我想时间久了你自然能体会这样的好处。 美团技术团队甚至会奖励读完一些书本的人，很多公司都有自己的小图书馆，我觉得挺好的。 我现在也认识很多作者，像程序员小灰，老钱这样的作者，都很不错，如果未来自己能达到写作的条件的话我也想写哈哈。 至于我为啥不敢懈怠……三歪（java3y作者）在我对面我真的不敢有丝毫放松，每次闲暇之余我准备拿起手机玩耍的时候，看到他在看书，我默默的放下手机，就是这样的人在不断鞭笞着我。 鸣谢自己技术群的小伙伴：很多书籍我没写进去，主要是记录被刷走太多了，我让大家私聊，结果都发群里了，我就懒得整理了，主要是没书评我没看过也不敢写。 豆瓣小伙伴：很多我没有的书籍我都是找的豆瓣书评。 阿里技术团队的小伙伴：文章有很多书评都是来自他。 博文视点：对文末抽奖的赞助 其实很多好书我都没写到，一时想不到，大家有喜欢的也留言让更多朋友看到嘛，我有空会修改文章。 还有就是本文主要的目的不是安利多少书，主要是想大家放下手机翻开你在角落积灰的书籍，你会发现里面有光的。 这周双十二有点小忙，年会的事情也紧锣密鼓的筹备着，我下周要是鸽了那…… 抽书！！！书名：Java系统性能优化实战 个人推荐理由： 20多个优化技巧：说明Java性能优化的各种方法。 30多个具有“坏味道”的代码片段：实战演练优化技巧。 常用的高性能工具：以Caffeine、Jackson、HikariCP为例进行讲解，并对其高性能的原因做一定的源码解析。 容易阅读的代码：从代码注释、代码分解和面向对象三方面讲解如何编写容易阅读的代码。 规则：抽两本，公众号「三太子敖丙」这个文章下面留言点赞排名前两位送两本，截止本周我发周报之前，公众号和掘金周六我会写周报。 觉得概率不大？ 月底会有一个文章抽30本书，至于送啥书，贫穷的我得好好想想。 点关注，不迷路好了各位，以上就是这篇文章的全部内容了，能看到这里的人呀，都是人才。 我后面会每周都更新几篇一线互联网大厂面试和常用技术栈相关的文章，非常感谢人才们能看到这里，如果这个文章写得还不错，觉得「敖丙」我有点东西的话 求点赞👍 求关注❤️ 求分享👥 对暖男我来说真的 非常有用！！！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！ 敖丙 | 文 【原创】 如果本篇博客有任何错误，请批评指教，不胜感激 ！ 文章每周持续更新，可以微信搜索「 三太子敖丙 」第一时间阅读和催更（比博客早一到两篇哟），本文 GitHub https://github.com/JavaFamily 已经收录，有一线大厂面试点思维导图，也整理了很多我的文档，欢迎Star和完善，大家面试可以参照考点复习，希望我们一起有点东西。","comments":true,"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://pandamin18436220.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"Pandas库","date":"2020-02-20T07:52:20.601Z","path":"2020/02/20/pandas库/","text":"pandas的作用我们知道numpy是矩阵运算的这么一个库，而pandas是数据处理这么一个库。其操作会基于numpy的内部函数。 pandas读取需要处理的文件 1234567891011121314151617import pandasfood_info=pandas.read_csv(\"food_info.csv\")print(type(food_info)) #DataFrame(类似于矩阵结构)print(food_info.dtypes) #int64,float64,object(字符型)print(help(pandas.read_csv))#显示数据food_info.head(m)#但m值不给定时，默认显示前5条数据food_info.head(n)#但n值不给定时，默认显示后5条数据food_info.colums()#显示列名food_info.shape()#显示行与列#取数据food_info.loc[m] #取第m行数据food_info.loc[m:n] #取第m-n行数据food_info.loc[a,b,c] #a,b,c行的数据ndb_col=foold_info[\"NDB_No\"] #打印列名对应的这一列 Numpy的基本使用下面介绍Numpy的基础知识与相关函数 创建数组及使用 12345678910111213141516171819202122232425262728#定义了一个二维数组，大小为（2，3）&gt;&gt;&gt; x=np.array([ [1.0,0.0,0.0], [0.,1.,2.] ])&gt;&gt;&gt; xarray([[1., 0., 0.], [0., 1., 2.]])#数组维度数&gt;&gt;&gt; x.ndim2#数组的维数，返回的格式(n,m),其中n为行数，m为列数&gt;&gt;&gt; x.shape(2, 3)#数组元素的总数&gt;&gt;&gt; x.size6#数组元素类型&gt;&gt;&gt; x.dtype#64位浮点型dtype('float64')#每个元素占有的字节大小 &gt;&gt;&gt; x.itemsize 8#数组元素的缓冲区&gt;&gt;&gt; x.data&lt;memory at 0x00000205227DAC18&gt; 知识点扩展: 创建序列数组的函数arrange和linspace。（range函数类似） arange(a,b,c) 参数表示(开始值，结束值，步长) linspace(a,b,c) 参数表示(开始值，结束值，元素数量) 调用reshape()可以指定形状 123456789101112&gt;&gt;&gt; arange(6).reshape(2,3)array([ [ 0, 1, 2], [ 3, 4, 5], [10, 11, 12] ])&gt;&gt;&gt; arange(1,5,2) array([1, 3, 5])&gt;&gt;&gt; arange(0,1,0.5) array([0. , 0.5, 1])&gt;&gt;&gt; linspace(0,2,9) array([0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) 特殊数组 zeros数组：全零数组，元素全为零。 ones数组：全1数组，元素全为1。 empty数组：空数组，元素全近似为0。 1234567891011121314151617181920212223242526&gt;&gt;&gt; zeros((3,4)) array([ [0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.] ])&gt;&gt;&gt; ones((2,3,4),dtype=int16) array([ [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ], [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] ], dtype=int16)&gt;&gt;&gt; empty((5,3)) array([ [6.23042070e-307, 1.42417221e-306, 1.37961641e-306], [1.11261027e-306, 1.11261502e-306, 1.42410839e-306], [7.56597770e-307, 6.23059726e-307, 1.42419530e-306], [7.56599128e-307, 1.11260144e-306, 6.89812281e-307], [2.22522596e-306, 2.22522596e-306, 2.56761491e-312] ]) 数组索引 Numpy数组通过索引访问12345678910111213141516171819&gt;&gt;&gt; c=arange(24).reshape(2,3,4)&gt;&gt;&gt; print(c)[ [ [ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] ] [ [12 13 14 15] [16 17 18 19] [20 21 22 23] ]]&gt;&gt;&gt; print(c[1,2,:]) [20 21 22 23]&gt;&gt;&gt; print(c[0,1,2]) 6 数组运算 数组的加减乘除以及乘方运算方式为:相应位置的元素分别进行运算。12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; a=array([20,30,40,50])&gt;&gt;&gt; aa=arange(1,5)&gt;&gt;&gt; a/aa array([20. , 15. , 13.33333333, 12.5 ])&gt;&gt;&gt; b=arange(4)&gt;&gt;&gt; b array([0, 1, 2, 3])&gt;&gt;&gt; c=a-b&gt;&gt;&gt; c array([20, 29, 38, 47])&gt;&gt;&gt; b**2 array([0, 1, 4, 9], dtype=int32)&gt;&gt;&gt; A=array([ [1,1], [0,1] ])&gt;&gt;&gt; B=array([ [2,0], [3,4] ])&gt;&gt;&gt; A*B array([ [2, 0], [0, 4] ])&gt;&gt;&gt; A.sum() 3&gt;&gt;&gt; A.min() 0&gt;&gt;&gt; A.max() 1 数组的拷贝 拷贝有浅拷贝和深拷贝两种; 浅拷贝通过数组变量的赋值完成,浅拷贝只拷贝数组的引用，如果对拷贝进行修改，源数组也将修改; 深拷贝使用数组对象的copy方法，会复制一份和源数组一样的数组，新数组与源数组会存放在不同内存位置，因此对新数组的修改不会影响源数组。 案例一(浅拷贝)1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; a=ones((2,3))&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 1.] ])&gt;&gt;&gt; b=a&gt;&gt;&gt; b[1,2]=2&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 2.] ])&gt;&gt;&gt; b array([ [1., 1., 1.], [1., 1., 2.] ])案例二(深拷贝)&gt;&gt;&gt; a=ones((2,3))&gt;&gt;&gt; b=a.copy()&gt;&gt;&gt; b[1,2]=2&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 1.] ])&gt;&gt;&gt; b array([ [1., 1., 1.], [1., 1., 2.] ]) 创建矩阵 矩阵与数组的区别Numpy的矩阵对象与数组对象相似。其不同之处在于，矩阵对象的计算遵循矩阵数学运算律。矩阵使用matrix函数创建。1234567891011121314151617&gt;&gt;&gt; A=matrix('1.0 2.0;3.0 4.0')&gt;&gt;&gt; A matrix([ [1., 2.], [3., 4.] ])&gt;&gt;&gt; B=matrix([ [1.0,2.0], [3.0,4.0] ])&gt;&gt;&gt; B matrix([ [1., 2.], [3., 4.] ])&gt;&gt;&gt; type(A) &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt; 矩阵运算 123456789101112131415161718&gt;&gt;&gt; A.T #转置 matrix([ [1., 3.], [2., 4.] ])&gt;&gt;&gt; x=matrix('5.0 7.0')&gt;&gt;&gt; y=x.T&gt;&gt;&gt; y matrix([ [5.], [7.] ])&gt;&gt;&gt; print(A*y) #矩阵乘法 [[26.] [38.]]&gt;&gt;&gt; print(A.I) #逆矩阵 [[-2. 1. ] [ 1.5 -0.5]] Numpy线性代数相关函数 numpy.dot() 此函数返回两个数组的点积。 对于二维向量，其等效于矩阵乘法。 对于一维数组，它是向量的内积。 对于 N 维数组，它是a的最后一个轴上的和与b的倒数第二个轴的乘积。 12345&gt;&gt;&gt; a=np.array([[1,2],[3,4]])&gt;&gt;&gt; b=np.array([[11,12],[13,14]])&gt;&gt;&gt; np.dot(a,b) array([[37, 40], #[[1*11+2*13, 1*12+2*14],[3*11+4*13, 3*12+4*14]] [85, 92]]) numpy.vdot() 此函数返回两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数id是多维数组，它会被展开。 12&gt;&gt;&gt; np.vdot(a,b) 130 #1*11+2*12+3*13+4*14=130 numpy.inner() 此函数返回一维数组的向量内积。 对于更高的维度，它返回最后一个轴上的和的乘积。 1234&gt;&gt;&gt; x=np.array([1,2,3])&gt;&gt;&gt; y=np.array([0,1,0])&gt;&gt;&gt; print(np.inner(x,y)) 2 # 等价于 1*0+2*1+3*0 numpy.matmul() 函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。 另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。 #对二维数组（列表），就相当于矩阵乘法 123456789101112131415161718192021&gt;&gt;&gt; a=[[1,0],[0,1]]&gt;&gt;&gt; b=[[4,1],[2,2]]&gt;&gt;&gt; print(np.matmul(a,b))[[4 1][2 2]]#二维和一维运算&gt;&gt;&gt; a=[[1,0],[0,1]]&gt;&gt;&gt; b=[1,2]&gt;&gt;&gt; print(np.matmul(a,b)) [1 2]&gt;&gt;&gt; print(np.matmul(b,a)) [1 2]#维度大于2的&gt;&gt;&gt; a=np.arange(8).reshape(2,2,2)&gt;&gt;&gt; b=np.arange(4).reshape(2,2)&gt;&gt;&gt; print(np.matmul(a,b)) [[[ 2 3] [ 6 11]] [[10 19] [14 27]]] numpy.linalg.det() 行列式在线性代数中是非常有用的值。 它从方阵的对角元素计算。 对于 2×2 矩阵，它是左上和右下元素的乘积与其他两个的乘积的差。 换句话说，对于矩阵[[a，b]，[c，d]]，行列式计算为ad-bc。 较大的方阵被认为是 2×2 矩阵的组合。 numpy.linalg.det()函数计算输入矩阵的行列式。 123456789101112&gt;&gt;&gt; a=np.array([[1,2],[3,4]])&gt;&gt;&gt; print(np.linalg.det(a)) -2.0000000000000004&gt;&gt;&gt; b=np.array([[6,1,1],[4,-2,5],[2,8,7]])&gt;&gt;&gt; print(b) [[ 6 1 1] [ 4 -2 5] [ 2 8 7]]&gt;&gt;&gt; print(np.linalg.det(b)) -306.0&gt;&gt;&gt; print(6*(-2*7-5*8)-1*(4*7-5*2)+(4*8- -2*2)) -306 numpy.linalg.solve() 该函数给出了矩阵形式的线性方程的解。 1234567891011121314151617181920212223&gt;&gt;&gt; x=np.array([[1,2],[3,4]])&gt;&gt;&gt; y=np.linalg.inv(x)&gt;&gt;&gt; x array([[1, 2], [3, 4]])&gt;&gt;&gt; y array([[-2. , 1. ], [ 1.5, -0.5]])&gt;&gt;&gt; np.dot(x,y) array([[1.0000000e+00, 0.0000000e+00], [8.8817842e-16, 1.0000000e+00]]) a=np.array([[1,1,1],[0,2,5],[2,5,-1]]) print('数组a:') print(a) ainv=np.linalg.inv(a) print('a的逆矩阵') print(ainv) print('矩阵b:') b=np.array([[6],[-4],[27]]) print(b) print('计算：A^(-1)B:') x=np.linalg.solve(a,b) print(x) 数组分割 使用hsplit你能将数组沿着它的Y轴分割，或者指定返回相同形状数组的个数，或者指定在哪些列后发生分割。vsplit沿着X轴分割。12345678910111213141516171819202122232425262728293031323334&gt;&gt;&gt; a = floor(10*random.random((2,12)))&gt;&gt;&gt; a array([ [ 8., 8., 3., 9., 0., 4., 3., 0., 0., 6., 4., 4.], [ 0., 3., 2., 9., 6., 0., 4., 5., 7., 5., 1., 4.] ])&gt;&gt;&gt; hsplit(a,3) # Split a into 3 [array([ [ 8., 8., 3., 9.], [ 0., 3., 2., 9.] ]), array([ [ 0., 4., 3., 0.], [ 6., 0., 4., 5.] ]), array([ [ 0., 6., 4., 4.], [ 7., 5., 1., 4.]] )]&gt;&gt;&gt; hsplit(a,(3,4)) # Split a after the third and the fourth column [ array([ [ 8., 8., 3.], [ 0., 3., 2.] ]), array([ [ 9.], [ 9.] ]), array([ [ 0., 4., 3., 0., 0., 6., 4., 4.], [ 6., 0., 4., 5., 7., 5., 1., 4.] ]) ] 官方文档链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"https://pandamin18436220.github.io/tags/pandas/"}]},{"title":"算法与设计之基本概念","date":"2020-02-19T10:53:41.498Z","path":"2020/02/19/算法与设计/","text":"算法概述 算法定义的是计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。这样算法就是把输入转换成输出的计算步骤的一个序列。我们也可以把算法看成是用于求解良说明的计算问题的工具。一般来说，问题陈述说明了期望的输入/输出关系。算法则描述一个特定的计算过程来实现该输入/输出关系。 若对每个输入实例算法都以正确的输出停机，则称该算法是正确的，并称正确的算法解决了给定的计算问题。不正确的算法对某些输入实例可能根本不停机，也可能以不正确的回答停机。与人们期望的相反，不正确的算法只要其错误率可控有时可能是有用的，但是通常我们只关心正确的算法。算法可以用自然语言说明，也可以说明成计算机程序，甚至说明成硬件设计。唯一的要求是这个说明必须精确描述所要遵循的计算过程。虽然算法可以解决各式各样的问题，但是算法所解决的问题有的两个共同的特征： 存在许多候选解，但绝大多数候选解都没有解决手头的问题。寻找一个真正的解或一个最好的解可能是一个很大的挑战。存在实际应用。比如一家运输公司（如公路运输或铁路运输公司）对如何在公路或铁路网中找出最短路径，有着经济方面的利益，因为采用的路径越短，其人力和燃料的开销就越低；互联网上的一个路由结点为了快速地发送一条消息可能需要寻找通过网络的最短路径。希望从纽约开车去波士顿的人可能想从一个恰当的网站寻找开车方向，或者开车时她可能使用其GPS。 假设计算机是无限快的并且计算机存储器是免费的，你还有什么理由来研究算法吗？即使只是因为你还想证明你的解法会终止并以正确的答案终止，那么回答也是肯定的。如果计算机无限快，那么用于求解某个问题的任何正确的方法都行。也许你希望你的实现在好的软件工程实践的范围内（例如，你的实现应该具有良好的设计与文档），但是你最常使用的是最容易实现的方法。当然，计算机也许是快的，但它们不是无限快。存储器也许是廉价的，但不是免费的。所以计算时间是一种有限资源，存储器中的空间也一样。你应该明智地使用这些资源，在时间或空间方面有效的算法将帮助你这样使用资源。为求解相同问题而设计的不同算法在效率方面常常具有显著的差别。这些差别可能比由于硬件和软件造成的差别要重要得多。 上面的例子表明我们应该像计算机硬件一样把算法看成是一种技术。整个系统的性能不但依赖于选择快速的硬件而且还依赖于选择有效的算法。正如其他计算机技术正在快速推进一样，算法也在快速发展。 你也许想知道相对其他先进的计算机技术（如：先进的计算机体系结构与制造技术、易于使用、直观的图形用户界面（GUI）、面向对象的系统、集成的万维网技术、有线与无线网络的快速组网等），算法对于当代计算机是否真的那么重要？回答是肯定的。虽然某些应用在应用层不明确需要算法内容（如某些简单的基于万维网的应用），但是许多应用确实需要算法内容。例如，考虑一种基于万维网的服务，它确定如何从一个位置旅行到另一个位置。其实现依赖于快速的硬件、一个图形用户界面、广域网，还可能依赖于面向对象技术。然而，对某些操作，如寻找路线（可能使用最短路径算法）、描绘地图、插入地址，它还是需要算法。而且，即使是那些在应用层不需要算法内容的应用也高度依赖于算法。该应用依赖于快速的硬件吗？硬件设计用到算法。该应用依赖于图形用户界面吗？任何图形用户界面的设计都依赖于算法。该应用依赖于网络吗？网络中的路由高度依赖于算法。该应用采用一种不同于机器代码的语言来书写吗？那么它被某个编译器、解释器或汇编器处理过，所有这些都广泛地使用算法。 算法是当代计算机中使用的大多数技术的核心。进一步，随着计算机能力的不断增强，我们使用计算机来求解比以前更大的问题。正如我们在上面对插入排序与归并排序的比较中所看到的，正是在较大问题规模时，算法之间效率的差别才变得特别显著。是否具有算法知识与技术的坚实基础是区分真正熟练的程序员与初学者的一个特征。使用现代计算技术，如果你对算法懂得不多，你也可以完成一些任务，但是，如果有一个好的算法背景，那么你可以做的事情就多得多 分析算法（以插入排序作为引入) 相信大家都玩过纸牌。插入排序的工作方式就像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面朝下（意味着我们不在翻开之前并不知道下一张牌是多大的）。然后，我们每次从那些牌中选出一张牌，并把它插入到正确的位置（一般我们认为左边的最小），我们从左到右（或从右到左）将它与已在手中的每张牌进行比较。 动态演示 算法分析 对于插入排序，我们将伪代码的过程命名为INSERTION-SORT其中 12345678910111213141516/*参数是A[1..N]，为长度n的一个需要排序的序列。A.length表示数组A中元素的数量该算法在数组A中重排这些数，在任何时候，最多只有其中的常数个数字存储在数组外面。等INSERTION-SORT结束时，输入数组A包含排序好的输出序列。*/INSERTION-SORT（A）1 for j=2 to A.length2 key = A[j]3 //Insert A[j] into the sorted sequence A[1..j-1]4 i = j - 15 while i &gt; 0 and A[i] &gt; key6 A[i+1] = A[i]7 i = i - 18 A[i+1]=key INSERTION-SORT（A） 代价 次数 for j=2 to A.length c1 n key = A[j] c2 n - 1 i = j - 1 c3 n - 1 while i &gt; 0 and A[i] &gt; key c4 $\\sum_{j=2}^n{t^j}$ A[i+1] = A[i] c5 $\\sum_{j=2}^n{(t^j-1)}$ i = i - 1 c6 $\\sum_{j=2}^n{(t^j-1)}$ A[i+1]=key c7 n - 1 该算法的运行时间是执行每条语句的运行时间之和。基于此，我们可以计算在具有n个值输入上INSERTION-SORT(A)的运行时间T[n]，我们将代价与次数列对应元素之积求和，得: T(n)=c1n+c2(n-1)+c3(n-1)+c4 $\\sum_{j=2}^n{t^j}$ +c5 $\\sum_{j=2}^n{(t^j-1)}$ +c6 $\\sum_{j=2}^n{(t^j-1)}$ +c7(n-1) 最好的情况下: =对于给定的n个需要排序的，若输入已排序，则出现最佳情况。这个时候，对于j=2,3，….,n，可以发现，当i取初值j-1时，有A[i]≤keyA[i]≤key。从而对j=2,3,…，n有tj=1,也就是说只需要比较一次。 假设现在你左手中的牌都是已经排好序了的，而且是从小到大排序，现在你手上拿了一张牌，比你左手上的牌最右边（即是你手中牌中最大）还要大，那么你一定要保证牌是从小到大的排序，必然会把牌之间放在你牌的最右边。而这个过程，你只是和你本来有的牌的最大一张比较了一次。 所以最好的情况下的时间复杂度Tn为: 123T(n)=c1n+c2(n?1)+c3(n?1)+c4(n?1)+c7(n?1)=(c1+c2+c3+c4+c7)n?(c1+c2+c3+c4)T(n)=c1n+c2(n?1)+c3(n?1)+c4(n?1)+c7(n?1)=(c1+c2+c3+c4+c7)n?(c1+c2+c3+c4)即 T(n)=an+b 其中a和b依赖于语句代价 ci 我们可以得出一个结论： 在最好情况下，插入排序的时间复杂度在O(n)，即线性时间上完成排序 最坏的情况下: 若输入数组已方向排序，即按照递减排序排好了序,则导致最坏情况。我们必须把每个元素A[j]与整个已排序子 数组A[1..j-1]中的每个元素都要进行比较，所以对j=2,3,…,n，有tj=j。我估计有人问为什么tj=j，那么我就 这样告诉你吧: tj是while语句进行比较语句的执行的次数，最后一次是进行i&gt;0的判断，所以A[1..j-1]与A[j]实际上进行j-1次比较，那么为什么进行j-1次比较呢，我们这么想，j代表我要加入第几张牌，我就以j=3来说，我即将加入第3张牌进入我左手的牌中（左手有两张牌，已经升序排列了好了），而这个牌比前面2个都要小，那么我是需要和比较两次才知道的，所以一共比较j-1次。 值得注意的是，这时候的是 $\\sum_{j=2}^n{j}$=n(n+1)/2-1 以及 $\\sum_{j=2}^n{(j-1)}$=n(n-1)/2 上述是求和递推公式，相关数学知识参考下期文章。 所以最坏的情况下的时间复杂度Tn为: T(n)=c1n+c2(n-1)+c3(n-1)+c4(n(n+1)/2-1)+c5(n(n-1)/2)+c6(n(n-1)/2)+c7(n-1) =(c4/2+c5/2+c6/2)n^2+(c1+c2+c3+c4/2-c5/2-c6/2+c7)n-(c2+c3+c4+c7) 即 T(n)=an^2+bn+c其中a,b和c依赖于语句代价ci我们可以得出一个结论： 在最坏的情况下，插入排序时间复杂性O(n^2),即n的二次函数上完成排序。平均情况和最坏情况差不多，复杂度也在O(n2) 渐进记号12 针对资源管理的角度https://blog.csdn.net/YuYunTan/article/details/52026857?utm_source=itdadao&amp;utm_medium=referral https://blog.csdn.net/hy592070616/article/details/92102395 https://wenku.baidu.com/view/390d9d5cb04e852458fb770bf78a6529657d3539.html https://blog.csdn.net/weixin_44961794/article/details/90106570 分治法贪心法","comments":true,"tags":[{"name":"算法与设计","slug":"算法与设计","permalink":"https://pandamin18436220.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}]},{"title":"数学建模前的准备","date":"2020-02-18T03:35:55.879Z","path":"2020/02/18/数学建模前的准备/","text":"什么是数学模型数学模型是对于现实世界的一个特定对象，一个特定目的，根据特有的内在规律，做出一些必要的假设，运用适当的教学工具得到一个对问题近似刻划的数学结构，以便于人们更深刻地认识所研究的对象。数学建模常用的方法 解析几何，代数方程，微积分，微分方程，差分方程，概率统计，层次分析，插值与拟合，综合评价，优化方法，数据处理与计算等。 另外了解排队论，对策论，决策论，模拟评判等方面的知识。 数学建模的必备数学知识 高等数学，微分方程，运筹学，线性代数，概率统计，数值计算等。","comments":true,"tags":[{"name":"数学建模","slug":"数学建模","permalink":"https://pandamin18436220.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}]},{"title":"操作系统","date":"2020-02-18T01:17:17.335Z","path":"2020/02/18/操作系统/","text":"操作系统的概述 操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机工作和资源分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统的最基本的系统软件。 即分为三个作用： 控制和管理计算机系统的硬件和软件资源 组织和调度计算机工作和资源分配 提供给用户和其他软件方便的接口和环境 操作系统的四种理解 针对资源管理的角度 API接口是提供给操作系统级程序员，基本的操作命令是提供给用户。 所谓的脱机方式是在不在CPU的调度下工作；相应的联机方式是指在CPU的调度下使用的！ 这门课程主要是研究OS非功能性需求这一块 线程与进程的区别：线程是共享进程资源的，是由进程调度的最小单位，而进程是是系统拥有资源的最小实体！ 操作系统分类及特点进程管理存储管理设备管理文件管理作业管理","comments":true,"tags":[{"name":"存储","slug":"存储","permalink":"https://pandamin18436220.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"设备","slug":"设备","permalink":"https://pandamin18436220.github.io/tags/%E8%AE%BE%E5%A4%87/"},{"name":"文件","slug":"文件","permalink":"https://pandamin18436220.github.io/tags/%E6%96%87%E4%BB%B6/"},{"name":"作业","slug":"作业","permalink":"https://pandamin18436220.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"操作系统","slug":"操作系统","permalink":"https://pandamin18436220.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程","slug":"进程","permalink":"https://pandamin18436220.github.io/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"Anaconda下载命令","date":"2020-02-17T09:12:03.677Z","path":"2020/02/17/Anaconda下载命令/","text":"Anaconda介绍 Anaconda就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。 主要是提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令conda来进行package和environment的管理，并且已经包含了Python和相关的配套工具。 Anaconda的命令 conda list #查看已安装好的包 conda install +包名(如numpy) #安装相关包 anaconda search -t conda tensorflow #网络寻找tensorflow的版本 anaconda show +版本名 #查看安装此版本的tensorflow的命令 conda install –channel https://conda.anaconda.org/dhirschfeld tensorflow #复制执行此命令，进行安装操作","comments":true,"tags":[{"name":"机器学习，Anaconda","slug":"机器学习，Anaconda","permalink":"https://pandamin18436220.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%8CAnaconda/"}]},{"title":"jupyter闪退问题","date":"2020-02-17T08:53:22.667Z","path":"2020/02/17/jupyter闪退问题/","text":"问题描述本系统为 win10，安装 Anaconda3 后，可以正常使用 jupyter notebook ，后来因为安装插件，再启动Jupyter notebook 就出现闪退现象，后来发现，库的升级还有一些其他操作也会造成闪退现象，当然，可以重装Anaconda进行修复，可是通过查询和个人实践，验证以下三种方法可以重新启动 jupyter notebook： 问题解决第一种：命令行启动 启动Anaconda Prompt，输入命令jupyter notebook 即可进入 jupyter notebook；第二种：修改jupyter notbook快捷方式的目标内容 右键单击开始菜单中Anaconda下的 Jupyter notebook。 更多 - 打开文件位置，右键 Jupyter notebook 快捷方式，选择属性，修改目标内容为自己 Anaconda3 的安装目录下： .\\Anaconda3\\Scripts\\jupyter-notebook.exe之后应用。 关闭后，再点击开始菜单中 jupyter notebook 快捷方式便可启动。 说明：本人的Anaconda3安装在C:\\ProgramData\\下。 Anaconda3下jupyter notebook快捷方式的目标的原有内容如下： C:\\ProgramData\\Anaconda3\\python.exe C:\\ProgramData\\Anaconda3\\cwp.py C:\\ProgramData\\Anaconda3 C:\\ProgramData\\Anaconda3\\python.exe C:\\ProgramData\\Anaconda3\\Scripts\\jupyter-notebook-script.py &quot;%USERPROFILE%/&quot;为什么闪退呢是因为“jupyter-notebook-script.py”没有了。打开目录“C:\\ProgramData\\Anaconda3\\Scripts”，里面没有了“jupyter-notebook-script.py”，但有一项“jupyter-notebook.exe”，直接双击这一项也可启动jupyter notebook，所以把jupyter notebook快捷方式的目标改为该文件。第三种：修复jupyter-notebook-script.py文件。 刚才说过为什么会闪退，就是缺少了文件“jupyter-notebook-script.py”，那就重新生成一下。 启动Anaconda Prompt，输入命令：jupyter notebook --generate-config。 或者拷贝现成的文件到Anaconda3安装目录的Scripts下，我的安装目录“C:\\ProgramData\\Anaconda3\\Scripts”，即补充完整路径C:\\ProgramData\\Anaconda3\\Scripts\\jupyter-notebook-script.py。 附加说明：jupyter notebook --generate-config 命令是生成jupyter notebook的配置文件，修改配置文件还可以修改Anaconda中JupyterNotebook的默认工作路径具体修改配置文件方法 打开 Anaconda Prompt，输入jupyter notebook –generate-config 这个命令的作用是生成 Jupyter notebook 的配置文件。如果你是第一次运行，会直接生成这个文件。如果曾经运行过这个命令，就会像下图一样问你时候要覆盖原来的文件。这个时候不用理会。我们的主要目的只是为了找到这个文件的路径。 根据第一步找到 jupyter_notebook_config.py 的路径并打开此文件。找到 c.NotebookApp.notebook_dir 这个变量，将你希望的路径赋值给这个变量，并删除这一行前面的“#”。修改后如下： 一定要确保删除 “#”，取消这一行的注释模式。 这一行代码前不能有空格。 路径一定要是已经存在的，否则会闪退。且路径要用英文单引号括起来。 改完后保存。再次通过 Anaconda Navigator 进入 Jupyter Notebook 的时候会发现默认路径已经更改。 然而，如果你直接通过 Jupyter Notebook 的快捷方式进入，默认目录还是原来那个。如果需要修改，还需要进行如下步骤： 找到快捷方式，右键打开属性，将“目标”最后面的 “%USERPROFILE%” 删除就可以了。 遇到那些坑及推测的原因并不是说这些方法是错误的，只是大概不适合我自己的系统和环境而已。 网上说打开 “cmd”，运行 “jupyter notebook –generate-config” 命令 可能是因为 Jupyter Notebook 是通过 Anaconda 安装的，所以 Anaconda 环境外没有配置环境变量。 根据网上贴出的路径直接查找 “Jupyter_notebook_config.py” 文件，发现查无此文件。 再次提醒，如果从没运行过 generate 命令，是不会有这个配置文件的。 据说，修改 Anaconda 安装目录下 etc\\jupyter 文件夹中的 jupyter_notebook_config.json 文件也是可以的。但是，我的文件打开是空的。我也不知道为什么。 据说可以只改快捷方式的属性：“目标”那里的 “%USERPROFILE%” 删除，“起始位置”改成你希望的路径。 在不改 jupyter_notebook_config.py 文件的情况下，仅改变这两个地方，并不起任何作用。如果改了 jupyter_notebook_config.py，这两个地方都不改的话，从这个快捷方式进入 Jupyter Notebook 会进入默认路径，用 Anaconda Navigator 启动就会进入改变后的路径。对“目标”栏进行改动后，则从快捷方式进入，也会进入修改后的路径。“起始位置”那里的值，改不改都不影响。","comments":true,"tags":[{"name":"问题解决，机器学习","slug":"问题解决，机器学习","permalink":"https://pandamin18436220.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java学习","date":"2020-02-17T08:29:58.157Z","path":"2020/02/17/Java学习/","text":"大数据概念大数据（big data），指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。 大数据的特点 Volume（大量）：截至2017年，人类生产的所有印刷材料的数据量是200PB，而历史上全人类总共说过的话的数据量大约是5EB。当前，典型个人计算机硬盘的容量为TB量级，而一些大企业的数据量已经接近EB量级。 Velocity（高速）：这是大数据区分于传统数据挖掘的最显著特征。根据IDC的“数字宇宙”的报告，预计到2020年，全球数据使用量将达到35.2ZB。在如此海量的数据面前，处理数据的效率就是企业的生命。 Variety（多样）：这种类型的多样性也让数据被分为结构化数据和非结构化数据。相对于以往便于存储的以数据库/文本为主的结构化数据，非结构化数据越来越多，包括网络日志、音频、视频、图片、地理位置信息等，这些多类型的数据对数据的处理能力提出了更高要求。 Value（低价值密度）：价值密度的高低与数据总量的大小成反比。比如，在一天监控视频中，我们只关心晚上在床上健身那一分钟，如何快速对有价值数据“提纯”成为目前大数据背景下待解决的难题。 大数据的应用 O2O：百度大数据+平台通过先进的线上线下打通技术和客流分析能力，助力商家精细化运营，提升销量。 *零售：探索用户价值，提供个性化服务解决方案；贯穿网络与实体零售，携手创造极致体验。经典案例，子尿布+啤酒。 旅游：深度结合百度独有大数据能力与旅游行业需求，共建旅游产业智慧管理、智慧服务和智慧营销的未来。 商品广告推荐：给用户推荐访问过的商品广告类型 房产：大数据全面助力房地产行业，打造精准投策与营销，选出更合适的地，建造更合适的楼，卖给更合适的人。 保险：海量数据挖掘及风险预测，助力保险行业精准营销，提升精细化定价能力。 金融：多维度体现用户特征，帮助金融机构推荐优质客户，防范欺诈风险。 移动联通：移动联通：根据用户年龄、职业、消费情况，分析统计哪种套餐适合哪类人群。对市场人群精准定制。 人工智能 课后答案","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"https://pandamin18436220.github.io/tags/Java/"}]},{"title":"数据分析与机器学习","date":"2020-02-17T08:27:11.368Z","path":"2020/02/17/数据分析与机器学习/","text":"numpy知识点 读取文件的函数：numpy.getfromtxt(“文件路径”,delimiter=”,”,dtpye=str,skip_header=1) 返回是一个矩阵 可以通过print(help(函数名)),获取函数的API介绍 索引的几种方法 12345678910vector=numpy.array([ [ 0, 1, 2], [ 3, 4, 5], [10, 11, 12] ])#vector[行,列]print(vector[0,3]) #取第一行第三列的元素print(vector[0,0:3]) #取第一行第三列的前两个元素print(vector[:,1]) #取第一列的所有元素 bool值做索引下标 123vector==10 #会返回对应位置为bool值的arrayvector[vector==10] #会返回对应位置等于10的值:[10]vector[vector==10;] #会返回对应位置等于10的这一行 array的类型转化 123print(vector.dtype) #int32vector=vector.astype(float)print(vector.dtype) #float64 array的函数 相关函数可以通过print(help(numpy.array))去查看API 123456789101112131415161718192021222324vector.min() #求最小最vector.sum(axis=1) #求每一行的和vector.sum(axis=0) #求每一列的和vector.argmax(axis=0) #求每一列的最大值 返回索引值print(np.arange(15))#[0,1,...,14]向量形式#转化成矩阵形式vector=np.arange(15).reshape(3,5)#转化成三行五列的形式#矩阵转回向量vector.ravel()#通过shape查看形式print(vector.shape())#通过vector.ndim查看维度#通过vector.size()查看共有多少个元素#通过vector.dtype.name查看元素类型名:'innt32'#初始化矩阵np.zero((3,4),dtype=np.int32)np.ones((3,4),dtype=np.int32)np.array(5,11,5) #[5,10]np.random.random((2,3)) #np.random是一个模块，然后在通过点random函数np.linspace(0,6,100) #从0~6平均取100个数字 求解np的幂和根号 1234#计算幂np.exp(B)#计算根号np.sqrt(B) 拼接操作 123456a=np.floor(10*np.random.random((2,2)))b=np.floor(10*np.random.random((2,2)))#横着拼接np.hstack((a,b))#纵着拼接np.vstack((a,b)) 分割操作 12345#横着拼接1. np.hsplit((a,3))#将a横着切三份2. np.hsplit((a,(m,n)))#将a在光标3和4的地方切#纵着拼接np.vstack((a,3)) 复制操作 123456#浅复制a=np.arrange(12)b=a #a与b指向的位置一样也是一套数值c=a.view() #a与c指向的位置不一样但是是一套数值#深复制d=a.copy() #a与d指向的位置不一样,数值也不一样 排序和索引 123456789101112131415a=np.array( [ [4,3,5], [1,2,6] ])b=np.sort(a,axis=1)#按行排序c=np.array([4,3,1,2])d=np.argsort(c)#得到排序后的索引：[2,3,1,0]e=d[d] #得到排好序的数组：[1,2,3,4]data=np.sin(np.arrange((20)).reshape(5,4))ind=data.argmax(axis=0) #查找每一列的最大值并返回索引行data_max=data[ind,range(data.shape[1])] #根据索引行和shape[1]列去索引data数值 数值扩展1np.tile(a,(m,n))#将a的行扩展m倍，a的列扩展n倍","comments":true,"tags":[{"name":"机器学习，数据分析","slug":"机器学习，数据分析","permalink":"https://pandamin18436220.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]},{"title":"大数据概论","date":"2020-02-17T07:47:49.724Z","path":"2020/02/17/大数据概论/","text":"大数据概念大数据（big data），指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。 大数据的特点 Volume（大量）：截至2017年，人类生产的所有印刷材料的数据量是200PB，而历史上全人类总共说过的话的数据量大约是5EB。当前，典型个人计算机硬盘的容量为TB量级，而一些大企业的数据量已经接近EB量级。 Velocity（高速）：这是大数据区分于传统数据挖掘的最显著特征。根据IDC的“数字宇宙”的报告，预计到2020年，全球数据使用量将达到35.2ZB。在如此海量的数据面前，处理数据的效率就是企业的生命。 Variety（多样）：这种类型的多样性也让数据被分为结构化数据和非结构化数据。相对于以往便于存储的以数据库/文本为主的结构化数据，非结构化数据越来越多，包括网络日志、音频、视频、图片、地理位置信息等，这些多类型的数据对数据的处理能力提出了更高要求。 Value（低价值密度）：价值密度的高低与数据总量的大小成反比。比如，在一天监控视频中，我们只关心晚上在床上健身那一分钟，如何快速对有价值数据“提纯”成为目前大数据背景下待解决的难题。 大数据的应用 O2O：百度大数据+平台通过先进的线上线下打通技术和客流分析能力，助力商家精细化运营，提升销量。 零售：探索用户价值，提供个性化服务解决方案；贯穿网络与实体零售，携手创造极致体验。经典案例，子尿布+啤酒。 旅游：深度结合百度独有大数据能力与旅游行业需求，共建旅游产业智慧管理、智慧服务和智慧营销的未来。 商品广告推荐：给用户推荐访问过的商品广告类型 房产：大数据全面助力房地产行业，打造精准投策与营销，选出更合适的地，建造更合适的楼，卖给更合适的人。 保险：海量数据挖掘及风险预测，助力保险行业精准营销，提升精细化定价能力。 金融：多维度体现用户特征，帮助金融机构推荐优质客户，防范欺诈风险。 移动联通：移动联通：根据用户年龄、职业、消费情况，分析统计哪种套餐适合哪类人群。对市场人群精准定制。 人工智能 云计算的概念 为什么会需要“云”传统的应用正在变得越来越复杂：需要支持更多的用户，需要更强的计算能力，需要更加稳定安全等等，而为了支撑这些不断增长的需求，企业不得不去购买各类硬件设备（服务器，存储，带宽等等）和软件（数据库，中间件等等），另外还需要组建一个完整的运维团队来支持这些设备或软件的正常运作，这些维护工作就包括安装、配置、测试、运行、升级以及保证系统的安全等。便会发现支持这些应用的开销变得非常巨大，而且它们的费用会随着你应用的数量或规模的增加而不断提高。这也是为什么即使是在那些拥有很出色IT部门的大企业中，那些用户仍在不断抱怨他们所使用的系统难以满足他们的需求。而对于那些中小规模的企业，甚至个人创业者来说，创造软件产品的运维成本就更加难以承受了。 简而言之：云计算的资源是动态扩展且虚拟化的，通过互联网提供，终端用户不需要了解云中基础设施的细节，不必具有专业的云技术知识，也无须直接进行控制，只要关注自身真正需要什么样的资源以及如何通过网络来获得相应的服务即可。云计算，应运而生——更大、更快、更强 针对上述问题解决方案便是“云计算”！将应用部署到云端后，可以不必再关注那些令人头疼的硬件和软件问题，它们会由云服务提供商的专业团队去解决。使用的是共享的硬件，这意味着像使用一个工具一样去利用云服务（就像插上插座，你就能使用电一样简单）。只需要按照你的需要来支付相应的费用，而关于软件的更新，资源的按需扩展都能自动完成。 云计算的五点特点 大规模、分布式“云”一般具有相当的规模，一些知名的云供应商如Google云计算、Amazon、IBM、微软、阿里等也都拥能拥有上百万级的服务器规模。而依靠这些分布式的服务器所构建起来的“云”能够为使用者提供前所未有的计算能力。虚拟化云计算都会采用虚拟化技术，用户并不需要关注具体的硬件实体，只需要选择一家云服务提供商，注册一个账号，登陆到它们的云控制台，去购买和配置你需要的服务（比如 云服务器，云存储，CDN等等），再为你的应用做一些简单的配置之后，你就可以让你的应用对外服务了，这比传统的在企业的数据中心去部署一套应用要简单方便得多。而且你可以随时随地通过你的PC或移动设备来控制你的资源，这就好像是云服务商为每一个用户都提供了一个IDC(Internet Data Center)一样。高可用性和扩展性那些知名的云计算供应商一般都会采用数据多副本容错、计算节点同构可互换等措施来保障服务的高可靠性。基于云服务的应用可以持续对外提供服务（7*24小时），另外“云”的规模可以动态伸缩，来满足应用和用户规模增长的需要。按需服务，更加经济用户可以根据自己的需要来购买服务，甚至可以按使用量来进行精确计费。这能大大节省IT成本，而资源的整体利用率也将得到明显的改善。安全网络安全已经成为所有企业或个人创业者必须面对的问题，企业的IT团队或个人很难应对那些来自网络的恶意攻击，而使用云服务则可以借助更专业的安全团队来有效降低安全风险。 云计算可以分为IaaS、PaaS、SaaS、[DaaS四个]层次。(按照服务划分) IaaS: Infrastructure-as-a-Service(基础设施即服务)有了IaaS，你可以将硬件外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。一些大的IaaS公司包括Amazon, Microsoft, VMWare, Rackspace和Red Hat.不过这些公司又都有自己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。 PaaS: Platform-as-a-Service(平台即服务)第二层就是所谓的PaaS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资源。PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。一些大的PaaS提供者有Google App Engine,Microsoft Azure，Force.com,Heroku，Engine Yard。最近兴起的公司有AppFog,Mendix和Standing Cloud. SaaS: Software-as-a-Service(软件即服务)第三层也就是所谓SaaS。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器上的应用都可以通过网络来运行，就是SaaS了。你消费的服务完全是从网页如Netflix,MOG,Google Apps,Box.net,Dropbox或者苹果的iCloud那里进入这些分类。尽管这些网页服务是用作商务和娱乐或者两者都有，但这也算是云技术的一部分。 另外，越来越多的数据沉淀、抽象形成了新的服务——DaaS（Data as a Service，数据即服务）。 下面画一个图来对比一下：| 相关项目 | 云服务 || :—- | —-: || | DASS | SAAS | PAAS | IAAS || 服务对象 | 开发者和企业 | 企业 | 开发者 | 开发者和企业用户 || 成熟度 |发展较晚，成熟度较低|发展早，成熟度相对最高|起步较晚，成熟度低|在应用层成熟后兴起，成熟度较高||核心能力|实现数据共享|帮助企业优化业务流程|帮助开发者的产品快速活动某种功能|帮助企业/开发者快速拥有存储，计算等资源||发展现状|潜力最大，融资集中在早期|企业级市场活跃，融资集中在C轮及以上|潜力较大，但是市场总体量较小|竞争激烈，垂直领域亦有发展空间||主要玩家|互联网公司|互联网公司,传统软件公司及创业企业|互联网公司，创业企业|电信运营商，IT厂商，互联网公司，创业企业| Hadoop的概念 Hadoop是一个由Apache基金会所开发的分布式系统基础架构 主要解决，海量数据的存储和海量数据的分析计算问题。 广义上来说，hadoop通常是指一个更广泛的概念——hadoop生态圈 Hadoop组成 MapReduce 计算 Yarn 资源调度 HDFS 数据存储 Common 辅助工具 大数据技术生态系统 技术名词解释 Sqoop：sqoop是一款开源的工具，主要用于在Hadoop(Hive)与传统的数据库(mysql)间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL ,Oracle 等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。 Flume：Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。 Kafka：Kafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性： （1）通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。 （2）高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息 （3）支持通过Kafka服务器和消费机集群来分区消息。 （4）支持Hadoop并行数据加载。 Storm：Storm为分布式实时计算提供了一组通用原语，可被用于“流处理”之中，实时处理消息并更新数据库。这是管理队列及工作者集群的另一种方式。 Storm也可被用于“连续计算”（continuous computation），对数据流做连续查询，在计算时就将结果以流的形式输出给用户。 Spark：Spark是当前最流行的开源大数据内存计算框架。可以基于Hadoop上存储的大数据进行计算。 Oozie：Oozie是一个管理Hdoop作业（job）的工作流程调度管理系统。Oozie协调作业就是通过时间（频率）和有效数据触发当前的Oozie工作流程。 Hbase：HBase是一个分布式的、面向列的开源数据库。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。 Hive：hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。 R语言：R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。 Mahout:Apache Mahout是个可扩展的机器学习和数据挖掘库，当前Mahout支持主要的4个用例：推荐挖掘：搜集用户动作并以此给用户推荐可能喜欢的事物。聚集：收集文件并进行相关文件分组。分类：从现有的分类文档中学习，寻找文档中的相似特征，并为无标签的文档进行正确的归类。频繁项集挖掘：将一组项分组，并识别哪些个别项会经常一起出现。 ZooKeeper：Zookeeper是Google的Chubby一个开源的实现。它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、 分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 扩展我们在这里就不再展开了，我们不妨关注其他一些更有趣的话题。分布式系统阿里云介绍 课后答案","comments":true,"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://pandamin18436220.github.io/tags/hadoop/"},{"name":"大数据概论","slug":"大数据概论","permalink":"https://pandamin18436220.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A6%82%E8%AE%BA/"},{"name":"云计算","slug":"云计算","permalink":"https://pandamin18436220.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}]},{"title":"Nao检测Mark","date":"2020-02-09T12:44:42.507Z","path":"2020/02/09/nao之检测Mark/","text":"在此先附上一串简单的代码此代码适于用于Nao机器人的Mark检测 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding:utf-8 -*-from naoqi import ALProxyimport mathimport almathdef main(robotIP,PORT): motion=ALProxy(\"ALMotion\",robotIP,PORT) posture=ALProxy(\"ALRobotPosture\",robotIP,PORT) tts=ALProxy(\"ALTextToSpeech\",robotIP,PORT) markProxy= ALProxy(\"ALLandMarkDetection\",robotIP,PORT) #ALTracker模块允许机器人使用不同的方式（仅头部，全身，移动等）跟踪不同的目标（红球，面部，地标等）。 #该模块的主要目的是在目标检测与运动之间建立桥梁，以使机器人在摄像机中间始终观察目标。 tracker=ALProxy(\"ALTracker\",robotIP,PORT) useSensors=False period = 500 #H=0.459 #L=0.405 #theta=39.7*almath.TO_RAD #启动naomark检测功能 markProxy.subscribe(\"Test_Mark\",period,0.0) memProxy=ALProxy(\"ALMemory\",robotIP,PORT) motion.wakeUp() posture.goToPosture(\"StandInit\",0.5) for i in range(0,20): motion.moveTo(-0.05,0.0,0.0,config) data=memProxy.getData(\"LandmarkDetected\",) if data:#data为空则没有识别到 tts.say(\"检测到mark\") sensorAngles= motion.getAngles(\"HeadPitch\",useSensors)#获得头部角度数据 #sen=(math.degrees(sensorAngles[0])) #S=((H-L)/2)/math.tan(sen+theta) #print(data[1][1][0]) print(sensorAngles[0]) #print(S) #print(tracker.getTargetCoordinates()) #tts.say(\"距离为:%d\"%(S)) exit(0) else: tts.say(\"没检测到mark\")if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument(\"--ip\", type=str, default=\"127.0.0.1\", help=\"Robot IP address. On robot or Local Naoqi: use '127.0.0.1'.\") parser.add_argument(\"--port\", type=int, default=9559, help=\"Naoqi port number\") args = parser.parse_args() #步态参数 config=[ [\"MaxStepX\",0.045], [\"MaxStepY\",0.145], [\"MaxStepFrequency\",0.4], [\"TorsoWx\",5.0*almath.TO_RAD] ] robotIP=args.ip PORT=args.port","comments":true,"tags":[{"name":"Nao","slug":"Nao","permalink":"https://pandamin18436220.github.io/tags/Nao/"},{"name":"Naoqi","slug":"Naoqi","permalink":"https://pandamin18436220.github.io/tags/Naoqi/"}]},{"title":"Nao传感器","date":"2020-02-09T11:58:17.631Z","path":"2020/02/09/nao之传感器/","text":"在此先附上一串简单的代码此代码适于用于做对Nao机器人头顶三个传感器做相关的实验参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# -*- coding:utf-8 -*-from naoqi import ALProxyimport almathimport argparseimport threadingfrom naoqi import ALModuledef main(robotIP,PORT): n=1 motion=ALProxy(\"ALMotion\",robotIP,PORT) posture=ALProxy(\"ALRobotPosture\",robotIP,PORT) tts=ALProxy(\"ALTextToSpeech\",robotIP,PORT) memory=ALProxy(\"ALMemory\",robotIP,PORT) def run():#行走 motion.wakeUp() posture.goToPosture(\"StandInit\",0.5) motion.moveTo(1.0 ,0,0,config) #threadLock.acquire() #threadLock.release() #threadLock = threading.Lock() def onTouched():#触摸传感器 #防止一次触摸未识别，进行死循环，触摸成功才可退出循环 while n==1: fronthead = memory.getData('FrontTactilTouched') #如果触摸成功，则fronthead=1 if fronthead == 1: motion.rest() break #创建 thread1=threading.Thread(target=run) thread2=threading.Thread(target=onTouched) #开始进行多线程 thread1.start() thread2.start() #结束 thread1.join() thread2.join()if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument(\"--ip\", type=str, default=\"127.0.0.1\", help=\"Robot IP address. On robot or Local Naoqi: use '127.0.0.1'.\") parser.add_argument(\"--port\", type=int, default=9559, help=\"Naoqi port number\") args = parser.parse_args() #步态参数 config=[ [\"MaxStepX\",0.045], [\"MaxStepY\",0.145], [\"MaxStepFrequency\",0.4], [\"TorsoWx\",5.0*almath.TO_RAD] ] robotIP=args.ip PORT=args.port","comments":true,"tags":[{"name":"Nao","slug":"Nao","permalink":"https://pandamin18436220.github.io/tags/Nao/"},{"name":"Naoqi","slug":"Naoqi","permalink":"https://pandamin18436220.github.io/tags/Naoqi/"}]},{"title":"Nao单目测距","date":"2020-02-09T07:44:59.072Z","path":"2020/02/09/nao之单目测距/","text":"在此先附上一串简单的机器人测距代码此代码适于用做对Nao机器人做视觉识别和测距实验,只提供关键代码部分,尝试利用cv2去优化代码会更加简洁哟！ 此代码的主要功能:1.初始姿态下，通过更换摄像头和转头去寻找目标2.通过颜色阈值识别目标，计算目标与Nao的距离和角度可以扩展功能：1.在运动过程中对方向和距离进行多次测量和校正，提高准确度2.找到目标后，通过对目标的测量，选择使用哪个脚去踢目标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#!/usr/bin/python2.7#-*- encoding: UTF-8 -*-import vision_definitions#----------------------单目测距--------------------------------#***********************************************#@函数名： DistAndDirect_cal(cxnum,rynum,colsum,rowsum,Head_angle,cameraID)#@参数： (cxnum,rynum)是通过图像识别得到球心的像素点坐标# (colsum,rowsum)是图片总大小：640*480# cameraID=0，取上摄像头；cameraID=1，取下摄像头#@返回值： 无#@功能说明： 采用机器人的下摄像头进行测量球离机器人的相关角度与距离def DistAndDirect_cal(cxnum,rynum,colsum,rowsum,Head_angle,cameraID): distx=-(cxnum-colsum/2) disty=rynum-rowsu/2 print distx,disty Picture_angle=disty*47.64/480 if cameraID ==0: h=0.62 Camera_angle=12 else: h=0.57 Camera_angle=38 #Head_angle[0]机器人仰俯角度 Total_angle=math.pi*(Picture_angle+Camera_angle)/180+Head_angle[0] d1=h/math.tan(Total_angle) alpha=math.pi*(distx*60.92/640)/180 d2=d1/math.cos(alpha) #Head_angle[1]机器人左右角度 Forward_Distance=d2*math.cos(alpha+Head_angle[1]) Sideward_Distance=-d2*math.sin(alpha+Head_angle[1])#***********************************************#@函数名： GetNaoImage(IP,PORT,cameraID)#@参数： 略#@返回值： 无#@功能说明： 采调用机器人内置摄像头控制模块，对当前场景进行拍摄并保持。# 由于球距离机器人约小于0.6m时，机器人额头摄像头无法看到，# 所以需要变换摄像头，cameraID=0，取上摄像头；# cameraID=1，取下摄像头def Get NaoImage(IP,PORT,cameraID): camProxy=ALProxy(\"ALVideoDevice\",IP,PORT) resolition=2 #VGA格式640*480 colorSpace=11#RGB #选择并启用摄像头 camProxy.setParam(vision_definitions.kCameraSelectID,cameraID) videoClient=camProxy.subscribe(\"python_client\",resolition,colorSpace,5) #获取摄像机图像。 #image [6]包含以ASCII字符数组形式传递的图像数据。 naoImage=camProxy.getImageRemote(videoClient) camProxy.unsubscribe(videoClient) #获取图像大小和像素阵列。 imageWidth=naoImage[0] imageHeight=naoImage[1] array=naoImage[6] #从我们的像素阵列创建一个PIL图像。 im=Image.fromstring(\"RGB\",(imageWidth,imageHeight),array) #保存图像。 im.save(\"temp.jpg\",\"JPEG\")#***********************************************#@函数名： findColorPattern(img,pattern)#@参数： 略#@返回值： 无#@功能说明： 将RGB图像转化为二值图：此方法用的是cv,可以尝试用cv2代码会更加简洁def findColorPattern(img,pattern): channels=[None,None,None] channels[0]=cv.CreateImage(cv.GetSize(img),8,1) channels[1]=cv.CreateImage(cv.GetSize(img),8,1) channels[2]=cv.CreateImage(cv.GetSize(img),8,1) ch0=cv.CreateImage(cv.GetSize(img),8,1) ch1=cv.CreateImage(cv.GetSize(img),8,1) ch2=cv.CreateImage(cv.GetSize(img),8,1) cv.Split(img,ch0,ch1,ch2,None) dest=[None,None,None,None] dest[0]=cv.CreateImage(cv.GetSize(img),8,1) dest[1]=cv.CreateImage(cv.GetSize(img),8,1) dest[2]=cv.CreateImage(cv.GetSize(img),8,1) dest[3]=cv.CreateImage(cv.GetSize(img),8,1) cv.Smooth(ch0,channels[0],cv.CV_GAUSSIAN,3,3,0) cv.Smooth(ch1,channels[1],cv.CV_GAUSSIAN,3,3,0) cv.Smooth(ch2,channels[2],cv.CV_GAUSSIAN,3,3,0) for i in range(3): k=2-i lower=pattern[k]-75#设置阈值 upper=pattern[k]+75 cv.InRangeS(channels[i],lower,upper,dest[i]) cv.And(dest[0],dest[1],dest[3]) temp=cv.CreateImage(cv.GetSize(img),8,1) cv.And(dest[2],dest[3],temp) ''' cv.NameWindow(\"result\",cv.CV_WINDOW_AUTOSIZE) cv.ShowImage(\"result\",temp) cv.WaitKey(0) ''' return temp#***********************************************#@函数名： xyProject(matrix,imgaesize)#@参数： matrix# imgaesize#@返回值： 无#@功能说明： 利用二值图，计算球的像素坐标。其原理是：遍历各行各列# 像素的数值的和，最大的组合即为球心坐标def xyProject(matrix,imagesize): #声明一个数据类型为8位型单通道的imagessize[1]*1/1*imagessize[0]矩阵(初始值为 0)。 colmask=cv.CreateMat(imagessize[1],1,cv.CV_8UC1) rowmask=cv.CreateMat(1,imagessize[0],cv.CV_8UC1) cv.Set(colmask,1) cv.Set(rowmask,1) colsum=[] for i in range(imagesize[0]): col=cv.GetCol(matrix,i) #计算向量点积 a=cv.DotProduct(colmask,col) colsum.append(a) rowsum=[] for i in range(imagesize[1]): row=cv.GetRow(matrix,i) a=cv.DotProduct(rowmask,row) rowsum.append(a) return(colsum,rowsum)#得到各行各列“1”值的和def crMax(colsum,rowsum): cx=max(colsum) ry=max(rowsum) for i in range(len(colsum)): if colsum[i]==cx: cxnum=i for i in range(len(rowsum)): if rowsum[i]==ry: rynum=i return(cxnum,rynum)#***********************************************#@函数名： GetHeadAngles(robotIP,PORT)#@参数： 略#@返回值： 无#@功能说明：def GetHeadAngles(robotIP,PORT): motionProxy=ALProxy(\"ALMotion\",robotIP,PORT) names=[\"HeadPitch\",\"HeadYaw\"] useSensors=1 sensorAngles=motionProxy.getAngles(names,useSensors) return sensorAngles#***********************************************#@函数名： SetHeadAngles(robotIP,PORT,angles)#@参数： 略#@返回值： 无#@功能说明：def SetHeadAngles(robotIP,PORT,angles): motionProxy=ALProxy(\"ALMotion\",robotIP,PORT) motionProxy.setStiffnesses(\"Head\",1.0) names=[\"HeadPitch\",\"HeadYaw\"] fractionMaxSpeed=0.2 motionProxy.setAngles(names,angles,fractionMaxSpeed) time.sleep(2.0) motionProxy.setStiffnesses(\"Head\",0.0)#***********************************************#@函数名： Capture_Picture(IP,PORT,cameraID,angles,pattern_colors)#@参数： angles# pattern_colors#@返回值： 无#@功能说明： 将上面的一系列函数整合起来def Capture_Picture(IP,PORT,cameraID,angles,pattern_colors): SetHeadAngles(IP,PORT,angles) GetNaoImage(IP,PORT,cameraID) image=cv.LoadImage(\"temp.jpg\") imagesize=cv.GetSize(image) #返回数值，两个元素分别为列数和行数 matrix=findColorPattern(image,pattern_colors) (colsum,rowsum)=xyProject(matrix,imagesize) (cxnum,rynum)=crMax(colsum,rowsum) cv.SaveImage(\"result.jpg\",matrix) return (cxnum,rynum,colsum,rowsum)#***********************************************#@函数名： Target_Detect_and_Distance(IP,PORT)#@参数：#@返回值： 无#@功能说明： 当上摄像头无法找到球时，切换到下摄像头，然后在左转右转。# 在这个过程中，如果发现目标，则计算距离并输出距离# 若始终未找到目标，则输出距离为0。def Target_Detect_and_Distance(IP,PORT): pattern_colors=(255,150,50) cameraID=0# 默认上摄像头 angles=[0,0] (cxnum,rynum,colsum,rowsum)=Capture_Picture(IP,PORT,cameraID,angles) if(cxnum,rynum)==(639,479): cameraID=1 (cxnum,rynum,colsum,rowsum)=Capture_Picture(IP,PORT,cameraID,angles) if(cxnum,rynum)==(639,479): cameraID=0 angles=[0.0.7] (cxnum,rynum,colsum,rowsum)=Capture_Picture(IP,PORT,cameraID,angles) if(cxnum,rynum)==(639,479): cameraID=0 angles=[0,-0.7] (cxnum,rynum,colsum,rowsum)=Capture_Picture(IP,PORT,cameraID,angles) HeadAngles-GetHeadAngles(IP,PORT) ############### (Forward_Distance,Sideward_Distance)=DistAndDirect_cal(cxnum,rynum,colsum,rowsum,Head_angle,cameraID) if(cxnum,rynum)==(639,479): (Forward_Distance,Sideward_Distance)=(0,0) print \"Forward_Distance=\",Forward_Distance,\"meters\" print \"Sideward_Distance=\"+Sideward_Distance+\"meters\"#***********************************************#@函数名： Target_Detect_and_Distance(IP,PORT)#@参数：#@返回值： 无#@功能说明： 当找到球后，可能会存在一定的误差。# 因此需要判断球位于机器人前方的哪一侧，再来确定用哪只脚踢球def Final_See(robotIP,PORT): pattern_colors=(255,150,50) angles=[0.5,0] SetHeadAngles(robotIP,PORT,angles) cameraID=1 GetNaoImage(robotIP,PORT,cameraID) image=cv.LoadImage(\"temp.jpg\") imagesize=cv.GetNaoImage(image) matrix=findColorPattern(image,pattern_colors) (colsum,rowsum)=xyProject(matrix,imgaesize) (cxnum,rynum)=crMax(colsum,rowsum) cv.SaveImage(\"result.jpg\",matrix) HeadAngles=GetHeadAngles(robotIP,PORT) ######################### (Forward_Distance,Sideward_Distance)=DistAndDirect_cal(cxnum,rynum,colsum,rowsum,Head_angle,cameraID) if cxnum&lt;len(colsum)/2: side=0#左脚 else: side=1#右脚 print \"side=\",side print \"last distance=\",Forward_Distance return (side,Forward_Distance)","comments":true,"tags":[{"name":"Nao","slug":"Nao","permalink":"https://pandamin18436220.github.io/tags/Nao/"},{"name":"Naoqi","slug":"Naoqi","permalink":"https://pandamin18436220.github.io/tags/Naoqi/"}]},{"title":"Naoqi库","date":"2020-02-09T07:00:00.660Z","path":"2020/02/09/naoqi库/","text":"Naoqi的作用通过调用naoqi可以调用Nao等机器人的内置的相关端口。需要重点了解的相关模块：| 模块 | 作用 || :—-: | :—-: ||ALMotionProxy|||ALRobotPostureProxy|||ALVideoDeviceProxy|||ALMemoryProxy||||ALLandMarkDetection|||ALTrackerProxy|||ALRedBallDetection|||ALFaceDetection|| Naoqi函数 作用 ALMotionProxy::wakeUp（） 如果调用成功，则返回值为True，否则返回值为False。机器人唤醒：开启电机，并在需要时转到初始位置。如果机器人已经变硬，则调用会立即返回True。 ALMotionProxy::rest（） 机器人休息：转到放松且安全的位置并关闭电机。 ALMotionProxy::moveTo () 参数：x –沿X轴的距离，以米为单位。y –沿Y轴的距离，以米为单位。theta –绕Z轴旋转的弧度[-3.1415至3.1415]。moveConfig -步态参数返回值：如果moveTo成功终止，则为True；如果被中断，则为False。 ALRobotPostureProxy::goToPosture 使机器人转到参数中要求的预定义姿势,可以修改移动速度。参数:poseName-要达到的预定义姿势的名称。速度 -在0.0和1.0之间的相对速度。返回值：返回是否达到预定义的姿势 ALVideoDeviceProxy::unsubscribe 从ALVideoDevice取消注册该模块。 ALVideoDeviceProxy::subscribeCameras 订阅ALVideoDevice。当视频模块注册到ALVideoDevice时，所请求图像格式的缓冲区将添加到缓冲区列表中。返回可从ALVideoDevice获知VM的名称（当多个VM尝试使用相同的名称进行预订时，此名称很有用，例如，第三个将_3添加到其名称中）。参数:vmName –订阅虚拟机的名称。分辨率 –请求的分辨率。{0 = kQQVGA，1 = kQVGA，2 = kVGA，3 = k4VGA},colorSpace –请求的色彩空间。{0 = kYuv，9 = kYUV422、10 = kYUV，11 = kRGB，12 = kHSY，13 = kBGR},fps –向视频源请求的Fps（每秒帧数）。OV7670 VGA摄像机只能以30fps的速度运行，而MT9M114 HD摄像机在不久的将来将可以在某些特殊模式下更快地运行。与本地模块相比，远程模块的帧速率将取决于网络的可用带宽（例如，使用高清摄像机的千兆以太网连接，我们可以达到原始1280x960 @ 10fps）。返回值：从ALVideoDevice可以知道VM的名称，如果失败，则为NULL。 ALVideoDeviceProxy :: setParam 设置视频源的特定参数的值。 ALMemoryProxy :: getData 获取存储在内存中的键值对的值参数：键 –值的名称。返回值：数据为AL :: ALValue。通常可以将其透明地转换为原始类型。 ALLandMarkDetection :: subscribe 激活识别地标为”Naomarks”功能,可以使用ALMemory.getData（“ keyName”）在内存中访问它们。在许多情况下，可以通过仅调用提供回调方法的ALMemory.subscribeToEvent（）来避免在提取程序上调用订阅。这将自动为您订阅提取器。参数：名称 -这订阅模块的名称。period –刷新周期（以毫秒为单位）（如果相关）。精度 –提取器的精度（如果相关）。 ALTrackerProxy::getTargetCoordinates 仅适用于LandMarks目标名称。获取使用设置的对象坐标 ALMotionProxy::setMoveArmsEnabled 参数：leftArmEnable-如果为真，则由“移动任务”控制左臂运动。rightArmEnable –如果真实的右臂动作是由“移动任务”控制的 ALMotionProxy::angleInterpolation 将一个或多个关节插入到目标角度或沿定时轨迹进行插值。参数：名称 –关节，链条，“车身”，“ JointActuators”，“ Joints”或“ Actuators”的名称或名称。angleLists –以弧度表示的角度，角度列表或角度列表timeLists –时间，时间列表或时间列表（以秒为单位）isAbsolute –如果为true，则以绝对角度描述运动，否则角度相对于当前角度。 ALMotionProxy::stiffnessInterpolation 将一个或多个关节插入到目标刚度或沿着刚度的定时轨迹进行插值。参数：名称 –关节，链条，“车身”，“ JointActuators”，“Joints”或“ Actuators”的名称或名称。刚度列表–刚度，刚度列表或刚度列表timeLists –时间，时间列表或时间列表。 ALMotionProxy::angleInterpolationWithSpeed 使用最大速度的一部分将一个或多个关节插入到目标角度。每个关节仅允许一个目标角度。参数：名称 –关节，链条，“车身”，“ JointActuators”，“ Joints”或“ Actuators”的名称或名称。targetAngles –角度或以弧度表示的角度列表。maxSpeedFraction –分数。 官方文档链接1 官方文档链接2","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"Naoqi","slug":"Naoqi","permalink":"https://pandamin18436220.github.io/tags/Naoqi/"}]},{"title":"Nao行走","date":"2020-02-09T06:37:33.754Z","path":"2020/02/09/nao之行走/","text":"在此先附上一串简单的机器人行走代码此代码适于用做测量Nao的步态参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding:utf-8 -*-from naoqi import ALProxyimport mathimport argparseimport almathdef main(robotIP,PORT): motion=ALProxy(\"ALMotion\", robotIP,PORT) posture=ALProxy(\"ALRobotPosture\",robotIP,PORT) tts=ALProxy(\"ALTextToSpeech\",robotIP,PORT) posture.goToPosture(\"StandInit\",0.5) motion.wakeUp() motion.moveTo(2.5,0.0,0.0,config) tts.say(\"左转\") motion.moveTo(0.0,0.0,math.pi/2,Config) motion.moveTo(1.0,0.0,0.0,config) tts.say(\"左转\") motion.moveTo(0.0,0.0,math.pi/2,Config) motion.moveTo(2,5.0,0.0,config) motion.rest()if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument(\"--ip\", type=str, default=\"127.0.0.1\", help=\"Robot IP address. On robot or Local Naoqi: use '127.0.0.1'.\") parser.add_argument(\"--port\", type=int, default=9559, help=\"Naoqi port number\") args = parser.parse_args() #步态参数 config=[ [\"MaxStepX\",0.045], [\"MaxStepY\",0.145], [\"MaxStepFrequency\",0.4], [\"TorsoWx\",5.0*almath.TO_RAD]#5度 ] config1=[ [\"MaxStepX\",0.035], [\"MaxStepY\",0.145], [\"MaxStepFrequency\",0.3] #[\"TorsoWx\",-0.05] #[\"TorsoWy\",0.05] ] robotIP=args.ip PORT=args.port 步态参数（moveConfig）的介绍操控机器人最基础的就是操控机器人走路，而想要让机器人可以平稳的行走就需要我们对moveConfig中的参数进行调试。其中不同的机器人对于不同的步态参数的适应力都不相同，也就是说相同的步态参数可以让这个机器人平稳行走，放在另一个机器人上就可能行不通，所以在每次运行不同机器人前都需要进行调试。moveConfig中包含了以下这些参数及参数可调范围： 名称 作用 默认值 最低限度 最大值 可设置 MaxStepX 沿X(米)的最大向前平移 0.040 0.001 0.080 是 MinStepX 沿X(米)的最大向后平移 -0.040 没有 MaxStepY 沿Y(米)的绝对最大横向平移 0.140 0.101 0.160 是 MaxStepTheta Z(弧度)周围的绝对最大旋转 0.349 0.001 0.524 是 MaxStepFrequency 最大步进频率(标准化，无单位) 1. 0. 1. 是 MinStepPeriod 最小步长(秒) 0.42 没有 MaxStepPeriod 最大步长(秒) 0.6 没有 梯状 沿Z(米)的峰值脚高 0.020 0.005 0.040 是 TorsoWx X(弧度)周围的峰值躯干旋转 0.000 -0.122 0.122 是 TorsoWy y(弧度)周围的峰值躯干旋转 0.000 -0.122 0.122 是 FootSeparation 沿Y(米)改变双脚之间的距离 0.1 没有 MinFootSeparation 沿Y的最小距离(米) 0.088 没有","comments":true,"tags":[{"name":"Nao","slug":"Nao","permalink":"https://pandamin18436220.github.io/tags/Nao/"},{"name":"Naoqi","slug":"Naoqi","permalink":"https://pandamin18436220.github.io/tags/Naoqi/"}]},{"title":"世界怎么了","date":"2020-02-07T13:15:03.511Z","path":"2020/02/07/随笔录之世界怎么了/","text":"大爱无疆，生死不在话下。拥有大爱和超出常人气魄胆量的人，如今都在疫情的一线用性命去和病毒搏斗，他们不是没有家人没有眼泪没有恐惧没有情绪，更不是因为他们有九条命。而是他们不仅仅只爱眼下围城里的专属物品，亲人、朋友。他们越过了所有人认知里的小世界，还爱着安全疆域之外的陌生人，所有的陌生人加起来就是祖国、是全人类，再大一点，其实可以说是动物世界。 如今只要是躺在病床上的无论黑发碧眼高矮胖瘦，温柔求救或是出言不逊口吐芬芳，被人抓着脖颈歇斯底里辱骂害怕到发抖也都会去医治挽救。我们常说救人是医生该做的事，但没有说冒着搭进自己性命的危险也是该做的事。如果我们仍口口声声说他们是在上班，那不好意思，班是可以请假的，更可以离职，换一个班上。在所有的危难时刻里挺身而出的职业都不算做是职业，而是人类的帕修斯。 只有爱能给人带来无边的勇气，忘却生死和利益。那一刻他们不是活在某一个城市，而是活在了宇宙中心，他们似乎比我们高了好几个维度，夏虫不可语于冰。只有看到他们抽出3分钟吃顿饭的时候才恍惚觉得他们不是神。 小爱围城，生死是头等大事。每个家庭就是一个小围城。我们都在汲汲营营的生存，在这一隅天地里付出自己的爱得到对方的情。我们思考的事情是如何让围城里的人能够过得更好，不至于死的太快或太惨。围城外的人是我们的攀比对象，也是我们成败的见证对象。我们可能会活的有些自私，我们可能只帮自己人。 无爱恶魔，混迹人间。有些“人”，甚至连自己围城里的人或物都不爱，具体能有多不爱，要看情势有多严峻，把他们逼到什么地步。因为还是不能杀人的，如果可以，我猜他们应该会建议一把火把病毒区连人带房都烧了，别怪我为什么这样猜测，当谣言说猫狗会传染后第一时间就是将它们丢弃或弄死。和谁的情都是情，和人是，和动物更是。我们爱自己的宠物，就是真心爱着，是自己人。只有虚假的感情才能瞬间去裁决生死，因为不会让自己伤心，他们根本就没有心。 我很难过在这样特殊情况下的很多事情。难过所有被连累逝去的生命；难过所有无法休息拿命搏斗的人；难过一座美丽的城市却成了恐慌的代名词。 自私一点的难过是，爱的人过家门而不能入，一句想念隔了几千公里。我很难过无法见你这件事。而越是危难时刻，我愈发想见你。 都在说疫情过后要如何如何，疫情过后我只想珍惜你和我的生命，做一对快乐的夏虫。 然而压死骆驼的稻草也似乎永远都不止一根，多少男孩心目中的神也的确回到了天堂。科比坠机的那天不知道又有多少眼泪在横飞。 我们为什么会这样的揪心难过，因为他是一代人的青春，是过去我们存活激情时刻留下的生命印证，从篮球连带着想起那些岁月，篮球场、汗流浃背的身影、看我们打球的姑娘、发疯般追过的曼巴精神，这些会让我们恍然隔世，原来我们曾那样活过啊！失去他，就好像失去了生命的一部分。始于科比的篮球，终于凌晨四点的洛杉矶。 理论是灰色的，生命之树常青。这是李文亮医生是微信签名。从他被处分，感染到平反。他说了实话，说了很多人不敢说的话。但却得到了不相称的惩罚！同一天，他的核酸检测结果出来了，阳性。他说：尘埃落定，终于确诊了，还配了个狗狗的表情。他在病房里看到许多网友的鼓励，在微博上感谢大家：谢谢大家的支持，我没有被吊销执照，请大家放心，我一定积极配合治疗，争取早日出院。再之前，工作群里号召医生们报名到防疫一线时，他还说了一句：我好了也报名。但他却被宣告死亡… 澳大利亚大火，应该给人类和这个星球留下哪些教训？因为人广地稀，所以死亡的人员并不多（但也至少28人死亡）。不过造成了极大的生态灾难：至少10亿只动物丧生火海。这么多的野生动物被烧死，对本来就相对脆弱的澳洲生态系统一定会造成难以弥补的损害。从去年9月开始，澳大利亚的山火已经整整燃烧了四个多月，迄今仍未看到熄灭的迹象。 美国流感疫情严重，据报道，今年美国的流感季相对往年不仅来得早，而且爆发速度快快，流感最先在东南部数州出现后迅速扩散，迄今没有减缓的迹象。包括南方地区、西部的部分地区、纽约市和华盛顿，现流感已扩散至46个州。 这些天的足不出户，让我发了足够久的呆，我思考着这一切，不知该拿什么心情收场。人类的悲欢在此刻是相通的吧，我想。","comments":true,"tags":[{"name":"随笔录","slug":"随笔录","permalink":"https://pandamin18436220.github.io/tags/%E9%9A%8F%E7%AC%94%E5%BD%95/"}]},{"title":"PIL库","date":"2020-02-07T12:41:48.226Z","path":"2020/02/07/PIL库/","text":"PIL的作用对于图像识别，大量的工作在于图像的处理，处理效果好，那么才能很好地识别，因此，良好的图像处理是识别的基础。在Python中，有一个优秀的图像处理框架，就是PIL库。但本篇文章主要来介绍PIL中的Image模块的相关函数，如果你还想了解更多，可以点击官方文档链接进行学习。相信提到图像的处理工作，很多小伙伴们会提到OpenCv库不也有这个功能吗？ 那我们首先来比较一下他们的区别 模块名称 函数 作用 OpenCv cv2.imshow() 采用BGR模式，通过cv2.imread()读取 matplotlib.pyplot plt.imshow() 采用RGB模式, 通过plt.imread()读取 PIL.Image img.show() 采用RGB模式, 通过Image.open()读取 oopencv(BGR)显示图片12345# img为BGR通道img = cv2.imread(img_path, mode) # mode = [1, 0, -1]依次表示彩色、灰度、彩色+alpha， 默认为1;cv2.imshow('test', img)cv2.waitKey(0) # 保持图形界面，直到你在终端输入任意字符cv2.destroyAllWindows() PIL.Image(RGB)显示图片12img = Image.open(img_path)img.show() PIL.Image转Opencv1cv2_img = cv2.cvtColor(numpy.asarray(Img_img),cv2.COLOR_RGB2BGR) Opencv转PIL.Image1pil_img = Image.fromarray(cv2.cvtColor(cv_img,cv2.COLOR_BGR2RGB)) 下面介绍Image模块相关函数Image模块是在Python PIL图像处理中常见的模块，对图像进行基础操作的功能基本都包含于此模块内。如open、save、conver、show…等功能。 类模块? 作用 open类 im = Image.open(“文件存在的路径”) Save类 im.save(“文件保存路径”) Size类 im.size 尺寸信息 new类 im= Image.new(“通道RGB”, (尺寸), “颜色”) Split类 r,g,b = im.split() 分离“RGB”图像将产生三个新的图像，分别对应原始图像的每个通道（红，绿，蓝） Merge类 Image.merge(“RGB”,[r,g,b]) 合并三个通道 convert类 将当前图像转换为其他模式，细情请看友情链接 官方文档 友情链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"PIL","slug":"PIL","permalink":"https://pandamin18436220.github.io/tags/PIL/"}]},{"title":"sys库","date":"2020-02-07T12:02:38.353Z","path":"2020/02/07/sys库/","text":"sys的作用sys模块主要是针对与Python解释器相关的变量和方法，不是主机操作系统。 sys函数 作用 sys.argv 获取命令行参数列表，第一个元素是程序本身 sys.exit(n) 退出Python程序，exit(0)表示正常退出。当参数非0时，会引发一个SystemExit异常，可以在程序中捕获该异常 sys.version 获取Python解释程器的版本信息 sys.maxsize 最大的Int值，64位平台是2**63 - 1 sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.platform 返回操作系统平台名称 sys.stdin 输入相关 sys.stdout 输出相关 sys.stderr 错误相关 sys.exc_info() 返回异常信息三元元组 sys.getdefaultencoding() 获取系统当前编码，默认为utf-8 sys.setdefaultencoding() 设置系统的默认编码 sys.getfilesystemencoding() 获取文件系统使用编码方式，默认是utf-8 sys.modules 以字典的形式返回所有当前Python环境中已经导入的模块 sys.builtin_module_names 返回一个列表，包含所有已经编译到Python解释器里的模块的名字 sys.copyright 当前Python的版权信息 sys.flags 命令行标识状态信息列表。只读。 sys.getrefcount(object) 返回对象的引用数量 sys.getrecursionlimit() 返回Python最大递归深度，默认1000 sys.getsizeof(object[, default]) 返回对象的大小 sys.getswitchinterval() 返回线程切换时间间隔，默认0.005秒 sys.setswitchinterval(interval) 设置线程切换的时间间隔，单位秒 sys.getwindowsversion() 返回当前windwos系统的版本信息 sys.hash_info 返回Python默认的哈希方法的参数 sys.implementation 当前正在运行的Python解释器的具体实现，比如CPython sys.thread_info 当前线程信息 官方文档链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"sys","slug":"sys","permalink":"https://pandamin18436220.github.io/tags/sys/"}]},{"title":"OS库","date":"2020-02-07T11:36:01.637Z","path":"2020/02/07/os库/","text":"OS的作用OS模块提供了一些方便使用操作系统相关功能的函数。 OS函数 作用 os.sep 取代操作系统特定的路径分隔符 os.name 指示你正在使用的工作平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’。 os.getcwd 得到当前工作目录，即当前python脚本工作的目录路径。 os.getenv()和os.putenv() 分别用来读取和设置环境变量 os.listdir() 返回指定目录下的所有文件和目录名 os.remove(file) 删除一个文件 os.stat（file） 获得文件属性 os.chmod(file) 修改文件权限和时间戳 os.mkdir(name) 创建目录 os.rmdir(name) 删除目录 os.removedirs（r“c：\\python”） 删除多个目录 os.system() 运行shell命令 os.exit() 终止当前进程 os.linesep 给出当前平台的行终止符。例如，Windows使用’\\r\\n’，Linux使用’\\n’而Mac使用’\\r’ os.path.split() 返回一个路径的目录名和文件名 os.path.isfile()和os.path.isdir() 分别检验给出的路径是一个目录还是文件 os.path.existe() 检验给出的路径是否真的存在 os.listdir(dirname) 列出dirname下的目录和文件 os.getcwd() 获得当前工作目录 os.curdir 返回当前目录（’.’） os.chdir(dirname) 改变工作目录到dirname os.path.isdir(name): 判断name是不是目录，不是目录就返回false os.path.isfile(name) 判断name这个文件是否存在，不存在返回false os.path.exists(name) 判断是否存在文件或目录name os.path.getsize(name) 或得文件大小，如果name是目录返回0L os.path.abspath(name) 获得绝对路径 os.path.isabs() 判断是否为绝对路径 os.path.normpath(path) 规范path字符串形式 os.path.split(name) 分割文件名与目录（事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在） os.path.splitext() 分离文件名和扩展名 os.path.join(path,name) 连接目录与文件名或目录 os.path.basename(path) 返回文件名 os.path.dirname(path) 返回文件路径 官方文档链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"OS","slug":"OS","permalink":"https://pandamin18436220.github.io/tags/OS/"}]},{"title":"Numpy库","date":"2020-02-07T08:33:20.147Z","path":"2020/02/07/numpy库/","text":"Numpy的作用Numpy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。 Numpy库与数组的区别python中可以使用列表保存一组值，可将列表当数组使用。另外，python中有array模块，但它不支持多维数组。所以无论是列表还是array模块都没有科学运算函数，不适合做矩阵等科学计算。 numpy没有使用python本身的数组机制，而是提供了ndarray对象，该对象不仅能方便地存取数组，而且拥有丰富的数组计算函数。Numpy的基本使用下面介绍Numpy的基础知识与相关函数 创建数组及使用 12345678910111213141516171819202122232425262728#定义了一个二维数组，大小为（2，3）&gt;&gt;&gt; x=np.array([ [1.0,0.0,0.0], [0.,1.,2.] ])&gt;&gt;&gt; xarray([[1., 0., 0.], [0., 1., 2.]])#数组维度数&gt;&gt;&gt; x.ndim2#数组的维数，返回的格式(n,m),其中n为行数，m为列数&gt;&gt;&gt; x.shape(2, 3)#数组元素的总数&gt;&gt;&gt; x.size6#数组元素类型&gt;&gt;&gt; x.dtype#64位浮点型dtype('float64')#每个元素占有的字节大小 &gt;&gt;&gt; x.itemsize 8#数组元素的缓冲区&gt;&gt;&gt; x.data&lt;memory at 0x00000205227DAC18&gt; 知识点扩展: 创建序列数组的函数arrange和linspace。（range函数类似） arange(a,b,c) 参数表示(开始值，结束值，步长) linspace(a,b,c) 参数表示(开始值，结束值，元素数量) 调用reshape()可以指定形状 123456789101112&gt;&gt;&gt; arange(6).reshape(2,3)array([ [ 0, 1, 2], [ 3, 4, 5], [10, 11, 12] ])&gt;&gt;&gt; arange(1,5,2) array([1, 3, 5])&gt;&gt;&gt; arange(0,1,0.5) array([0. , 0.5, 1])&gt;&gt;&gt; linspace(0,2,9) array([0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) 特殊数组 zeros数组：全零数组，元素全为零。 ones数组：全1数组，元素全为1。 empty数组：空数组，元素全近似为0。 1234567891011121314151617181920212223242526&gt;&gt;&gt; zeros((3,4)) array([ [0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.] ])&gt;&gt;&gt; ones((2,3,4),dtype=int16) array([ [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ], [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] ], dtype=int16)&gt;&gt;&gt; empty((5,3)) array([ [6.23042070e-307, 1.42417221e-306, 1.37961641e-306], [1.11261027e-306, 1.11261502e-306, 1.42410839e-306], [7.56597770e-307, 6.23059726e-307, 1.42419530e-306], [7.56599128e-307, 1.11260144e-306, 6.89812281e-307], [2.22522596e-306, 2.22522596e-306, 2.56761491e-312] ]) 数组索引 Numpy数组通过索引访问12345678910111213141516171819&gt;&gt;&gt; c=arange(24).reshape(2,3,4)&gt;&gt;&gt; print(c)[ [ [ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] ] [ [12 13 14 15] [16 17 18 19] [20 21 22 23] ]]&gt;&gt;&gt; print(c[1,2,:]) [20 21 22 23]&gt;&gt;&gt; print(c[0,1,2]) 6 数组运算 数组的加减乘除以及乘方运算方式为:相应位置的元素分别进行运算。12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; a=array([20,30,40,50])&gt;&gt;&gt; aa=arange(1,5)&gt;&gt;&gt; a/aa array([20. , 15. , 13.33333333, 12.5 ])&gt;&gt;&gt; b=arange(4)&gt;&gt;&gt; b array([0, 1, 2, 3])&gt;&gt;&gt; c=a-b&gt;&gt;&gt; c array([20, 29, 38, 47])&gt;&gt;&gt; b**2 array([0, 1, 4, 9], dtype=int32)&gt;&gt;&gt; A=array([ [1,1], [0,1] ])&gt;&gt;&gt; B=array([ [2,0], [3,4] ])&gt;&gt;&gt; A*B array([ [2, 0], [0, 4] ])&gt;&gt;&gt; A.sum() 3&gt;&gt;&gt; A.min() 0&gt;&gt;&gt; A.max() 1 数组的拷贝 拷贝有浅拷贝和深拷贝两种; 浅拷贝通过数组变量的赋值完成,浅拷贝只拷贝数组的引用，如果对拷贝进行修改，源数组也将修改; 深拷贝使用数组对象的copy方法，会复制一份和源数组一样的数组，新数组与源数组会存放在不同内存位置，因此对新数组的修改不会影响源数组。 案例一(浅拷贝)1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; a=ones((2,3))&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 1.] ])&gt;&gt;&gt; b=a&gt;&gt;&gt; b[1,2]=2&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 2.] ])&gt;&gt;&gt; b array([ [1., 1., 1.], [1., 1., 2.] ])案例二(深拷贝)&gt;&gt;&gt; a=ones((2,3))&gt;&gt;&gt; b=a.copy()&gt;&gt;&gt; b[1,2]=2&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 1.] ])&gt;&gt;&gt; b array([ [1., 1., 1.], [1., 1., 2.] ]) 创建矩阵 矩阵与数组的区别Numpy的矩阵对象与数组对象相似。其不同之处在于，矩阵对象的计算遵循矩阵数学运算律。矩阵使用matrix函数创建。1234567891011121314151617&gt;&gt;&gt; A=matrix('1.0 2.0;3.0 4.0')&gt;&gt;&gt; A matrix([ [1., 2.], [3., 4.] ])&gt;&gt;&gt; B=matrix([ [1.0,2.0], [3.0,4.0] ])&gt;&gt;&gt; B matrix([ [1., 2.], [3., 4.] ])&gt;&gt;&gt; type(A) &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt; 矩阵运算 123456789101112131415161718&gt;&gt;&gt; A.T #转置 matrix([ [1., 3.], [2., 4.] ])&gt;&gt;&gt; x=matrix('5.0 7.0')&gt;&gt;&gt; y=x.T&gt;&gt;&gt; y matrix([ [5.], [7.] ])&gt;&gt;&gt; print(A*y) #矩阵乘法 [[26.] [38.]]&gt;&gt;&gt; print(A.I) #逆矩阵 [[-2. 1. ] [ 1.5 -0.5]] Numpy线性代数相关函数 numpy.dot() 此函数返回两个数组的点积。 对于二维向量，其等效于矩阵乘法。 对于一维数组，它是向量的内积。 对于 N 维数组，它是a的最后一个轴上的和与b的倒数第二个轴的乘积。 12345&gt;&gt;&gt; a=np.array([[1,2],[3,4]])&gt;&gt;&gt; b=np.array([[11,12],[13,14]])&gt;&gt;&gt; np.dot(a,b) array([[37, 40], #[[1*11+2*13, 1*12+2*14],[3*11+4*13, 3*12+4*14]] [85, 92]]) numpy.vdot() 此函数返回两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数id是多维数组，它会被展开。 12&gt;&gt;&gt; np.vdot(a,b) 130 #1*11+2*12+3*13+4*14=130 numpy.inner() 此函数返回一维数组的向量内积。 对于更高的维度，它返回最后一个轴上的和的乘积。 1234&gt;&gt;&gt; x=np.array([1,2,3])&gt;&gt;&gt; y=np.array([0,1,0])&gt;&gt;&gt; print(np.inner(x,y)) 2 # 等价于 1*0+2*1+3*0 numpy.matmul() 函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。 另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。 #对二维数组（列表），就相当于矩阵乘法 123456789101112131415161718192021&gt;&gt;&gt; a=[[1,0],[0,1]]&gt;&gt;&gt; b=[[4,1],[2,2]]&gt;&gt;&gt; print(np.matmul(a,b))[[4 1][2 2]]#二维和一维运算&gt;&gt;&gt; a=[[1,0],[0,1]]&gt;&gt;&gt; b=[1,2]&gt;&gt;&gt; print(np.matmul(a,b)) [1 2]&gt;&gt;&gt; print(np.matmul(b,a)) [1 2]#维度大于2的&gt;&gt;&gt; a=np.arange(8).reshape(2,2,2)&gt;&gt;&gt; b=np.arange(4).reshape(2,2)&gt;&gt;&gt; print(np.matmul(a,b)) [[[ 2 3] [ 6 11]] [[10 19] [14 27]]] numpy.linalg.det() 行列式在线性代数中是非常有用的值。 它从方阵的对角元素计算。 对于 2×2 矩阵，它是左上和右下元素的乘积与其他两个的乘积的差。 换句话说，对于矩阵[[a，b]，[c，d]]，行列式计算为ad-bc。 较大的方阵被认为是 2×2 矩阵的组合。 numpy.linalg.det()函数计算输入矩阵的行列式。 123456789101112&gt;&gt;&gt; a=np.array([[1,2],[3,4]])&gt;&gt;&gt; print(np.linalg.det(a)) -2.0000000000000004&gt;&gt;&gt; b=np.array([[6,1,1],[4,-2,5],[2,8,7]])&gt;&gt;&gt; print(b) [[ 6 1 1] [ 4 -2 5] [ 2 8 7]]&gt;&gt;&gt; print(np.linalg.det(b)) -306.0&gt;&gt;&gt; print(6*(-2*7-5*8)-1*(4*7-5*2)+(4*8- -2*2)) -306 numpy.linalg.solve() 该函数给出了矩阵形式的线性方程的解。 1234567891011121314151617181920212223&gt;&gt;&gt; x=np.array([[1,2],[3,4]])&gt;&gt;&gt; y=np.linalg.inv(x)&gt;&gt;&gt; x array([[1, 2], [3, 4]])&gt;&gt;&gt; y array([[-2. , 1. ], [ 1.5, -0.5]])&gt;&gt;&gt; np.dot(x,y) array([[1.0000000e+00, 0.0000000e+00], [8.8817842e-16, 1.0000000e+00]]) a=np.array([[1,1,1],[0,2,5],[2,5,-1]]) print('数组a:') print(a) ainv=np.linalg.inv(a) print('a的逆矩阵') print(ainv) print('矩阵b:') b=np.array([[6],[-4],[27]]) print(b) print('计算：A^(-1)B:') x=np.linalg.solve(a,b) print(x) 数组分割 使用hsplit你能将数组沿着它的Y轴分割，或者指定返回相同形状数组的个数，或者指定在哪些列后发生分割。vsplit沿着X轴分割。12345678910111213141516171819202122232425262728293031323334&gt;&gt;&gt; a = floor(10*random.random((2,12)))&gt;&gt;&gt; a array([ [ 8., 8., 3., 9., 0., 4., 3., 0., 0., 6., 4., 4.], [ 0., 3., 2., 9., 6., 0., 4., 5., 7., 5., 1., 4.] ])&gt;&gt;&gt; hsplit(a,3) # Split a into 3 [array([ [ 8., 8., 3., 9.], [ 0., 3., 2., 9.] ]), array([ [ 0., 4., 3., 0.], [ 6., 0., 4., 5.] ]), array([ [ 0., 6., 4., 4.], [ 7., 5., 1., 4.]] )]&gt;&gt;&gt; hsplit(a,(3,4)) # Split a after the third and the fourth column [ array([ [ 8., 8., 3.], [ 0., 3., 2.] ]), array([ [ 9.], [ 9.] ]), array([ [ 0., 4., 3., 0., 0., 6., 4., 4.], [ 6., 0., 4., 5., 7., 5., 1., 4.] ]) ] 官方文档链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"https://pandamin18436220.github.io/tags/numpy/"}]},{"title":"Argparse库","date":"2020-02-07T06:23:41.010Z","path":"2020/02/07/argparse库/","text":"Argparse的作用python中argparse库是一个命令行参数的解析工具，利用这个库可以在命令行运行脚本时，设置参数，从而灵活的设置脚本中需要的参数。下面总结一下argparse库的使用方法。简而言之: 学会了该库的基本使用，就不必再代码里修改参数！ Argparse的基本使用下面演示Argparse三个基本函数 创建parse对象（函数一） #导入argparse库 import argparse #创建对象 这里使用description参数，我们可以输入想要的提示信息。 parser = argparse.ArgumentParser(description=&apos;add some useful information here....&apos;) ArgumentParser对象保存了所有必要的信息，用于将命令行参数解析为相应的python数据类型。 添加参数信息（函数二） 创建了ArgumentParser对象之后，就可以使用add_argument()方法来添加参数,其输入参数如下，其中[]中的参数为可选参数，作用为设置参数的一些属性。 带 - 的为可选参数(optional parameter) 不带 - 的为必选参数(positional parametrer) ArgumentParser.add_argument(name or flags…[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest]) 下面总结一下，add_argument()方法中常用的一些属性 属性值 作用 type 指定参数存储时的类型，可为int、float、str等 action 参数的处理方法，在命令行遇到此参数时要采取的基本操作类型 nargs 参数的数量，应该使用的命令行参数的数量 const 参数的常量值，某些动作和选择所需的常量值 default 参数的默认值，如果命令行中不存在的参数，则生成的值 choices 参数的取值范围，参数允许值的范围 action 参数的处理方法，在命令行遇到此参数时要采取的基本操作类型 requires 参数是否可以忽略不写，进队可选参数有效 help 参数的说明信息，简单描述参数的作用 metavar 参数在说明信息usage(用法)中的名称，用法消息中的名称 dest 对象的属性名，要添加到返回值的对象的属性的名称 案例一: 12345678910import argparse# 创建解析对象, description是对其描述parser = argparse.ArgumentParser(description=\"测试使用 argparse 库\")# 向parser对象添加你要关注的命令行参数和选项, 这里的两个参数，一个为长参数：--parm1，一个为短参数:-p1parser.add_argument(\"--param1\", \"-p1\", type=str)# 对命令行参数进行解析args = parser.parse_args()print(args)# 输出具体的参数值print(args.param1) 案例二:12345678910111213import argparse# 创建解析对象, description是对其描述parser = argparse.ArgumentParser(description=\"测试使用 argparse 库\")# 向parser对象添加你要关注的命令行参数和选项, 这里的两个参数，一个为长参数：--parm1，一个为短参数:-p1parser.add_argument(\"--param1\", \"-p1\", type=str)parser.add_argument(\"--param2\", \"-p2\", type=int, help=\"参数2需要输入0~20整数\", choices=range(21))# 参数值为int型，传入多个值时，返回的是一个列表parser.add_argument(\"--param3\", \"-p3\", type=int, nargs=\"+\", help=\"list类型，可以接收1~n个值\")# 对命令行参数进行解析args = parser.parse_args()print(args)# 输出具体的参数值print(args.param1,\"\\n\", args.param2,\"\\n\", args.param3) 我们可以通过 --param1 来指定参数1， 也可以使用短参 -p1来指定参数1 add_argument的部分参数介绍如下： type: 指定类型 required: 参数是否必填，如果为True则必须要传入对应的值 help: python test.py -h 会出现对应help的内容 nargs: 指定这个参数后面的值有多少个，默认为1, 也可以写正则表达式符号：+(一个或者多个) , *(没有或者多个), 数字 choices: 设置参数的范围 解析参数(函数三)添加完参数后，最后调用parse_args()方法，将会返回一个命名空间(namespace)，之后我们就可以调用各个设置好的参数啦 def parse_arg(): parser = argparse.ArgumentParser(description=&apos;描述内容&apos;) parser.add_argument(&apos;--param1&apos;, type=int,help=&apos;add some helpful message here.&apos;) parser.add_argument(&apos;--param2&apos;, type=int) parser.add_argument(&apos;--param3&apos;, type=float) args = parser.parse_args() #命名空间namespace return args官方文档链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"Argparse","slug":"Argparse","permalink":"https://pandamin18436220.github.io/tags/Argparse/"}]},{"title":"OpenCv基本函数","date":"2020-02-05T07:38:15.137Z","path":"2020/02/05/opencv基本函数/","text":"本篇文章附有opencv的基本函数使用和基本操作代码 导入库-*- coding: utf-8 -*- import cv2 #opencv2库 import numpy as np #numpy库 import matplotlib.pyplot as plt #类似于matlab工具读入图像函数为：cv2.imread(文件名[,显示控制参数]) 返回值：一个图像 功能：读取图像 当显示控制参数为 1/cv2.IMREAD_UNCHANGED 不改变 0/cv2.IMREAD_GRAYSCALE 图像灰度 -1/cv2.IMREAD_COLOR 图像彩度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426 o=cv2.imread('C:\\\\Users\\\\Pandamin\\\\Desktop\\\\image\\\\1.jpg',0) ## 保存图像 函数为：cv2.imwrite(文件地址，文件名) 返回值：无 功能：保存图像## 访问像素 函数为：img[位置[,通道数]] 返回值：该位置的像素 功能：得到该位置的图像，也可以更改其值## 使用numpy访问像素 函数为：img.itemset((位置[,通道数]),设置像素值) 返回值：该位置的像素 功能：得到该位置的图像，也可以更改其值## 获取图像属性 函数为：cv2.shape 返回值：返回行数，列数[,通道数] 功能：略## 函数为：cv2.size 返回值：返回行数*列数[*通道数] 功能：略## 函数为：cv2.dtype 返回值：返回图像的数据类型(unit8) 功能：略## 感兴趣区域(截取图像img中200:400到200:400的像素) 函数为：face=img[200:400,200:400] 返回值：截取后的图像 功能：略## 通道拆分和合并 函数为：b,g,r=cv2.split(图像名) 返回值：该图像b,g,r三个通道值 功能：获取三个通道的值## 函数为：m=cv2.merge([b,g,r]) 返回值：三个通道合成后的图像 功能：略## 图像加法 函数为：cv2.add(a,b) 返回值：是将a,b图像的对应像素点%255得到加法之后的图像 功能：略## 图像融合 函数为：cv2.addWeighted(图像1，图像1的系数，图像2，图像2的系数，亮度调节值) 返回值：融合后的图像 功能：可以将将两个残缺图像(且残缺的位置不同),融合为一个完整图像## 类型转换 函数为：cv2.cvtColor(图像名,cv2.COLOR_BGR2RGB) 返回值：由BGR通道转化到RGB通道的图像 功能：略 函数为：cv2.cvtColor(图像名,cv2.COLOR_GRAY2BGR) 返回值：由灰度类型转化到BGR通道的图像## 图像缩放 函数为：cv2.resize(src[,dsize=None],fx,fy) 返回值：缩放后的图像 参数：dsize缩放大小(列，行)，如果dsize=None,则可以通过fx(水平),fy(垂直)去缩放 功能：略## 图像旋转 函数为：cv2.flip(src,flipCode) 返回值：旋转后的图像 flipCode&gt;0 返回以Y轴为对称旋转 flipCode=0 返回以x轴为对称旋转 flipCode&lt;0 返回以x,y轴同时翻转## 阈值分割 二进制阈值化 函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_BINARY) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为白色，暗的处理为黑色。## 反二进制阈值化 函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_BINARY_INV) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为黑色，暗的处理为白色。## 截断阈值化 函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_TRUNC) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为阈值，暗的处理为不变。## 反阈值化为0 函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_TOZERO_INV) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为黑色0，暗的处理为不变。## 阈值化为0 函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_TOZERO) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为不变，暗的处理为黑色。## 均值滤波 函数为：cv2.blur(src,核大小) 返回值：返回均值化后的图像(图像更加平滑) 参数：核大小是以宽度＆高度形式表示的元组 功能：使图像更加平滑## 方框滤波 函数为：cv2.boxFilter(src,目标图像深度,核大小[,normalize属性=1]) 返回值：处理后的图像 参数： 目标图像深度为int类型的目标图像深度，通常使用“-1”表示与原始图像一致 核大小：（n,n）表示有n列n行 normalize=true时，进行归一化处理,与均值滤波相同 normalize=false时，很容易溢出,像素值易大于255,得到白色的图像## 高斯滤波 函数为：GaussianBlur(src,ksize,sigmaX) 返回值：略 参数： ksize：为核大小(n,n),必须为奇数 sigmaX：X方向方差，控制权重，一般sigmaX=0,其会自动算一个方差## 中值滤波 函数为：cv2.medianBlur(src,ksize) 参数： ksize：必须为比1大的奇数且只要写一个数值n，不要写(n,n)## 图像腐蚀 函数为：cv2.erode(src,kernel[,iterations=1]) 参数： kernel为卷积核,np.ones((n,n),np.unit8), 通过numpy的ones函数生成n*n的数值，其类型为unit8的卷积核 iterations为迭代次数## 图像膨胀 函数为：cv2.dilate(src,kernel[,iterations=1]) 参数： kernel为卷积核,np.ones((n,n),np.unit8), 通过numpy的ones函数生成n*n的数值，其类型为unit8的卷积核 iterations为迭代次数## 开运算：先进行腐蚀操作+膨胀操作，其作用去除噪声并保持原有的形状 函数为：cv2.morphologyEx(img,cv2.MORPH_OPEN,kernel) 参数： cv2.MORPH_OPEN 开运算 kernel 卷积核## 闭运算：先进行膨胀+腐蚀操作，其作用去掉物体内的小黑点 函数为：cv2.morphologyEx(img,cv2.MORPH_CLOSE,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_CLOSE 闭运算 kernel 卷积核## 梯度运算：将一个图像分别进行膨胀，腐蚀操作并将其相减，得到轮廓信息 函数为：cv2.morphologyEx(img,cv2.MORPH_GRADIENT,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_GRADIENT 梯度运算 kernel 卷积核## 礼帽(顶帽)运算：礼帽图像=原图像-开运算图像(去除噪声)，得到噪声图像 函数为：cv2.morphologyEx(img,cv2.MORPH_TOPHAT,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_TOPHAT 礼帽运算 kernel 卷积核## 黑帽图像处理：黑帽图像=闭运算图像-元素图像，得到图像内部的小黑点 函数为：cv2.morphologyEx(img,cv2.MORPH_BLACKHAT,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_BLACKHAT 黑帽运算 kernel 卷积核## 计算图像梯度,寻找边界(左右像素值差=0不是边界，!=0为边界，对其结果取绝对值) sobel算子：|左-右|+|下-上| 函数为：cv2.Sobel(src,dddpth,dx,dy,[ksize]) 参数： dddpth：处理结果图像深度，通常情况下，可以设置为-1，表示与原图像的深度一致。 但是在计算的时候可能会出现负值，会发生信息丢失，所以需要更高的数据类型 即dddpth取cv2.CV_64F,取绝对值后，再转换为np.unit8类型 取绝对值通过cv2.convertScaleAbs(scr[,alpha[,beta]]) 其作用是将原始图像转化为256色位图 dx:计算x方向的边界[dx=1,dy=0] dy:计算y方向的边界[dx=0,dy=1] 通过函数cv2.addWeighted(sobel_dx，图像1的系数，sobel_dy，图像2的系数，亮度调节值) ksize=-1时，等价于Scharr算子 scharr算子：|左-右|+|下-上| 函数为：cv2.Scharr(src,cv2.CV_64F,dx,dy) dx:计算x方向的边界dx=Scharrx(src,ddpeth,dx=1,dy=0) dy:计算y方向的边界dy=Scharry(src,ddpeth,dx=0,dy=1) 通过函数cv2.addWeighted(dx，图像1的系数，dy，图像2的系数，亮度调节值) ##且要满足dx&gt;=0&amp;&amp;dy&gt;=0&amp;&amp;&amp;dx+dy==1 参数值：略 拉普拉斯算子：|左-右|+|左-右|+|下-上|+|下-上| 函数为：cv2.Laplacian(src,dddpth) 即dddpth取cv2.CV_64F,取绝对值后，再转换为np.unit8类型 取绝对值通过cv2.convertScaleAbs(scr[,alpha[,beta]]) 其作用是将原始图像转化为256色位图 参数值：略## canny边缘检测 函数为：cv2.Canny(src,阈值1,阈值2) 参数值：阈值1minVal,阈值2maxVal,两个阈值是来控制边界信息的丰富程度的， 阈值越小得到图像的边界越丰富，越细致## 图像金字塔 pyrDown(图像向下取样，变成原来的1/4)，pyrUp(图像向下取样，变成原来4倍) 函数为：cv2.pyrDown(src) cv2.pyrUp(src) 参数值：略 取样可逆性研究：经过放到缩小图像是否不变？不一样，图像的清晰度变差## 拉普拉斯金字塔 函数为：Li=Gi-PyrUp(PyrDown(Gi)) 参数值：Gi原始图像，Li拉普拉斯图像 例如： od=cv2.pyrDown(o) odu=cv2.pyrUp(od) lapPyr=o-odu 拉普拉斯金字塔图像第0层 o1=od o1d=cv2.pyrDown(o1) o1du=cv2.pyrUp(o1d) lapPyr1=o1-o1du 拉普拉斯金字塔图像第1层 即拉普拉斯图像+向下取样图像=原始图像## 计算轮廓的面积 函数为：cv2.contourArea(cnt， True) 参数值：cnt为输入的单个轮廓值## 计算轮廓的周长 函数为：cv2.arcLength(cnt， True) 参数值：cnt为输入的单个轮廓值## 用于获得轮廓的近似值，使用cv2.drawCountors进行画图操作 函数为：cv2.aprroxPolyDP(cnt, epsilon， True) 参数值：cnt为输入的轮廓值， epsilon为阈值T，通常使用轮廓的周长作为阈值，True表示的是轮廓是闭合的## 获得外接矩形 函数为：x, y, w, h = cv2.boudingrect(cnt) 参数值：x，y, w, h 分别表示外接矩形的x轴和y轴的坐标，以及矩形的宽和高， cnt表示输入的轮廓值## 生成最小外接矩形 函数为：cv2.minAreaRect(cnt) 参数为：cnt为输入的轮廓值。[是点集数组或向量（里面存放的是点的坐标），并且这个点集中的元素不定个数。] 返回值：返回一个Box2D结构rect:（rect[0]中心(x,y), (rect[1][0]宽,rect[1][1]高),rect[2]旋转角度）## 根据坐标在图像上画出矩形 函数为：cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2) 参数值: img表示传入的图片， (x, y)表示左上角的位置, （x+w， y+h）表示加上右下角的位置，（0, 255, 0)表示颜色，2表示线条的粗细## 获得外接圆的位置信息 函数为：(x, y), radius = cv2.minEnclosingCircle(cnt) 参数值: (x, y)表示外接圆的圆心，radius表示外接圆的半径， cnt表示输入的轮廓## 根据坐标在图上画出圆 函数为：cv2.Cricle(img, center, radius, (0, 255, 0), 2) 参数值:img表示需要画的图片，center表示圆的中心点，radius表示圆的半径, (0, 255, 0)表示颜色， 2表示线条的粗细## 查找检测物体的轮廓 函数为：cv2.findContours(image, mode, method[, contours[, hierarchy[, offset ]]]) 参数值： 第一个参数是寻找轮廓的图像；二值图像 第二个参数表示轮廓的检索模式，有四种（本文介绍的都是新的cv2接口）： cv2.RETR_EXTERNAL表示只检测外轮廓 cv2.RETR_LIST检测的轮廓不建立等级关系 cv2.RETR_CCOMP建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。 cv2.RETR_TREE建立一个等级树结构的轮廓。 第三个参数method为轮廓的近似办法 cv2.CHAIN_APPROX_NONE存储所有的轮廓点，相邻的两个点的像素位置差不超过1，即max（abs（x1-x2），abs（y2-y1））==1 cv2.CHAIN_APPROX_SIMPLE压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息 cv2.CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法 返回值： 一个是轮廓本身，还有一个是每条轮廓对应的属性， 可返回一个可选的hiararchy结果。[这是一个ndarray，其中的元素个数和轮廓个数相同; 每个轮廓contours[i]对应4个hierarchy元素hierarchy[i][0] ~hierarchy[i][3]; 分别表示后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号，如果没有对应项，则该值为负数] （返回一个list，list中每个元素都是图像中的一个轮廓，用numpy中的ndarray表示）## 图像轮廓：边界与轮廓的区别，轮廓是指连续的边界 函数为:cv2.drawContours(src,contours,contourldx,color[,thickness]) 参数值： contours：需要绘制的边缘数组 contourldx:需要绘制的边缘索引，如果全部绘制为-1 color:绘制的颜色，为BGR格式的Scalar thinckness:绘制的密度，即轮廓画笔的粗细## 绘制直方图 函数为：plt.hist(src.ravel(),256) 参数值：将src转化为一维数组 像素级一般为256,为八位的图像的灰度级：[0,255]## 使用Opencv统计直方图 函数为：hist=cv2.calcHist(images,channels,mask,histSize,ranges[,accumulate]) 通过函数plt.plot(hist，color='g/b/r')绘制出来 参数值： images:原始图像 channels：指定通道 mask：掩码图像，统计整幅图像的直方图为None histSize：BINS的数量,一般为[256]--灰度图像 ranges：像素值范围RANGE，一般为[0,255] accumulate:累计标识 返回值：返回一个直方图hist## 使用掩码直方图：先通过zeros生成全黑图像，在截取相应区域为白色 函数为：mask=np.zeros(src.shape,np.unit8) mask[200:400,200:400]=255 参数值：src.shape元素图像的大小，np.unit8为八位的位图 返回值：略## 直方图均值化原理：色彩的细节更加丰富 函数为：equ=cv2.qualizeHist(src) 参数值：略 返回值：略## subplot函数：一个窗口显示多个图像 函数为：plt.subplot(n行,n列,窗口序列) 例如：plt.subplot(121),plt.hist(img.ravel(),256) plt.subplot(122),plt.hist(img.ravel(),256) 函数为：imshow(x,cmap=None) 参数值：x为需要绘制的图像 cmap为颜色图谱，默认为RGB(A)颜色空间 若要显示灰度图像：cmap=plt.cm,gray 若雅显示彩色图像:如果是通过python读进来的，则不需要处理RGB 如果是通过opencv读进来的，则其默认BGR,要调整色彩空间 使用默认值，显示彩色图像 plt.subplot(221) plt.imshow(scr_color),plt.axis('off')## 使用gray参数，显示彩色图像 plt.subplot(222) plt.imshow(src_color,cmap=plt.cm.gray),plt.axis('off')## 使用默认值，显示彩色度图像 plt.subplot(223) plt.imshow(src_gray),plt.axis('off')## 使用gray参数，显示灰度图像【灰度图像+灰度类型才可以显示灰度图像】 plt.subplot(224) plt.imshow(src_gray,cmap=plt.cm.gray),plt.axis('off')#设置直方图没有坐标## 傅里叶变换 函数为：f=np.fft.fft2(src) 返回值：返回一个复数的数组## 移动到中心位置：将零频率分量移动到频谱中心 函数为：fshift=np.fft.fftshift(f) 将复数数组转化为灰度图像--&gt;20*np.log(np.abs(fshift))设置频谱的范围## 逆傅里叶变换 函数为：ifshift=np.fft.ifftshift(f) iimg=np.fft.ifft2(ishift) iimg=np.abs(iimg)## 显示图像，删除所有窗口 函数为：cv2.imshow(窗口名，图像名) cv2.waitKey([,delay]) cv2.destroyAllWindows() 参数值： delay: delay&gt;0 等待delay毫秒 delay&lt;0 等待键盘单击 delay=0 无限等待## 参考代码一-- coding: utf-8 --import cv2 #opencv2库import numpy as npimport time#读取图片o=cv2.imread(‘C:/Users/Pandamin/Desktop/img/1.jpg’,1)#o1=cv2.imread(‘C:/Users/Pandamin/Desktop/img/1.jpg’,0)#cv2.imshow(‘src’,o)#cv2.imshow(‘src1’,o1)‘’’frameWidth=o[0]frameHeight=o[1]frameChannels=o[2]frameArray=np.frombuffer(o[6],dtype=np.unit8).reshape([frameHeight,frameWidth,frameChannels])‘’’#转化成HSVhue_image = cv2.cvtColor(o, cv2.COLOR_BGR2HSV)#cv2.imshow(‘hue_image’, hue_image) #双阈值化处理low_range = np.array([160, 83, 100])high_range = np.array([180, 255, 255])#OpenCV中的inRange()函数可实现二值化功能（这点类似threshold()函数）#更关键的是可以同时针对多通道进行操作，使用起来非常方便！#将两阈值范围内的设置为白色，不在的设置为黑色,具有双阈值化操作th = cv2.inRange(hue_image, low_range, high_range)#cv2.imshow(‘HSV_hueimgae’, th)#th = cv2.inRange(o, low_range, high_range)#cv2.imshow(‘HSV_o’, th) #二进制阈值化处理(只能够将大于阈值的显示白色，小于阈值的显示黑色，前提是灰度图像)#r,b=cv2.threshold(hue_image,127,255,cv2.THRESH_BINARY)#cv2.imshow(‘threshold_hue’, b)r,b=cv2.threshold(th,127,255,cv2.THRESH_BINARY)cv2.imshow(‘threshold_o’, b) 平滑处理gaus=cv2.GaussianBlur(th,(7,7),1.5)#cv2.imshow(‘result’, gaus)‘’’ 腐蚀eroded = cv2.erode(gaus, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (4, 4)), iterations=2)cv2.imshow(‘result腐蚀’, eroded) 膨胀dilated = cv2.dilate(eroded, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3)), iterations=2)cv2.imshow(‘result膨胀’, dilated)‘’’#开运算kernel=np.ones((5,5))openA=cv2.morphologyEx(gaus,cv2.MORPH_OPEN,kernel)cv2.imshow(‘open’, openA) #梯度运算openA=cv2.Canny(openA,30,100)cv2.imshow(‘open1’, openA) Hough Circle‘’’cv2.HoughCircles(image,method,dp,minDist[, circles[,param1, param2[,minRadius[,maxRadius]]]]])image 不用多说，输入矩阵method cv2.HOUGH_GRADIENT 也就是霍夫圆检测，梯度法dp 计数器的分辨率图像像素分辨率与参数空间分辨率的比值（官方文档上写的是图像分辨率与累加器分辨率的比值，它把参数空间认为是一个累加器，毕竟里面存储的都是经过的像素点的数量），dp=1，则参数空间与图像像素空间（分辨率）一样大，dp=2，参数空间的分辨率只有像素空间的一半大minDist 圆心之间最小距离，如果距离太小，会产生很多相交的圆，如果距离太大，则会漏掉正确的圆param1 canny检测的双阈值中的高阈值，低阈值是它的一半param2 最小投票数（基于圆心的投票数）minRadius 需要检测圆的最小半径maxRadius 需要检测圆的最大半径‘’’circles = cv2.HoughCircles(openA, cv2.HOUGH_GRADIENT, 1, 60, param1=15, param2=7, minRadius=5, maxRadius=50) 绘制if circles is not None: for x,y,radius in circles[0]: #x, y, radius = circles[0][0] center = (x, y) cv2.circle(o, center, radius, (0, 255, 0), 2)‘’’#从图像中底部往上跨越，找到相邻2像素且在中心的红色，并标志（此处可以添加误差，以减少寻找时间）for i in range(476,0,-2): if b[i][320]!=0 and b[i+2][320]!=0: cv2.line(img,(0,i),(640,i),(255,255,0),2) flag=1 break‘’’cv2.imshow(‘result’, o)cv2.waitKey()cv2.destroyAllWindows() 12## 参考代码二 import cv2import numpy as np def cv_show(img, name): cv2.imshow(name, img) cv2.waitKey(0) cv2.destroyAllWindows() 第一步读入图片img = cv2.imread(‘car.png’) 第二步：对图片做灰度变化gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) 第三步：对图片做二值变化ret, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY) 第四步：获得图片的轮廓值Binary, contours, h = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) 第五步：在图片中画出图片的轮廓值draw_img = img.copy()ret = cv2.drawContours(draw_img, contours, -1, (0, 0, 255), 2) 第六步：画出带有轮廓的原始图片cv_show(ret, ‘ret’) 使用另外一个图进行轮廓的测试第一步：载入图片，灰度化和二值化处理,使用cv2.findContours找出轮廓, 使用cv2.drawContours进行画图操作img = cv2.imread(‘contours.png’)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)ret, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY) binary, contours, h = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) draw_img = img.copy() 参数说明,draw_img 需要作图的原始图像， contours表示轮廓， 0表示轮廓索引， (0, 0, 255)表示颜色， 2表示线条粗细ret = cv2.drawContours(draw_img, contours, 0, (0, 0, 255), 2)cv_show(ret, ‘ret’) 取出单个的轮廓值cnt = contours[0] 第二步：计算轮廓的面积area = cv2.contourArea(cnt) 第三步： 计算轮廓的周长length= cv2.arcLength(cnt, True) print(area, length) 轮廓近似img = cv2.imread(‘contours2.png’)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)ret, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY) Binary, contours, h = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) cnt = contours[0] 使用周长的倍数作为阈值，阈值越小，图像的轮廓近似与轮廓越近似epsilon = 0.1 * cv2.arcLength(cnt, True) approx = cv2.approxPolyDP(cnt, epsilon, True) draw_img = img.copy()ret = cv2.drawContours(draw_img, [approx], -1, (0, 0, 255), 2)cv_show(ret, ‘ret’) 外接矩阵img = cv2.imread(‘contours.png’)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)res, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY) binary, contours, h = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) cnt = contours[0] x, y, w, h = cv2.boundingRect(cnt) ret = cv2.rectangle(img, (x, y), (x+w, y+h), (0, 0, 255), 2)cv_show(ret, ‘ret’) print(‘矩形面积 / 外接矩形面积’, cv2.contourArea(cnt) / (w*h)) 外接圆(x, y), radius = cv2.minEnclosingCircle(cnt)center = (int(x), int(y))radius = int(radius)ret = cv2.circle(ret, center, radius, (0, 255, 0), 2)cv_show(ret, ‘ret’)```","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"OpenCv","slug":"OpenCv","permalink":"https://pandamin18436220.github.io/tags/OpenCv/"}]},{"title":"Markdown的基本使用","date":"2020-02-04T05:53:24.883Z","path":"2020/02/04/Markdowm的基本使用/","text":"二级标题 粗体文本 斜体文本 粗斜体文本 * 无序列表 有序列表 你好(前面有四个空格/Tab) 用&gt;表示区块 二级区块 1表示代码部分使用链接 表头 表头 表头 表头 表头 表头","comments":true,"tags":[{"name":"Markdowm","slug":"Markdowm","permalink":"https://pandamin18436220.github.io/tags/Markdowm/"}]}]