[{"title":"OpenCv基本函数","date":"2020-02-05T07:38:15.137Z","path":"2020/02/05/opencv基本函数/","text":"导入库1234567-*- coding: utf-8 -*-import cv2 #opencv2库import numpy as np #numpy库import matplotlib.pyplot as plt #类似于matlab工具 读入图像函数为：cv2.imread(文件名[,显示控制参数]) 返回值：一个图像 功能：读取图像 当显示控制参数为 0/cv2.IMREAD_UNCHANGED 不改变 -1/cv2.IMREAD_GRAYSCALE 图像灰度 1/cv2.IMREAD_COLOR 图像菜度 1o=cv2.imread('C:\\\\Users\\\\Pandamin\\\\Desktop\\\\image\\\\1.jpg',0)保存图像函数为：cv2.imwrite(文件地址，文件名) 返回值：无 功能：保存图像访问像素函数为：img[位置[,通道数]] 返回值：该位置的像素 功能：得到该位置的图像，也可以更改其值使用numpy访问像素函数为：img.itemset((位置[,通道数]),设置像素值) 返回值：该位置的像素 功能：得到该位置的图像，也可以更改其值获取图像属性函数为：cv2.shape 返回值：返回行数，列数[,通道数] 功能：略函数为：cv2.size返回值：返回行数*列数[*通道数] 功能：略函数为：cv2.dtype返回值：返回图像的数据类型(unit8) 功能：略感兴趣区域(截取图像img中200:400到200:400的像素)函数为：face=img[200:400,200:400] 返回值：截取后的图像 功能：略通道拆分和合并函数为：b,g,r=cv2.split(图像名) 返回值：该图像b,g,r三个通道值 功能：获取三个通道的值函数为：m=cv2.merge([b,g,r])返回值：三个通道合成后的图像 功能：略图像加法函数为：cv2.add(a,b) 返回值：是将a,b图像的对应像素点%255得到加法之后的图像 功能：略图像融合函数为：cv2.addWeighted(图像1，图像1的系数，图像2，图像2的系数，亮度调节值) 返回值：融合后的图像 功能：可以将将两个残缺图像(且残缺的位置不同),融合为一个完整图像类型转换函数为：cv2.cvtColor(图像名,cv2.COLOR_BGR2RGB) 返回值：由BGR通道转化到RGB通道的图像 功能：略 函数为：cv2.cvtColor(图像名,cv2.COLOR_GRAY2BGR) 返回值：由灰度类型转化到BGR通道的图像图像缩放函数为：cv2.resize(src[,dsize=None],fx,fy) 返回值：缩放后的图像 参数：dsize缩放大小(列，行)，如果dsize=None,则可以通过fx(水平),fy(垂直)去缩放 功能：略图像旋转函数为：cv2.flip(src,flipCode) 返回值：旋转后的图像 flipCode&gt;0 返回以Y轴为对称旋转 flipCode=0 返回以x轴为对称旋转 flipCode&lt;0 返回以x,y轴同时翻转阈值分割二进制阈值化 函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_BINARY) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为白色，暗的处理为黑色。反二进制阈值化函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_BINARY_INV) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为黑色，暗的处理为白色。截断阈值化函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_TRUNC) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为阈值，暗的处理为不变。反阈值化为0函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_TOZERO_INV) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为黑色0，暗的处理为不变。阈值化为0函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_TOZERO) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为不变，暗的处理为黑色。均值滤波函数为：cv2.blur(src,核大小) 返回值：返回均值化后的图像(图像更加平滑) 参数：核大小是以宽度＆高度形式表示的元组 功能：使图像更加平滑方框滤波函数为：cv2.boxFilter(src,目标图像深度,核大小[,normalize属性=1]) 返回值：处理后的图像 参数： 目标图像深度为int类型的目标图像深度，通常使用“-1”表示与原始图像一致 核大小：（n,n）表示有n列n行 normalize=true时，进行归一化处理,与均值滤波相同 normalize=false时，很容易溢出,像素值易大于255,得到白色的图像高斯滤波函数为：GaussianBlur(src,ksize,sigmaX) 返回值：略 参数： ksize：为核大小(n,n),必须为奇数 sigmaX：X方向方差，控制权重，一般sigmaX=0,其会自动算一个方差中值滤波函数为：cv2.medianBlur(src,ksize) 参数： ksize：必须为比1大的奇数且只要写一个数值n，不要写(n,n)图像腐蚀函数为：cv2.erode(src,kernel[,iterations=1]) 参数： kernel为卷积核,np.ones((n,n),np.unit8), 通过numpy的ones函数生成n*n的数值，其类型为unit8的卷积核 iterations为迭代次数图像膨胀函数为：cv2.dilate(src,kernel[,iterations=1]) 参数： kernel为卷积核,np.ones((n,n),np.unit8), 通过numpy的ones函数生成n*n的数值，其类型为unit8的卷积核 iterations为迭代次数开运算：先进行腐蚀操作+膨胀操作，其作用去除噪声并保持原有的形状函数为：cv2.morphologyEx(img,cv2.MORPH_OPEN,kernel) 参数： cv2.MORPH_OPEN 开运算 kernel 卷积核闭运算：先进行膨胀+腐蚀操作，其作用去掉物体内的小黑点函数为：cv2.morphologyEx(img,cv2.MORPH_CLOSE,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_CLOSE 闭运算 kernel 卷积核梯度运算：将一个图像分别进行膨胀，腐蚀操作并将其相减，得到轮廓信息函数为：cv2.morphologyEx(img,cv2.MORPH_GRADIENT,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_GRADIENT 梯度运算 kernel 卷积核礼帽(顶帽)运算：礼帽图像=原图像-开运算图像(去除噪声)，得到噪声图像函数为：cv2.morphologyEx(img,cv2.MORPH_TOPHAT,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_TOPHAT 礼帽运算 kernel 卷积核黑帽图像处理：黑帽图像=闭运算图像-元素图像，得到图像内部的小黑点函数为：cv2.morphologyEx(img,cv2.MORPH_BLACKHAT,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_BLACKHAT 黑帽运算 kernel 卷积核计算图像梯度,寻找边界(左右像素值差=0不是边界，!=0为边界，对其结果取绝对值)sobel算子：|左-右|+|下-上| 函数为：cv2.Sobel(src,dddpth,dx,dy,[ksize]) 参数： dddpth：处理结果图像深度，通常情况下，可以设置为-1，表示与原图像的深度一致。 但是在计算的时候可能会出现负值，会发生信息丢失，所以需要更高的数据类型 即dddpth取cv2.CV_64F,取绝对值后，再转换为np.unit8类型 取绝对值通过cv2.convertScaleAbs(scr[,alpha[,beta]]) 其作用是将原始图像转化为256色位图 dx:计算x方向的边界[dx=1,dy=0] dy:计算y方向的边界[dx=0,dy=1] 通过函数cv2.addWeighted(sobel_dx，图像1的系数，sobel_dy，图像2的系数，亮度调节值) ksize=-1时，等价于Scharr算子 scharr算子：|左-右|+|下-上| 函数为：cv2.Scharr(src,cv2.CV_64F,dx,dy) dx:计算x方向的边界dx=Scharrx(src,ddpeth,dx=1,dy=0) dy:计算y方向的边界dy=Scharry(src,ddpeth,dx=0,dy=1) 通过函数cv2.addWeighted(dx，图像1的系数，dy，图像2的系数，亮度调节值) ##且要满足dx&gt;=0&amp;&amp;dy&gt;=0&amp;&amp;&amp;dx+dy==1 参数值：略 拉普拉斯算子：|左-右|+|左-右|+|下-上|+|下-上| 函数为：cv2.Laplacian(src,dddpth) 即dddpth取cv2.CV_64F,取绝对值后，再转换为np.unit8类型 取绝对值通过cv2.convertScaleAbs(scr[,alpha[,beta]]) 其作用是将原始图像转化为256色位图 参数值：略canny边缘检测函数为：cv2.Canny(src,阈值1,阈值2) 参数值：阈值1minVal,阈值2maxVal,两个阈值是来控制边界信息的丰富程度的， 阈值越小得到图像的边界越丰富，越细致图像金字塔pyrDown(图像向下取样，变成原来的1/4)，pyrUp(图像向下取样，变成原来4倍) 函数为：cv2.pyrDown(src) cv2.pyrUp(src) 参数值：略 取样可逆性研究：经过放到缩小图像是否不变？不一样，图像的清晰度变差拉普拉斯金字塔函数为：Li=Gi-PyrUp(PyrDown(Gi)) 参数值：Gi原始图像，Li拉普拉斯图像 例如： od=cv2.pyrDown(o) odu=cv2.pyrUp(od) lapPyr=o-odu 拉普拉斯金字塔图像第0层 o1=od o1d=cv2.pyrDown(o1) o1du=cv2.pyrUp(o1d) lapPyr1=o1-o1du 拉普拉斯金字塔图像第1层 即拉普拉斯图像+向下取样图像=原始图像图像轮廓：边界与轮廓的区别，轮廓是指连续的边界函数为:cv2.drawContours(src,contours,contourldx,color[,thickness]) 参数值： contours：需要绘制的边缘数组 contourldx:需要绘制的边缘索引，如果全部绘制为-1 color:绘制的颜色，为BGR格式的Scalar thinckness:绘制的密度，即轮廓画笔的粗细绘制直方图函数为：plt.hist(src.ravel(),256) 参数值：将src转化为一维数组 像素级一般为256,为八位的图像的灰度级：[0,255]使用Opencv统计直方图函数为：hist=cv2.calcHist(images,channels,mask,histSize,ranges[,accumulate]) 通过函数plt.plot(hist，color=&apos;g/b/r&apos;)绘制出来 参数值： images:原始图像 channels：指定通道 mask：掩码图像，统计整幅图像的直方图为None histSize：BINS的数量,一般为[256]--灰度图像 ranges：像素值范围RANGE，一般为[0,255] accumulate:累计标识 返回值：返回一个直方图hist使用掩码直方图：先通过zeros生成全黑图像，在截取相应区域为白色函数为：mask=np.zeros(src.shape,np.unit8) mask[200:400,200:400]=255 参数值：src.shape元素图像的大小，np.unit8为八位的位图 返回值：略直方图均值化原理：色彩的细节更加丰富函数为：equ=cv2.qualizeHist(src) 参数值：略 返回值：略subplot函数：一个窗口显示多个图像函数为：plt.subplot(n行,n列,窗口序列) 例如：plt.subplot(121),plt.hist(img.ravel(),256) plt.subplot(122),plt.hist(img.ravel(),256) 函数为：imshow(x,cmap=None) 参数值：x为需要绘制的图像 cmap为颜色图谱，默认为RGB(A)颜色空间 若要显示灰度图像：cmap=plt.cm,gray 若雅显示彩色图像:如果是通过python读进来的，则不需要处理RGB 如果是通过opencv读进来的，则其默认BGR,要调整色彩空间 使用默认值，显示彩色图像 plt.subplot(221) plt.imshow(scr_color),plt.axis(&apos;off&apos;)使用gray参数，显示彩色图像plt.subplot(222) plt.imshow(src_color,cmap=plt.cm.gray),plt.axis(&apos;off&apos;)使用默认值，显示彩色度图像plt.subplot(223) plt.imshow(src_gray),plt.axis(&apos;off&apos;)使用gray参数，显示灰度图像【灰度图像+灰度类型才可以显示灰度图像】plt.subplot(224) plt.imshow(src_gray,cmap=plt.cm.gray),plt.axis(&apos;off&apos;)#设置直方图没有坐标傅里叶变换函数为：f=np.fft.fft2(src) 返回值：返回一个复数的数组移动到中心位置：将零频率分量移动到频谱中心函数为：fshift=np.fft.fftshift(f) 将复数数组转化为灰度图像--&gt;20*np.log(np.abs(fshift))设置频谱的范围逆傅里叶变换函数为：ifshift=np.fft.ifftshift(f) iimg=np.fft.ifft2(ishift) iimg=np.abs(iimg)显示图像，删除所有窗口函数为：cv2.imshow(窗口名，图像名) cv2.waitKey([,delay]) cv2.destroyAllWindows() 参数值： delay: delay&gt;0 等待delay毫秒 delay&lt;0 等待键盘单击 delay=0 无限等待","comments":true,"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"OpenCv","slug":"OpenCv","permalink":"http://yoursite.com/tags/OpenCv/"}]},{"title":"Markdowm的基本使用","date":"2020-02-04T05:53:24.883Z","path":"2020/02/04/Markdowm的基本使用/","text":"一级标题二级标题 粗体文本 斜体文本 粗斜体文本 * 无序列表 有序列表 你好(前面有四个空格/Tab) 用&gt;表示区块 二级区块 1表示代码部分使用链接 表头 表头 表头 表头 表头 表头","comments":true,"tags":[]},{"title":"Hello World","date":"2020-02-03T13:45:51.816Z","path":"2020/02/03/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"tags":[]}]