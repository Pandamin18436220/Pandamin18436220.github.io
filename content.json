[{"title":"Pandas库","date":"2020-02-20T07:52:20.601Z","path":"2020/02/20/pandas库/","text":"pandas的作用我们知道numpy是矩阵运算的这么一个库，而pandas是数据处理这么一个库。其操作会基于numpy的内部函数。 pandas读取需要处理的文件 1234567891011121314151617import pandasfood_info=pandas.read_csv(\"food_info.csv\")print(type(food_info)) #DataFrame(类似于矩阵结构)print(food_info.dtypes) #int64,float64,object(字符型)print(help(pandas.read_csv))#显示数据food_info.head(m)#但m值不给定时，默认显示前5条数据food_info.head(n)#但n值不给定时，默认显示后5条数据food_info.colums()#显示列名food_info.shape()#显示行与列#取数据food_info.loc[m] #取第m行数据food_info.loc[m:n] #取第m-n行数据food_info.loc[a,b,c] #a,b,c行的数据ndb_col=foold_info[\"NDB_No\"] #打印列名对应的这一列 Numpy的基本使用下面介绍Numpy的基础知识与相关函数 创建数组及使用 12345678910111213141516171819202122232425262728#定义了一个二维数组，大小为（2，3）&gt;&gt;&gt; x=np.array([ [1.0,0.0,0.0], [0.,1.,2.] ])&gt;&gt;&gt; xarray([[1., 0., 0.], [0., 1., 2.]])#数组维度数&gt;&gt;&gt; x.ndim2#数组的维数，返回的格式(n,m),其中n为行数，m为列数&gt;&gt;&gt; x.shape(2, 3)#数组元素的总数&gt;&gt;&gt; x.size6#数组元素类型&gt;&gt;&gt; x.dtype#64位浮点型dtype('float64')#每个元素占有的字节大小 &gt;&gt;&gt; x.itemsize 8#数组元素的缓冲区&gt;&gt;&gt; x.data&lt;memory at 0x00000205227DAC18&gt; 知识点扩展: 创建序列数组的函数arrange和linspace。（range函数类似） arange(a,b,c) 参数表示(开始值，结束值，步长) linspace(a,b,c) 参数表示(开始值，结束值，元素数量) 调用reshape()可以指定形状 123456789101112&gt;&gt;&gt; arange(6).reshape(2,3)array([ [ 0, 1, 2], [ 3, 4, 5], [10, 11, 12] ])&gt;&gt;&gt; arange(1,5,2) array([1, 3, 5])&gt;&gt;&gt; arange(0,1,0.5) array([0. , 0.5, 1])&gt;&gt;&gt; linspace(0,2,9) array([0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) 特殊数组 zeros数组：全零数组，元素全为零。 ones数组：全1数组，元素全为1。 empty数组：空数组，元素全近似为0。 1234567891011121314151617181920212223242526&gt;&gt;&gt; zeros((3,4)) array([ [0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.] ])&gt;&gt;&gt; ones((2,3,4),dtype=int16) array([ [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ], [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] ], dtype=int16)&gt;&gt;&gt; empty((5,3)) array([ [6.23042070e-307, 1.42417221e-306, 1.37961641e-306], [1.11261027e-306, 1.11261502e-306, 1.42410839e-306], [7.56597770e-307, 6.23059726e-307, 1.42419530e-306], [7.56599128e-307, 1.11260144e-306, 6.89812281e-307], [2.22522596e-306, 2.22522596e-306, 2.56761491e-312] ]) 数组索引 Numpy数组通过索引访问12345678910111213141516171819&gt;&gt;&gt; c=arange(24).reshape(2,3,4)&gt;&gt;&gt; print(c)[ [ [ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] ] [ [12 13 14 15] [16 17 18 19] [20 21 22 23] ]]&gt;&gt;&gt; print(c[1,2,:]) [20 21 22 23]&gt;&gt;&gt; print(c[0,1,2]) 6 数组运算 数组的加减乘除以及乘方运算方式为:相应位置的元素分别进行运算。12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; a=array([20,30,40,50])&gt;&gt;&gt; aa=arange(1,5)&gt;&gt;&gt; a/aa array([20. , 15. , 13.33333333, 12.5 ])&gt;&gt;&gt; b=arange(4)&gt;&gt;&gt; b array([0, 1, 2, 3])&gt;&gt;&gt; c=a-b&gt;&gt;&gt; c array([20, 29, 38, 47])&gt;&gt;&gt; b**2 array([0, 1, 4, 9], dtype=int32)&gt;&gt;&gt; A=array([ [1,1], [0,1] ])&gt;&gt;&gt; B=array([ [2,0], [3,4] ])&gt;&gt;&gt; A*B array([ [2, 0], [0, 4] ])&gt;&gt;&gt; A.sum() 3&gt;&gt;&gt; A.min() 0&gt;&gt;&gt; A.max() 1 数组的拷贝 拷贝有浅拷贝和深拷贝两种; 浅拷贝通过数组变量的赋值完成,浅拷贝只拷贝数组的引用，如果对拷贝进行修改，源数组也将修改; 深拷贝使用数组对象的copy方法，会复制一份和源数组一样的数组，新数组与源数组会存放在不同内存位置，因此对新数组的修改不会影响源数组。 案例一(浅拷贝)1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; a=ones((2,3))&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 1.] ])&gt;&gt;&gt; b=a&gt;&gt;&gt; b[1,2]=2&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 2.] ])&gt;&gt;&gt; b array([ [1., 1., 1.], [1., 1., 2.] ])案例二(深拷贝)&gt;&gt;&gt; a=ones((2,3))&gt;&gt;&gt; b=a.copy()&gt;&gt;&gt; b[1,2]=2&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 1.] ])&gt;&gt;&gt; b array([ [1., 1., 1.], [1., 1., 2.] ]) 创建矩阵 矩阵与数组的区别Numpy的矩阵对象与数组对象相似。其不同之处在于，矩阵对象的计算遵循矩阵数学运算律。矩阵使用matrix函数创建。1234567891011121314151617&gt;&gt;&gt; A=matrix('1.0 2.0;3.0 4.0')&gt;&gt;&gt; A matrix([ [1., 2.], [3., 4.] ])&gt;&gt;&gt; B=matrix([ [1.0,2.0], [3.0,4.0] ])&gt;&gt;&gt; B matrix([ [1., 2.], [3., 4.] ])&gt;&gt;&gt; type(A) &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt; 矩阵运算 123456789101112131415161718&gt;&gt;&gt; A.T #转置 matrix([ [1., 3.], [2., 4.] ])&gt;&gt;&gt; x=matrix('5.0 7.0')&gt;&gt;&gt; y=x.T&gt;&gt;&gt; y matrix([ [5.], [7.] ])&gt;&gt;&gt; print(A*y) #矩阵乘法 [[26.] [38.]]&gt;&gt;&gt; print(A.I) #逆矩阵 [[-2. 1. ] [ 1.5 -0.5]] Numpy线性代数相关函数 numpy.dot() 此函数返回两个数组的点积。 对于二维向量，其等效于矩阵乘法。 对于一维数组，它是向量的内积。 对于 N 维数组，它是a的最后一个轴上的和与b的倒数第二个轴的乘积。 12345&gt;&gt;&gt; a=np.array([[1,2],[3,4]])&gt;&gt;&gt; b=np.array([[11,12],[13,14]])&gt;&gt;&gt; np.dot(a,b) array([[37, 40], #[[1*11+2*13, 1*12+2*14],[3*11+4*13, 3*12+4*14]] [85, 92]]) numpy.vdot() 此函数返回两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数id是多维数组，它会被展开。 12&gt;&gt;&gt; np.vdot(a,b) 130 #1*11+2*12+3*13+4*14=130 numpy.inner() 此函数返回一维数组的向量内积。 对于更高的维度，它返回最后一个轴上的和的乘积。 1234&gt;&gt;&gt; x=np.array([1,2,3])&gt;&gt;&gt; y=np.array([0,1,0])&gt;&gt;&gt; print(np.inner(x,y)) 2 # 等价于 1*0+2*1+3*0 numpy.matmul() 函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。 另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。 #对二维数组（列表），就相当于矩阵乘法 123456789101112131415161718192021&gt;&gt;&gt; a=[[1,0],[0,1]]&gt;&gt;&gt; b=[[4,1],[2,2]]&gt;&gt;&gt; print(np.matmul(a,b))[[4 1][2 2]]#二维和一维运算&gt;&gt;&gt; a=[[1,0],[0,1]]&gt;&gt;&gt; b=[1,2]&gt;&gt;&gt; print(np.matmul(a,b)) [1 2]&gt;&gt;&gt; print(np.matmul(b,a)) [1 2]#维度大于2的&gt;&gt;&gt; a=np.arange(8).reshape(2,2,2)&gt;&gt;&gt; b=np.arange(4).reshape(2,2)&gt;&gt;&gt; print(np.matmul(a,b)) [[[ 2 3] [ 6 11]] [[10 19] [14 27]]] numpy.linalg.det() 行列式在线性代数中是非常有用的值。 它从方阵的对角元素计算。 对于 2×2 矩阵，它是左上和右下元素的乘积与其他两个的乘积的差。 换句话说，对于矩阵[[a，b]，[c，d]]，行列式计算为ad-bc。 较大的方阵被认为是 2×2 矩阵的组合。 numpy.linalg.det()函数计算输入矩阵的行列式。 123456789101112&gt;&gt;&gt; a=np.array([[1,2],[3,4]])&gt;&gt;&gt; print(np.linalg.det(a)) -2.0000000000000004&gt;&gt;&gt; b=np.array([[6,1,1],[4,-2,5],[2,8,7]])&gt;&gt;&gt; print(b) [[ 6 1 1] [ 4 -2 5] [ 2 8 7]]&gt;&gt;&gt; print(np.linalg.det(b)) -306.0&gt;&gt;&gt; print(6*(-2*7-5*8)-1*(4*7-5*2)+(4*8- -2*2)) -306 numpy.linalg.solve() 该函数给出了矩阵形式的线性方程的解。 1234567891011121314151617181920212223&gt;&gt;&gt; x=np.array([[1,2],[3,4]])&gt;&gt;&gt; y=np.linalg.inv(x)&gt;&gt;&gt; x array([[1, 2], [3, 4]])&gt;&gt;&gt; y array([[-2. , 1. ], [ 1.5, -0.5]])&gt;&gt;&gt; np.dot(x,y) array([[1.0000000e+00, 0.0000000e+00], [8.8817842e-16, 1.0000000e+00]]) a=np.array([[1,1,1],[0,2,5],[2,5,-1]]) print('数组a:') print(a) ainv=np.linalg.inv(a) print('a的逆矩阵') print(ainv) print('矩阵b:') b=np.array([[6],[-4],[27]]) print(b) print('计算：A^(-1)B:') x=np.linalg.solve(a,b) print(x) 数组分割 使用hsplit你能将数组沿着它的Y轴分割，或者指定返回相同形状数组的个数，或者指定在哪些列后发生分割。vsplit沿着X轴分割。12345678910111213141516171819202122232425262728293031323334&gt;&gt;&gt; a = floor(10*random.random((2,12)))&gt;&gt;&gt; a array([ [ 8., 8., 3., 9., 0., 4., 3., 0., 0., 6., 4., 4.], [ 0., 3., 2., 9., 6., 0., 4., 5., 7., 5., 1., 4.] ])&gt;&gt;&gt; hsplit(a,3) # Split a into 3 [array([ [ 8., 8., 3., 9.], [ 0., 3., 2., 9.] ]), array([ [ 0., 4., 3., 0.], [ 6., 0., 4., 5.] ]), array([ [ 0., 6., 4., 4.], [ 7., 5., 1., 4.]] )]&gt;&gt;&gt; hsplit(a,(3,4)) # Split a after the third and the fourth column [ array([ [ 8., 8., 3.], [ 0., 3., 2.] ]), array([ [ 9.], [ 9.] ]), array([ [ 0., 4., 3., 0., 0., 6., 4., 4.], [ 6., 0., 4., 5., 7., 5., 1., 4.] ]) ] 官方文档链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"https://pandamin18436220.github.io/tags/pandas/"}]},{"title":"算法与设计之基本概念","date":"2020-02-19T10:53:41.498Z","path":"2020/02/19/算法与设计/","text":"算法概述123456789101112131415161718算法定义的是计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。这样算法就是把输入转换成输出的计算步骤的一个序列。我们也可以把算法看成是用于求解良说明的计算问题的工具。一般来说，问题陈述说明了期望的输入/输出关系。算法则描述一个特定的计算过程来实现该输入/输出关系。若对每个输入实例算法都以正确的输出停机，则称该算法是正确的，并称正确的算法解决了给定的计算问题。不正确的算法对某些输入实例可能根本不停机，也可能以不正确的回答停机。与人们期望的相反，不正确的算法只要其错误率可控有时可能是有用的，但是通常我们只关心正确的算法。算法可以用自然语言说明，也可以说明成计算机程序，甚至说明成硬件设计。唯一的要求是这个说明必须精确描述所要遵循的计算过程。虽然算法可以解决各式各样的问题，但是算法所解决的问题有的两个共同的特征：存在许多候选解，但绝大多数候选解都没有解决手头的问题。寻找一个真正的解或一个最好的解可能是一个很大的挑战。存在实际应用。比如一家运输公司（如公路运输或铁路运输公司）对如何在公路或铁路网中找出最短路径，有着经济方面的利益，因为采用的路径越短，其人力和燃料的开销就越低；互联网上的一个路由结点为了快速地发送一条消息可能需要寻找通过网络的最短路径。希望从纽约开车去波士顿的人可能想从一个恰当的网站寻找开车方向，或者开车时她可能使用其GPS。假设计算机是无限快的并且计算机存储器是免费的，你还有什么理由来研究算法吗？即使只是因为你还想证明你的解法会终止并以正确的答案终止，那么回答也是肯定的。如果计算机无限快，那么用于求解某个问题的任何正确的方法都行。也许你希望你的实现在好的软件工程实践的范围内（例如，你的实现应该具有良好的设计与文档），但是你最常使用的是最容易实现的方法。当然，计算机也许是快的，但它们不是无限快。存储器也许是廉价的，但不是免费的。所以计算时间是一种有限资源，存储器中的空间也一样。你应该明智地使用这些资源，在时间或空间方面有效的算法将帮助你这样使用资源。为求解相同问题而设计的不同算法在效率方面常常具有显著的差别。这些差别可能比由于硬件和软件造成的差别要重要得多。上面的例子表明我们应该像计算机硬件一样把算法看成是一种技术。整个系统的性能不但依赖于选择快速的硬件而且还依赖于选择有效的算法。正如其他计算机技术正在快速推进一样，算法也在快速发展。你也许想知道相对其他先进的计算机技术（如：先进的计算机体系结构与制造技术、易于使用、直观的图形用户界面（GUI）、面向对象的系统、集成的万维网技术、有线与无线网络的快速组网等），算法对于当代计算机是否真的那么重要？回答是肯定的。虽然某些应用在应用层不明确需要算法内容（如某些简单的基于万维网的应用），但是许多应用确实需要算法内容。例如，考虑一种基于万维网的服务，它确定如何从一个位置旅行到另一个位置。其实现依赖于快速的硬件、一个图形用户界面、广域网，还可能依赖于面向对象技术。然而，对某些操作，如寻找路线（可能使用最短路径算法）、描绘地图、插入地址，它还是需要算法。而且，即使是那些在应用层不需要算法内容的应用也高度依赖于算法。该应用依赖于快速的硬件吗？硬件设计用到算法。该应用依赖于图形用户界面吗？任何图形用户界面的设计都依赖于算法。该应用依赖于网络吗？网络中的路由高度依赖于算法。该应用采用一种不同于机器代码的语言来书写吗？那么它被某个编译器、解释器或汇编器处理过，所有这些都广泛地使用算法。算法是当代计算机中使用的大多数技术的核心。进一步，随着计算机能力的不断增强，我们使用计算机来求解比以前更大的问题。正如我们在上面对插入排序与归并排序的比较中所看到的，正是在较大问题规模时，算法之间效率的差别才变得特别显著。是否具有算法知识与技术的坚实基础是区分真正熟练的程序员与初学者的一个特征。使用现代计算技术，如果你对算法懂得不多，你也可以完成一些任务，但是，如果有一个好的算法背景，那么你可以做的事情就多得多 分析算法（以插入排序作为引入) 相信大家都玩过纸牌。插入排序的工作方式就像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面朝下（意味着我们不在翻开之前并不知道下一张牌是多大的）。然后，我们每次从那些牌中选出一张牌，并把它插入到正确的位置（一般我们认为左边的最小），我们从左到右（或从右到左）将它与已在手中的每张牌进行比较。 动态演示！插入 算法分析 对于插入排序，我们将伪代码的过程命名为INSERTION-SORT其中 12345678910111213141516/*参数是A[1..N]，为长度n的一个需要排序的序列。A.length表示数组A中元素的数量该算法在数组A中重排这些数，在任何时候，最多只有其中的常数个数字存储在数组外面。等INSERTION-SORT结束时，输入数组A包含排序好的输出序列。*/INSERTION-SORT（A）1 for j=2 to A.length2 key = A[j]3 //Insert A[j] into the sorted sequence A[1..j-1]4 i = j - 15 while i &gt; 0 and A[i] &gt; key6 A[i+1] = A[i]7 i = i - 18 A[i+1]=key INSERTION-SORT（A） 代价 次数 for j=2 to A.length c1 n key = A[j] c2 n - 1 i = j - 1 c3 n - 1 while i &gt; 0 and A[i] &gt; key c4 $\\sum_{j=2}^n{t^j}$ A[i+1] = A[i] c5 $\\sum_{j=2}^n{(t^j-1)}$ i = i - 1 c6 $\\sum_{j=2}^n{(t^j-1)}$ A[i+1]=key c7 n - 1 该算法的运行时间是执行每条语句的运行时间之和。基于此，我们可以计算在具有n个值输入上INSERTION-SORT(A)的运行时间T[n]，我们将代价与次数列对应元素之积求和，得: T(n)=c1n+c2(n-1)+c3(n-1)+c4 $\\sum_{j=2}^n{t^j}$ +c5 $\\sum_{j=2}^n{(t^j-1)}$ +c6 $\\sum_{j=2}^n{(t^j-1)}$ +c7(n-1) 最好的情况下: =对于给定的n个需要排序的，若输入已排序，则出现最佳情况。这个时候，对于j=2,3，….,n，可以发现，当i取初值j-1时，有A[i]≤keyA[i]≤key。从而对j=2,3,…，n有tj=1,也就是说只需要比较一次。 假设现在你左手中的牌都是已经排好序了的，而且是从小到大排序，现在你手上拿了一张牌，比你左手上的牌最右边（即是你手中牌中最大）还要大，那么你一定要保证牌是从小到大的排序，必然会把牌之间放在你牌的最右边。而这个过程，你只是和你本来有的牌的最大一张比较了一次。 所以最好的情况下的时间复杂度Tn为: 123T(n)=c1n+c2(n−1)+c3(n−1)+c4(n−1)+c7(n−1)=(c1+c2+c3+c4+c7)n−(c1+c2+c3+c4)T(n)=c1n+c2(n−1)+c3(n−1)+c4(n−1)+c7(n−1)=(c1+c2+c3+c4+c7)n−(c1+c2+c3+c4)即 T(n)=an+b 其中a和b依赖于语句代价 ci 我们可以得出一个结论： 在最好情况下，插入排序的时间复杂度在O(n)，即线性时间上完成排序 最坏的情况下: 若输入数组已方向排序，即按照递减排序排好了序,则导致最坏情况。我们必须把每个元素A[j]与整个已排序子 数组A[1..j-1]中的每个元素都要进行比较，所以对j=2,3,…,n，有tj=j。我估计有人问为什么tj=j，那么我就 这样告诉你吧: tj是while语句进行比较语句的执行的次数，最后一次是进行i&gt;0的判断，所以A[1..j-1]与A[j]实际上进行j-1次比较，那么为什么进行j-1次比较呢，我们这么想，j代表我要加入第几张牌，我就以j=3来说，我即将加入第3张牌进入我左手的牌中（左手有两张牌，已经升序排列了好了），而这个牌比前面2个都要小，那么我是需要和比较两次才知道的，所以一共比较j-1次。 值得注意的是，这时候的是 $\\sum_{j=2}^n{j}$=n(n+1)/2-1 以及 $\\sum_{j=2}^n{(j-1)}$=n(n-1)/2 上述是求和递推公式，相关数学知识参考下期文章。 所以最坏的情况下的时间复杂度Tn为: T(n)=c1n+c2(n-1)+c3(n-1)+c4(n(n+1)/2-1)+c5(n(n-1)/2)+c6(n(n-1)/2)+c7(n-1) =(c4/2+c5/2+c6/2)n^2+(c1+c2+c3+c4/2-c5/2-c6/2+c7)n-(c2+c3+c4+c7) 即 T(n)=an^2+bn+c其中a,b和c依赖于语句代价ci我们可以得出一个结论： 在最坏的情况下，插入排序时间复杂性O(n^2),即n的二次函数上完成排序。平均情况和最坏情况差不多，复杂度也在O(n2) 渐进记号12 针对资源管理的角度https://blog.csdn.net/YuYunTan/article/details/52026857?utm_source=itdadao&amp;utm_medium=referral https://blog.csdn.net/hy592070616/article/details/92102395 https://wenku.baidu.com/view/390d9d5cb04e852458fb770bf78a6529657d3539.html https://blog.csdn.net/weixin_44961794/article/details/90106570","comments":true,"tags":[{"name":"算法与设计","slug":"算法与设计","permalink":"https://pandamin18436220.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}]},{"title":"数学建模前的准备","date":"2020-02-18T03:35:55.879Z","path":"2020/02/18/数学建模前的准备/","text":"什么是数学模型数学模型是对于现实世界的一个特定对象，一个特定目的，根据特有的内在规律，做出一些必要的假设，运用适当的教学工具得到一个对问题近似刻划的数学结构，以便于人们更深刻地认识所研究的对象。数学建模常用的方法 解析几何，代数方程，微积分，微分方程，差分方程，概率统计，层次分析，插值与拟合，综合评价，优化方法，数据处理与计算等。 另外了解排队论，对策论，决策论，模拟评判等方面的知识。 数学建模的必备数学知识 高等数学，微分方程，运筹学，线性代数，概率统计，数值计算等。 第一章操作系统的概述","comments":true,"tags":[{"name":"数学建模","slug":"数学建模","permalink":"https://pandamin18436220.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}]},{"title":"操作系统","date":"2020-02-18T01:17:17.335Z","path":"2020/02/18/操作系统/","text":"操作系统的概念 第一章操作系统的概述针对资源管理的角度 API接口是提供给操作系统级程序员，基本的操作命令是提供给用户。 所谓的脱机方式是在不在CPU的调度下工作；相应的联机方式是指在CPU的调度下使用的！ 这门课程主要是研究OS非功能性需求这一块 线程与进程的区别：线程是共享进程资源的，是由进程调度的最小单位，而进程是是系统拥有资源的最小实体！","comments":true,"tags":[{"name":"操作系统，网课笔记","slug":"操作系统，网课笔记","permalink":"https://pandamin18436220.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/"}]},{"title":"Anaconda下载命令","date":"2020-02-17T09:12:03.677Z","path":"2020/02/17/Anaconda下载命令/","text":"Anaconda介绍 Anaconda就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。 主要是提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令conda来进行package和environment的管理，并且已经包含了Python和相关的配套工具。 Anaconda的命令 conda list #查看已安装好的包 conda install +包名(如numpy) #安装相关包 anaconda search -t conda tensorflow #网络寻找tensorflow的版本 anaconda show +版本名 #查看安装此版本的tensorflow的命令 conda install –channel https://conda.anaconda.org/dhirschfeld tensorflow #复制执行此命令，进行安装操作","comments":true,"tags":[{"name":"机器学习，Anaconda","slug":"机器学习，Anaconda","permalink":"https://pandamin18436220.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%8CAnaconda/"}]},{"title":"jupyter闪退问题","date":"2020-02-17T08:53:22.667Z","path":"2020/02/17/jupyter闪退问题/","text":"问题描述本系统为 win10，安装 Anaconda3 后，可以正常使用 jupyter notebook ，后来因为安装插件，再启动Jupyter notebook 就出现闪退现象，后来发现，库的升级还有一些其他操作也会造成闪退现象，当然，可以重装Anaconda进行修复，可是通过查询和个人实践，验证以下三种方法可以重新启动 jupyter notebook： 问题解决第一种：命令行启动 启动Anaconda Prompt，输入命令jupyter notebook 即可进入 jupyter notebook；第二种：修改jupyter notbook快捷方式的目标内容 右键单击开始菜单中Anaconda下的 Jupyter notebook。 更多 - 打开文件位置，右键 Jupyter notebook 快捷方式，选择属性，修改目标内容为自己 Anaconda3 的安装目录下： .\\Anaconda3\\Scripts\\jupyter-notebook.exe之后应用。 关闭后，再点击开始菜单中 jupyter notebook 快捷方式便可启动。 说明：本人的Anaconda3安装在C:\\ProgramData\\下。 Anaconda3下jupyter notebook快捷方式的目标的原有内容如下： C:\\ProgramData\\Anaconda3\\python.exe C:\\ProgramData\\Anaconda3\\cwp.py C:\\ProgramData\\Anaconda3 C:\\ProgramData\\Anaconda3\\python.exe C:\\ProgramData\\Anaconda3\\Scripts\\jupyter-notebook-script.py &quot;%USERPROFILE%/&quot;为什么闪退呢是因为“jupyter-notebook-script.py”没有了。打开目录“C:\\ProgramData\\Anaconda3\\Scripts”，里面没有了“jupyter-notebook-script.py”，但有一项“jupyter-notebook.exe”，直接双击这一项也可启动jupyter notebook，所以把jupyter notebook快捷方式的目标改为该文件。第三种：修复jupyter-notebook-script.py文件。 刚才说过为什么会闪退，就是缺少了文件“jupyter-notebook-script.py”，那就重新生成一下。 启动Anaconda Prompt，输入命令：jupyter notebook --generate-config。 或者拷贝现成的文件到Anaconda3安装目录的Scripts下，我的安装目录“C:\\ProgramData\\Anaconda3\\Scripts”，即补充完整路径C:\\ProgramData\\Anaconda3\\Scripts\\jupyter-notebook-script.py。 附加说明：jupyter notebook --generate-config 命令是生成jupyter notebook的配置文件，修改配置文件还可以修改Anaconda中JupyterNotebook的默认工作路径具体修改配置文件方法 打开 Anaconda Prompt，输入jupyter notebook –generate-config 这个命令的作用是生成 Jupyter notebook 的配置文件。如果你是第一次运行，会直接生成这个文件。如果曾经运行过这个命令，就会像下图一样问你时候要覆盖原来的文件。这个时候不用理会。我们的主要目的只是为了找到这个文件的路径。 根据第一步找到 jupyter_notebook_config.py 的路径并打开此文件。找到 c.NotebookApp.notebook_dir 这个变量，将你希望的路径赋值给这个变量，并删除这一行前面的“#”。修改后如下： 一定要确保删除 “#”，取消这一行的注释模式。 这一行代码前不能有空格。 路径一定要是已经存在的，否则会闪退。且路径要用英文单引号括起来。 改完后保存。再次通过 Anaconda Navigator 进入 Jupyter Notebook 的时候会发现默认路径已经更改。 然而，如果你直接通过 Jupyter Notebook 的快捷方式进入，默认目录还是原来那个。如果需要修改，还需要进行如下步骤： 找到快捷方式，右键打开属性，将“目标”最后面的 “%USERPROFILE%” 删除就可以了。 遇到那些坑及推测的原因并不是说这些方法是错误的，只是大概不适合我自己的系统和环境而已。 网上说打开 “cmd”，运行 “jupyter notebook –generate-config” 命令 可能是因为 Jupyter Notebook 是通过 Anaconda 安装的，所以 Anaconda 环境外没有配置环境变量。 根据网上贴出的路径直接查找 “Jupyter_notebook_config.py” 文件，发现查无此文件。 再次提醒，如果从没运行过 generate 命令，是不会有这个配置文件的。 据说，修改 Anaconda 安装目录下 etc\\jupyter 文件夹中的 jupyter_notebook_config.json 文件也是可以的。但是，我的文件打开是空的。我也不知道为什么。 据说可以只改快捷方式的属性：“目标”那里的 “%USERPROFILE%” 删除，“起始位置”改成你希望的路径。 在不改 jupyter_notebook_config.py 文件的情况下，仅改变这两个地方，并不起任何作用。如果改了 jupyter_notebook_config.py，这两个地方都不改的话，从这个快捷方式进入 Jupyter Notebook 会进入默认路径，用 Anaconda Navigator 启动就会进入改变后的路径。对“目标”栏进行改动后，则从快捷方式进入，也会进入修改后的路径。“起始位置”那里的值，改不改都不影响。","comments":true,"tags":[{"name":"问题解决，机器学习","slug":"问题解决，机器学习","permalink":"https://pandamin18436220.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java学习","date":"2020-02-17T08:29:58.157Z","path":"2020/02/17/Java学习/","text":"大数据概念大数据（big data），指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。 大数据的特点 Volume（大量）：截至2017年，人类生产的所有印刷材料的数据量是200PB，而历史上全人类总共说过的话的数据量大约是5EB。当前，典型个人计算机硬盘的容量为TB量级，而一些大企业的数据量已经接近EB量级。 Velocity（高速）：这是大数据区分于传统数据挖掘的最显著特征。根据IDC的“数字宇宙”的报告，预计到2020年，全球数据使用量将达到35.2ZB。在如此海量的数据面前，处理数据的效率就是企业的生命。 Variety（多样）：这种类型的多样性也让数据被分为结构化数据和非结构化数据。相对于以往便于存储的以数据库/文本为主的结构化数据，非结构化数据越来越多，包括网络日志、音频、视频、图片、地理位置信息等，这些多类型的数据对数据的处理能力提出了更高要求。 Value（低价值密度）：价值密度的高低与数据总量的大小成反比。比如，在一天监控视频中，我们只关心晚上在床上健身那一分钟，如何快速对有价值数据“提纯”成为目前大数据背景下待解决的难题。 大数据的应用 O2O：百度大数据+平台通过先进的线上线下打通技术和客流分析能力，助力商家精细化运营，提升销量。 *零售：探索用户价值，提供个性化服务解决方案；贯穿网络与实体零售，携手创造极致体验。经典案例，子尿布+啤酒。 旅游：深度结合百度独有大数据能力与旅游行业需求，共建旅游产业智慧管理、智慧服务和智慧营销的未来。 商品广告推荐：给用户推荐访问过的商品广告类型 房产：大数据全面助力房地产行业，打造精准投策与营销，选出更合适的地，建造更合适的楼，卖给更合适的人。 保险：海量数据挖掘及风险预测，助力保险行业精准营销，提升精细化定价能力。 金融：多维度体现用户特征，帮助金融机构推荐优质客户，防范欺诈风险。 移动联通：移动联通：根据用户年龄、职业、消费情况，分析统计哪种套餐适合哪类人群。对市场人群精准定制。 人工智能 课后答案","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"https://pandamin18436220.github.io/tags/Java/"}]},{"title":"数据分析与机器学习","date":"2020-02-17T08:27:11.368Z","path":"2020/02/17/数据分析与机器学习/","text":"numpy知识点 读取文件的函数：numpy.getfromtxt(“文件路径”,delimiter=”,”,dtpye=str,skip_header=1) 返回是一个矩阵 可以通过print(help(函数名)),获取函数的API介绍 索引的几种方法 12345678910vector=numpy.array([ [ 0, 1, 2], [ 3, 4, 5], [10, 11, 12] ])#vector[行,列]print(vector[0,3]) #取第一行第三列的元素print(vector[0,0:3]) #取第一行第三列的前两个元素print(vector[:,1]) #取第一列的所有元素 bool值做索引下标 123vector==10 #会返回对应位置为bool值的arrayvector[vector==10] #会返回对应位置等于10的值:[10]vector[vector==10;] #会返回对应位置等于10的这一行 array的类型转化 123print(vector.dtype) #int32vector=vector.astype(float)print(vector.dtype) #float64 array的函数 相关函数可以通过print(help(numpy.array))去查看API 123456789101112131415161718192021222324vector.min() #求最小最vector.sum(axis=1) #求每一行的和vector.sum(axis=0) #求每一列的和vector.argmax(axis=0) #求每一列的最大值 返回索引值print(np.arange(15))#[0,1,...,14]向量形式#转化成矩阵形式vector=np.arange(15).reshape(3,5)#转化成三行五列的形式#矩阵转回向量vector.ravel()#通过shape查看形式print(vector.shape())#通过vector.ndim查看维度#通过vector.size()查看共有多少个元素#通过vector.dtype.name查看元素类型名:'innt32'#初始化矩阵np.zero((3,4),dtype=np.int32)np.ones((3,4),dtype=np.int32)np.array(5,11,5) #[5,10]np.random.random((2,3)) #np.random是一个模块，然后在通过点random函数np.linspace(0,6,100) #从0~6平均取100个数字 求解np的幂和根号 1234#计算幂np.exp(B)#计算根号np.sqrt(B) 拼接操作 123456a=np.floor(10*np.random.random((2,2)))b=np.floor(10*np.random.random((2,2)))#横着拼接np.hstack((a,b))#纵着拼接np.vstack((a,b)) 分割操作 12345#横着拼接1. np.hsplit((a,3))#将a横着切三份2. np.hsplit((a,(m,n)))#将a在光标3和4的地方切#纵着拼接np.vstack((a,3)) 复制操作 123456#浅复制a=np.arrange(12)b=a #a与b指向的位置一样也是一套数值c=a.view() #a与c指向的位置不一样但是是一套数值#深复制d=a.copy() #a与d指向的位置不一样,数值也不一样 排序和索引 123456789101112131415a=np.array( [ [4,3,5], [1,2,6] ])b=np.sort(a,axis=1)#按行排序c=np.array([4,3,1,2])d=np.argsort(c)#得到排序后的索引：[2,3,1,0]e=d[d] #得到排好序的数组：[1,2,3,4]data=np.sin(np.arrange((20)).reshape(5,4))ind=data.argmax(axis=0) #查找每一列的最大值并返回索引行data_max=data[ind,range(data.shape[1])] #根据索引行和shape[1]列去索引data数值 数值扩展1np.tile(a,(m,n))#将a的行扩展m倍，a的列扩展n倍","comments":true,"tags":[{"name":"机器学习，数据分析","slug":"机器学习，数据分析","permalink":"https://pandamin18436220.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]},{"title":"大数据概论","date":"2020-02-17T07:47:49.724Z","path":"2020/02/17/大数据概论/","text":"大数据概念大数据（big data），指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。 大数据的特点 Volume（大量）：截至2017年，人类生产的所有印刷材料的数据量是200PB，而历史上全人类总共说过的话的数据量大约是5EB。当前，典型个人计算机硬盘的容量为TB量级，而一些大企业的数据量已经接近EB量级。 Velocity（高速）：这是大数据区分于传统数据挖掘的最显著特征。根据IDC的“数字宇宙”的报告，预计到2020年，全球数据使用量将达到35.2ZB。在如此海量的数据面前，处理数据的效率就是企业的生命。 Variety（多样）：这种类型的多样性也让数据被分为结构化数据和非结构化数据。相对于以往便于存储的以数据库/文本为主的结构化数据，非结构化数据越来越多，包括网络日志、音频、视频、图片、地理位置信息等，这些多类型的数据对数据的处理能力提出了更高要求。 Value（低价值密度）：价值密度的高低与数据总量的大小成反比。比如，在一天监控视频中，我们只关心晚上在床上健身那一分钟，如何快速对有价值数据“提纯”成为目前大数据背景下待解决的难题。 大数据的应用 O2O：百度大数据+平台通过先进的线上线下打通技术和客流分析能力，助力商家精细化运营，提升销量。 零售：探索用户价值，提供个性化服务解决方案；贯穿网络与实体零售，携手创造极致体验。经典案例，子尿布+啤酒。 旅游：深度结合百度独有大数据能力与旅游行业需求，共建旅游产业智慧管理、智慧服务和智慧营销的未来。 商品广告推荐：给用户推荐访问过的商品广告类型 房产：大数据全面助力房地产行业，打造精准投策与营销，选出更合适的地，建造更合适的楼，卖给更合适的人。 保险：海量数据挖掘及风险预测，助力保险行业精准营销，提升精细化定价能力。 金融：多维度体现用户特征，帮助金融机构推荐优质客户，防范欺诈风险。 移动联通：移动联通：根据用户年龄、职业、消费情况，分析统计哪种套餐适合哪类人群。对市场人群精准定制。 人工智能 云计算的概念 为什么会需要“云”传统的应用正在变得越来越复杂：需要支持更多的用户，需要更强的计算能力，需要更加稳定安全等等，而为了支撑这些不断增长的需求，企业不得不去购买各类硬件设备（服务器，存储，带宽等等）和软件（数据库，中间件等等），另外还需要组建一个完整的运维团队来支持这些设备或软件的正常运作，这些维护工作就包括安装、配置、测试、运行、升级以及保证系统的安全等。便会发现支持这些应用的开销变得非常巨大，而且它们的费用会随着你应用的数量或规模的增加而不断提高。这也是为什么即使是在那些拥有很出色IT部门的大企业中，那些用户仍在不断抱怨他们所使用的系统难以满足他们的需求。而对于那些中小规模的企业，甚至个人创业者来说，创造软件产品的运维成本就更加难以承受了。 简而言之：云计算的资源是动态扩展且虚拟化的，通过互联网提供，终端用户不需要了解云中基础设施的细节，不必具有专业的云技术知识，也无须直接进行控制，只要关注自身真正需要什么样的资源以及如何通过网络来获得相应的服务即可。云计算，应运而生——更大、更快、更强 针对上述问题解决方案便是“云计算”！将应用部署到云端后，可以不必再关注那些令人头疼的硬件和软件问题，它们会由云服务提供商的专业团队去解决。使用的是共享的硬件，这意味着像使用一个工具一样去利用云服务（就像插上插座，你就能使用电一样简单）。只需要按照你的需要来支付相应的费用，而关于软件的更新，资源的按需扩展都能自动完成。 云计算的五点特点 大规模、分布式“云”一般具有相当的规模，一些知名的云供应商如Google云计算、Amazon、IBM、微软、阿里等也都拥能拥有上百万级的服务器规模。而依靠这些分布式的服务器所构建起来的“云”能够为使用者提供前所未有的计算能力。虚拟化云计算都会采用虚拟化技术，用户并不需要关注具体的硬件实体，只需要选择一家云服务提供商，注册一个账号，登陆到它们的云控制台，去购买和配置你需要的服务（比如 云服务器，云存储，CDN等等），再为你的应用做一些简单的配置之后，你就可以让你的应用对外服务了，这比传统的在企业的数据中心去部署一套应用要简单方便得多。而且你可以随时随地通过你的PC或移动设备来控制你的资源，这就好像是云服务商为每一个用户都提供了一个IDC(Internet Data Center)一样。高可用性和扩展性那些知名的云计算供应商一般都会采用数据多副本容错、计算节点同构可互换等措施来保障服务的高可靠性。基于云服务的应用可以持续对外提供服务（7*24小时），另外“云”的规模可以动态伸缩，来满足应用和用户规模增长的需要。按需服务，更加经济用户可以根据自己的需要来购买服务，甚至可以按使用量来进行精确计费。这能大大节省IT成本，而资源的整体利用率也将得到明显的改善。安全网络安全已经成为所有企业或个人创业者必须面对的问题，企业的IT团队或个人很难应对那些来自网络的恶意攻击，而使用云服务则可以借助更专业的安全团队来有效降低安全风险。 云计算可以分为IaaS、PaaS、SaaS、[DaaS四个]层次。(按照服务划分) IaaS: Infrastructure-as-a-Service(基础设施即服务)有了IaaS，你可以将硬件外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。一些大的IaaS公司包括Amazon, Microsoft, VMWare, Rackspace和Red Hat.不过这些公司又都有自己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。 PaaS: Platform-as-a-Service(平台即服务)第二层就是所谓的PaaS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资源。PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。一些大的PaaS提供者有Google App Engine,Microsoft Azure，Force.com,Heroku，Engine Yard。最近兴起的公司有AppFog,Mendix和Standing Cloud. SaaS: Software-as-a-Service(软件即服务)第三层也就是所谓SaaS。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器上的应用都可以通过网络来运行，就是SaaS了。你消费的服务完全是从网页如Netflix,MOG,Google Apps,Box.net,Dropbox或者苹果的iCloud那里进入这些分类。尽管这些网页服务是用作商务和娱乐或者两者都有，但这也算是云技术的一部分。 另外，越来越多的数据沉淀、抽象形成了新的服务——DaaS（Data as a Service，数据即服务）。 下面画一个图来对比一下：| 相关项目 | 云服务 || :—- | —-: || | DASS | SAAS | PAAS | IAAS || 服务对象 | 开发者和企业 | 企业 | 开发者 | 开发者和企业用户 || 成熟度 |发展较晚，成熟度较低|发展早，成熟度相对最高|起步较晚，成熟度低|在应用层成熟后兴起，成熟度较高||核心能力|实现数据共享|帮助企业优化业务流程|帮助开发者的产品快速活动某种功能|帮助企业/开发者快速拥有存储，计算等资源||发展现状|潜力最大，融资集中在早期|企业级市场活跃，融资集中在C轮及以上|潜力较大，但是市场总体量较小|竞争激烈，垂直领域亦有发展空间||主要玩家|互联网公司|互联网公司,传统软件公司及创业企业|互联网公司，创业企业|电信运营商，IT厂商，互联网公司，创业企业| Hadoop的概念 Hadoop是一个由Apache基金会所开发的分布式系统基础架构 主要解决，海量数据的存储和海量数据的分析计算问题。 广义上来说，hadoop通常是指一个更广泛的概念——hadoop生态圈 Hadoop组成 MapReduce 计算 Yarn 资源调度 HDFS 数据存储 Common 辅助工具 大数据技术生态系统 技术名词解释 Sqoop：sqoop是一款开源的工具，主要用于在Hadoop(Hive)与传统的数据库(mysql)间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL ,Oracle 等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。 Flume：Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。 Kafka：Kafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性： （1）通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。 （2）高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息 （3）支持通过Kafka服务器和消费机集群来分区消息。 （4）支持Hadoop并行数据加载。 Storm：Storm为分布式实时计算提供了一组通用原语，可被用于“流处理”之中，实时处理消息并更新数据库。这是管理队列及工作者集群的另一种方式。 Storm也可被用于“连续计算”（continuous computation），对数据流做连续查询，在计算时就将结果以流的形式输出给用户。 Spark：Spark是当前最流行的开源大数据内存计算框架。可以基于Hadoop上存储的大数据进行计算。 Oozie：Oozie是一个管理Hdoop作业（job）的工作流程调度管理系统。Oozie协调作业就是通过时间（频率）和有效数据触发当前的Oozie工作流程。 Hbase：HBase是一个分布式的、面向列的开源数据库。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。 Hive：hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。 R语言：R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。 Mahout:Apache Mahout是个可扩展的机器学习和数据挖掘库，当前Mahout支持主要的4个用例：推荐挖掘：搜集用户动作并以此给用户推荐可能喜欢的事物。聚集：收集文件并进行相关文件分组。分类：从现有的分类文档中学习，寻找文档中的相似特征，并为无标签的文档进行正确的归类。频繁项集挖掘：将一组项分组，并识别哪些个别项会经常一起出现。 ZooKeeper：Zookeeper是Google的Chubby一个开源的实现。它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、 分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 扩展我们在这里就不再展开了，我们不妨关注其他一些更有趣的话题。分布式系统阿里云介绍 课后答案","comments":true,"tags":[{"name":"大数据概论，网课笔记","slug":"大数据概论，网课笔记","permalink":"https://pandamin18436220.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A6%82%E8%AE%BA%EF%BC%8C%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/"}]},{"title":"Nao检测Mark","date":"2020-02-09T12:44:42.507Z","path":"2020/02/09/nao之检测Mark/","text":"在此先附上一串简单的代码此代码适于用于Nao机器人的Mark检测 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding:utf-8 -*-from naoqi import ALProxyimport mathimport almathdef main(robotIP,PORT): motion=ALProxy(\"ALMotion\",robotIP,PORT) posture=ALProxy(\"ALRobotPosture\",robotIP,PORT) tts=ALProxy(\"ALTextToSpeech\",robotIP,PORT) markProxy= ALProxy(\"ALLandMarkDetection\",robotIP,PORT) #ALTracker模块允许机器人使用不同的方式（仅头部，全身，移动等）跟踪不同的目标（红球，面部，地标等）。 #该模块的主要目的是在目标检测与运动之间建立桥梁，以使机器人在摄像机中间始终观察目标。 tracker=ALProxy(\"ALTracker\",robotIP,PORT) useSensors=False period = 500 #H=0.459 #L=0.405 #theta=39.7*almath.TO_RAD #启动naomark检测功能 markProxy.subscribe(\"Test_Mark\",period,0.0) memProxy=ALProxy(\"ALMemory\",robotIP,PORT) motion.wakeUp() posture.goToPosture(\"StandInit\",0.5) for i in range(0,20): motion.moveTo(-0.05,0.0,0.0,config) data=memProxy.getData(\"LandmarkDetected\",) if data:#data为空则没有识别到 tts.say(\"检测到mark\") sensorAngles= motion.getAngles(\"HeadPitch\",useSensors)#获得头部角度数据 #sen=(math.degrees(sensorAngles[0])) #S=((H-L)/2)/math.tan(sen+theta) #print(data[1][1][0]) print(sensorAngles[0]) #print(S) #print(tracker.getTargetCoordinates()) #tts.say(\"距离为:%d\"%(S)) exit(0) else: tts.say(\"没检测到mark\")if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument(\"--ip\", type=str, default=\"127.0.0.1\", help=\"Robot IP address. On robot or Local Naoqi: use '127.0.0.1'.\") parser.add_argument(\"--port\", type=int, default=9559, help=\"Naoqi port number\") args = parser.parse_args() #步态参数 config=[ [\"MaxStepX\",0.045], [\"MaxStepY\",0.145], [\"MaxStepFrequency\",0.4], [\"TorsoWx\",5.0*almath.TO_RAD] ] robotIP=args.ip PORT=args.port","comments":true,"tags":[{"name":"Nao","slug":"Nao","permalink":"https://pandamin18436220.github.io/tags/Nao/"},{"name":"Naoqi","slug":"Naoqi","permalink":"https://pandamin18436220.github.io/tags/Naoqi/"}]},{"title":"Nao传感器","date":"2020-02-09T11:58:17.631Z","path":"2020/02/09/nao之传感器/","text":"在此先附上一串简单的代码此代码适于用于做对Nao机器人头顶三个传感器做相关的实验参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# -*- coding:utf-8 -*-from naoqi import ALProxyimport almathimport argparseimport threadingfrom naoqi import ALModuledef main(robotIP,PORT): n=1 motion=ALProxy(\"ALMotion\",robotIP,PORT) posture=ALProxy(\"ALRobotPosture\",robotIP,PORT) tts=ALProxy(\"ALTextToSpeech\",robotIP,PORT) memory=ALProxy(\"ALMemory\",robotIP,PORT) def run():#行走 motion.wakeUp() posture.goToPosture(\"StandInit\",0.5) motion.moveTo(1.0 ,0,0,config) #threadLock.acquire() #threadLock.release() #threadLock = threading.Lock() def onTouched():#触摸传感器 #防止一次触摸未识别，进行死循环，触摸成功才可退出循环 while n==1: fronthead = memory.getData('FrontTactilTouched') #如果触摸成功，则fronthead=1 if fronthead == 1: motion.rest() break #创建 thread1=threading.Thread(target=run) thread2=threading.Thread(target=onTouched) #开始进行多线程 thread1.start() thread2.start() #结束 thread1.join() thread2.join()if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument(\"--ip\", type=str, default=\"127.0.0.1\", help=\"Robot IP address. On robot or Local Naoqi: use '127.0.0.1'.\") parser.add_argument(\"--port\", type=int, default=9559, help=\"Naoqi port number\") args = parser.parse_args() #步态参数 config=[ [\"MaxStepX\",0.045], [\"MaxStepY\",0.145], [\"MaxStepFrequency\",0.4], [\"TorsoWx\",5.0*almath.TO_RAD] ] robotIP=args.ip PORT=args.port","comments":true,"tags":[{"name":"Nao","slug":"Nao","permalink":"https://pandamin18436220.github.io/tags/Nao/"},{"name":"Naoqi","slug":"Naoqi","permalink":"https://pandamin18436220.github.io/tags/Naoqi/"}]},{"title":"Nao单目测距","date":"2020-02-09T07:44:59.072Z","path":"2020/02/09/nao之单目测距/","text":"在此先附上一串简单的机器人测距代码此代码适于用做对Nao机器人做视觉识别和测距实验,只提供关键代码部分,尝试利用cv2去优化代码会更加简洁哟！ 此代码的主要功能:1.初始姿态下，通过更换摄像头和转头去寻找目标2.通过颜色阈值识别目标，计算目标与Nao的距离和角度可以扩展功能：1.在运动过程中对方向和距离进行多次测量和校正，提高准确度2.找到目标后，通过对目标的测量，选择使用哪个脚去踢目标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#!/usr/bin/python2.7#-*- encoding: UTF-8 -*-import vision_definitions#----------------------单目测距--------------------------------#***********************************************#@函数名： DistAndDirect_cal(cxnum,rynum,colsum,rowsum,Head_angle,cameraID)#@参数： (cxnum,rynum)是通过图像识别得到球心的像素点坐标# (colsum,rowsum)是图片总大小：640*480# cameraID=0，取上摄像头；cameraID=1，取下摄像头#@返回值： 无#@功能说明： 采用机器人的下摄像头进行测量球离机器人的相关角度与距离def DistAndDirect_cal(cxnum,rynum,colsum,rowsum,Head_angle,cameraID): distx=-(cxnum-colsum/2) disty=rynum-rowsu/2 print distx,disty Picture_angle=disty*47.64/480 if cameraID ==0: h=0.62 Camera_angle=12 else: h=0.57 Camera_angle=38 #Head_angle[0]机器人仰俯角度 Total_angle=math.pi*(Picture_angle+Camera_angle)/180+Head_angle[0] d1=h/math.tan(Total_angle) alpha=math.pi*(distx*60.92/640)/180 d2=d1/math.cos(alpha) #Head_angle[1]机器人左右角度 Forward_Distance=d2*math.cos(alpha+Head_angle[1]) Sideward_Distance=-d2*math.sin(alpha+Head_angle[1])#***********************************************#@函数名： GetNaoImage(IP,PORT,cameraID)#@参数： 略#@返回值： 无#@功能说明： 采调用机器人内置摄像头控制模块，对当前场景进行拍摄并保持。# 由于球距离机器人约小于0.6m时，机器人额头摄像头无法看到，# 所以需要变换摄像头，cameraID=0，取上摄像头；# cameraID=1，取下摄像头def Get NaoImage(IP,PORT,cameraID): camProxy=ALProxy(\"ALVideoDevice\",IP,PORT) resolition=2 #VGA格式640*480 colorSpace=11#RGB #选择并启用摄像头 camProxy.setParam(vision_definitions.kCameraSelectID,cameraID) videoClient=camProxy.subscribe(\"python_client\",resolition,colorSpace,5) #获取摄像机图像。 #image [6]包含以ASCII字符数组形式传递的图像数据。 naoImage=camProxy.getImageRemote(videoClient) camProxy.unsubscribe(videoClient) #获取图像大小和像素阵列。 imageWidth=naoImage[0] imageHeight=naoImage[1] array=naoImage[6] #从我们的像素阵列创建一个PIL图像。 im=Image.fromstring(\"RGB\",(imageWidth,imageHeight),array) #保存图像。 im.save(\"temp.jpg\",\"JPEG\")#***********************************************#@函数名： findColorPattern(img,pattern)#@参数： 略#@返回值： 无#@功能说明： 将RGB图像转化为二值图：此方法用的是cv,可以尝试用cv2代码会更加简洁def findColorPattern(img,pattern): channels=[None,None,None] channels[0]=cv.CreateImage(cv.GetSize(img),8,1) channels[1]=cv.CreateImage(cv.GetSize(img),8,1) channels[2]=cv.CreateImage(cv.GetSize(img),8,1) ch0=cv.CreateImage(cv.GetSize(img),8,1) ch1=cv.CreateImage(cv.GetSize(img),8,1) ch2=cv.CreateImage(cv.GetSize(img),8,1) cv.Split(img,ch0,ch1,ch2,None) dest=[None,None,None,None] dest[0]=cv.CreateImage(cv.GetSize(img),8,1) dest[1]=cv.CreateImage(cv.GetSize(img),8,1) dest[2]=cv.CreateImage(cv.GetSize(img),8,1) dest[3]=cv.CreateImage(cv.GetSize(img),8,1) cv.Smooth(ch0,channels[0],cv.CV_GAUSSIAN,3,3,0) cv.Smooth(ch1,channels[1],cv.CV_GAUSSIAN,3,3,0) cv.Smooth(ch2,channels[2],cv.CV_GAUSSIAN,3,3,0) for i in range(3): k=2-i lower=pattern[k]-75#设置阈值 upper=pattern[k]+75 cv.InRangeS(channels[i],lower,upper,dest[i]) cv.And(dest[0],dest[1],dest[3]) temp=cv.CreateImage(cv.GetSize(img),8,1) cv.And(dest[2],dest[3],temp) ''' cv.NameWindow(\"result\",cv.CV_WINDOW_AUTOSIZE) cv.ShowImage(\"result\",temp) cv.WaitKey(0) ''' return temp#***********************************************#@函数名： xyProject(matrix,imgaesize)#@参数： matrix# imgaesize#@返回值： 无#@功能说明： 利用二值图，计算球的像素坐标。其原理是：遍历各行各列# 像素的数值的和，最大的组合即为球心坐标def xyProject(matrix,imagesize): #声明一个数据类型为8位型单通道的imagessize[1]*1/1*imagessize[0]矩阵(初始值为 0)。 colmask=cv.CreateMat(imagessize[1],1,cv.CV_8UC1) rowmask=cv.CreateMat(1,imagessize[0],cv.CV_8UC1) cv.Set(colmask,1) cv.Set(rowmask,1) colsum=[] for i in range(imagesize[0]): col=cv.GetCol(matrix,i) #计算向量点积 a=cv.DotProduct(colmask,col) colsum.append(a) rowsum=[] for i in range(imagesize[1]): row=cv.GetRow(matrix,i) a=cv.DotProduct(rowmask,row) rowsum.append(a) return(colsum,rowsum)#得到各行各列“1”值的和def crMax(colsum,rowsum): cx=max(colsum) ry=max(rowsum) for i in range(len(colsum)): if colsum[i]==cx: cxnum=i for i in range(len(rowsum)): if rowsum[i]==ry: rynum=i return(cxnum,rynum)#***********************************************#@函数名： GetHeadAngles(robotIP,PORT)#@参数： 略#@返回值： 无#@功能说明：def GetHeadAngles(robotIP,PORT): motionProxy=ALProxy(\"ALMotion\",robotIP,PORT) names=[\"HeadPitch\",\"HeadYaw\"] useSensors=1 sensorAngles=motionProxy.getAngles(names,useSensors) return sensorAngles#***********************************************#@函数名： SetHeadAngles(robotIP,PORT,angles)#@参数： 略#@返回值： 无#@功能说明：def SetHeadAngles(robotIP,PORT,angles): motionProxy=ALProxy(\"ALMotion\",robotIP,PORT) motionProxy.setStiffnesses(\"Head\",1.0) names=[\"HeadPitch\",\"HeadYaw\"] fractionMaxSpeed=0.2 motionProxy.setAngles(names,angles,fractionMaxSpeed) time.sleep(2.0) motionProxy.setStiffnesses(\"Head\",0.0)#***********************************************#@函数名： Capture_Picture(IP,PORT,cameraID,angles,pattern_colors)#@参数： angles# pattern_colors#@返回值： 无#@功能说明： 将上面的一系列函数整合起来def Capture_Picture(IP,PORT,cameraID,angles,pattern_colors): SetHeadAngles(IP,PORT,angles) GetNaoImage(IP,PORT,cameraID) image=cv.LoadImage(\"temp.jpg\") imagesize=cv.GetSize(image) #返回数值，两个元素分别为列数和行数 matrix=findColorPattern(image,pattern_colors) (colsum,rowsum)=xyProject(matrix,imagesize) (cxnum,rynum)=crMax(colsum,rowsum) cv.SaveImage(\"result.jpg\",matrix) return (cxnum,rynum,colsum,rowsum)#***********************************************#@函数名： Target_Detect_and_Distance(IP,PORT)#@参数：#@返回值： 无#@功能说明： 当上摄像头无法找到球时，切换到下摄像头，然后在左转右转。# 在这个过程中，如果发现目标，则计算距离并输出距离# 若始终未找到目标，则输出距离为0。def Target_Detect_and_Distance(IP,PORT): pattern_colors=(255,150,50) cameraID=0# 默认上摄像头 angles=[0,0] (cxnum,rynum,colsum,rowsum)=Capture_Picture(IP,PORT,cameraID,angles) if(cxnum,rynum)==(639,479): cameraID=1 (cxnum,rynum,colsum,rowsum)=Capture_Picture(IP,PORT,cameraID,angles) if(cxnum,rynum)==(639,479): cameraID=0 angles=[0.0.7] (cxnum,rynum,colsum,rowsum)=Capture_Picture(IP,PORT,cameraID,angles) if(cxnum,rynum)==(639,479): cameraID=0 angles=[0,-0.7] (cxnum,rynum,colsum,rowsum)=Capture_Picture(IP,PORT,cameraID,angles) HeadAngles-GetHeadAngles(IP,PORT) ############### (Forward_Distance,Sideward_Distance)=DistAndDirect_cal(cxnum,rynum,colsum,rowsum,Head_angle,cameraID) if(cxnum,rynum)==(639,479): (Forward_Distance,Sideward_Distance)=(0,0) print \"Forward_Distance=\",Forward_Distance,\"meters\" print \"Sideward_Distance=\"+Sideward_Distance+\"meters\"#***********************************************#@函数名： Target_Detect_and_Distance(IP,PORT)#@参数：#@返回值： 无#@功能说明： 当找到球后，可能会存在一定的误差。# 因此需要判断球位于机器人前方的哪一侧，再来确定用哪只脚踢球def Final_See(robotIP,PORT): pattern_colors=(255,150,50) angles=[0.5,0] SetHeadAngles(robotIP,PORT,angles) cameraID=1 GetNaoImage(robotIP,PORT,cameraID) image=cv.LoadImage(\"temp.jpg\") imagesize=cv.GetNaoImage(image) matrix=findColorPattern(image,pattern_colors) (colsum,rowsum)=xyProject(matrix,imgaesize) (cxnum,rynum)=crMax(colsum,rowsum) cv.SaveImage(\"result.jpg\",matrix) HeadAngles=GetHeadAngles(robotIP,PORT) ######################### (Forward_Distance,Sideward_Distance)=DistAndDirect_cal(cxnum,rynum,colsum,rowsum,Head_angle,cameraID) if cxnum&lt;len(colsum)/2: side=0#左脚 else: side=1#右脚 print \"side=\",side print \"last distance=\",Forward_Distance return (side,Forward_Distance)","comments":true,"tags":[{"name":"Nao","slug":"Nao","permalink":"https://pandamin18436220.github.io/tags/Nao/"},{"name":"Naoqi","slug":"Naoqi","permalink":"https://pandamin18436220.github.io/tags/Naoqi/"}]},{"title":"Naoqi库","date":"2020-02-09T07:00:00.660Z","path":"2020/02/09/naoqi库/","text":"Naoqi的作用通过调用naoqi可以调用Nao等机器人的内置的相关端口。需要重点了解的相关模块：| 模块 | 作用 || :—-: | :—-: ||ALMotionProxy|||ALRobotPostureProxy|||ALVideoDeviceProxy|||ALMemoryProxy||||ALLandMarkDetection|||ALTrackerProxy|||ALRedBallDetection|||ALFaceDetection|| Naoqi函数 作用 ALMotionProxy::wakeUp（） 如果调用成功，则返回值为True，否则返回值为False。机器人唤醒：开启电机，并在需要时转到初始位置。如果机器人已经变硬，则调用会立即返回True。 ALMotionProxy::rest（） 机器人休息：转到放松且安全的位置并关闭电机。 ALMotionProxy::moveTo () 参数：x –沿X轴的距离，以米为单位。y –沿Y轴的距离，以米为单位。theta –绕Z轴旋转的弧度[-3.1415至3.1415]。moveConfig -步态参数返回值：如果moveTo成功终止，则为True；如果被中断，则为False。 ALRobotPostureProxy::goToPosture 使机器人转到参数中要求的预定义姿势,可以修改移动速度。参数:poseName-要达到的预定义姿势的名称。速度 -在0.0和1.0之间的相对速度。返回值：返回是否达到预定义的姿势 ALVideoDeviceProxy::unsubscribe 从ALVideoDevice取消注册该模块。 ALVideoDeviceProxy::subscribeCameras 订阅ALVideoDevice。当视频模块注册到ALVideoDevice时，所请求图像格式的缓冲区将添加到缓冲区列表中。返回可从ALVideoDevice获知VM的名称（当多个VM尝试使用相同的名称进行预订时，此名称很有用，例如，第三个将_3添加到其名称中）。参数:vmName –订阅虚拟机的名称。分辨率 –请求的分辨率。{0 = kQQVGA，1 = kQVGA，2 = kVGA，3 = k4VGA},colorSpace –请求的色彩空间。{0 = kYuv，9 = kYUV422、10 = kYUV，11 = kRGB，12 = kHSY，13 = kBGR},fps –向视频源请求的Fps（每秒帧数）。OV7670 VGA摄像机只能以30fps的速度运行，而MT9M114 HD摄像机在不久的将来将可以在某些特殊模式下更快地运行。与本地模块相比，远程模块的帧速率将取决于网络的可用带宽（例如，使用高清摄像机的千兆以太网连接，我们可以达到原始1280x960 @ 10fps）。返回值：从ALVideoDevice可以知道VM的名称，如果失败，则为NULL。 ALVideoDeviceProxy :: setParam 设置视频源的特定参数的值。 ALMemoryProxy :: getData 获取存储在内存中的键值对的值参数：键 –值的名称。返回值：数据为AL :: ALValue。通常可以将其透明地转换为原始类型。 ALLandMarkDetection :: subscribe 激活识别地标为”Naomarks”功能,可以使用ALMemory.getData（“ keyName”）在内存中访问它们。在许多情况下，可以通过仅调用提供回调方法的ALMemory.subscribeToEvent（）来避免在提取程序上调用订阅。这将自动为您订阅提取器。参数：名称 -这订阅模块的名称。period –刷新周期（以毫秒为单位）（如果相关）。精度 –提取器的精度（如果相关）。 ALTrackerProxy::getTargetCoordinates 仅适用于LandMarks目标名称。获取使用设置的对象坐标 ALMotionProxy::setMoveArmsEnabled 参数：leftArmEnable-如果为真，则由“移动任务”控制左臂运动。rightArmEnable –如果真实的右臂动作是由“移动任务”控制的 ALMotionProxy::angleInterpolation 将一个或多个关节插入到目标角度或沿定时轨迹进行插值。参数：名称 –关节，链条，“车身”，“ JointActuators”，“ Joints”或“ Actuators”的名称或名称。angleLists –以弧度表示的角度，角度列表或角度列表timeLists –时间，时间列表或时间列表（以秒为单位）isAbsolute –如果为true，则以绝对角度描述运动，否则角度相对于当前角度。 ALMotionProxy::stiffnessInterpolation 将一个或多个关节插入到目标刚度或沿着刚度的定时轨迹进行插值。参数：名称 –关节，链条，“车身”，“ JointActuators”，“Joints”或“ Actuators”的名称或名称。刚度列表–刚度，刚度列表或刚度列表timeLists –时间，时间列表或时间列表。 ALMotionProxy::angleInterpolationWithSpeed 使用最大速度的一部分将一个或多个关节插入到目标角度。每个关节仅允许一个目标角度。参数：名称 –关节，链条，“车身”，“ JointActuators”，“ Joints”或“ Actuators”的名称或名称。targetAngles –角度或以弧度表示的角度列表。maxSpeedFraction –分数。 官方文档链接1 官方文档链接2","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"Naoqi","slug":"Naoqi","permalink":"https://pandamin18436220.github.io/tags/Naoqi/"}]},{"title":"Nao行走","date":"2020-02-09T06:37:33.754Z","path":"2020/02/09/nao之行走/","text":"在此先附上一串简单的机器人行走代码此代码适于用做测量Nao的步态参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding:utf-8 -*-from naoqi import ALProxyimport mathimport argparseimport almathdef main(robotIP,PORT): motion=ALProxy(\"ALMotion\", robotIP,PORT) posture=ALProxy(\"ALRobotPosture\",robotIP,PORT) tts=ALProxy(\"ALTextToSpeech\",robotIP,PORT) posture.goToPosture(\"StandInit\",0.5) motion.wakeUp() motion.moveTo(2.5,0.0,0.0,config) tts.say(\"左转\") motion.moveTo(0.0,0.0,math.pi/2,Config) motion.moveTo(1.0,0.0,0.0,config) tts.say(\"左转\") motion.moveTo(0.0,0.0,math.pi/2,Config) motion.moveTo(2,5.0,0.0,config) motion.rest()if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument(\"--ip\", type=str, default=\"127.0.0.1\", help=\"Robot IP address. On robot or Local Naoqi: use '127.0.0.1'.\") parser.add_argument(\"--port\", type=int, default=9559, help=\"Naoqi port number\") args = parser.parse_args() #步态参数 config=[ [\"MaxStepX\",0.045], [\"MaxStepY\",0.145], [\"MaxStepFrequency\",0.4], [\"TorsoWx\",5.0*almath.TO_RAD]#5度 ] config1=[ [\"MaxStepX\",0.035], [\"MaxStepY\",0.145], [\"MaxStepFrequency\",0.3] #[\"TorsoWx\",-0.05] #[\"TorsoWy\",0.05] ] robotIP=args.ip PORT=args.port 步态参数（moveConfig）的介绍操控机器人最基础的就是操控机器人走路，而想要让机器人可以平稳的行走就需要我们对moveConfig中的参数进行调试。其中不同的机器人对于不同的步态参数的适应力都不相同，也就是说相同的步态参数可以让这个机器人平稳行走，放在另一个机器人上就可能行不通，所以在每次运行不同机器人前都需要进行调试。moveConfig中包含了以下这些参数及参数可调范围： 名称 作用 默认值 最低限度 最大值 可设置 MaxStepX 沿X(米)的最大向前平移 0.040 0.001 0.080 是 MinStepX 沿X(米)的最大向后平移 -0.040 没有 MaxStepY 沿Y(米)的绝对最大横向平移 0.140 0.101 0.160 是 MaxStepTheta Z(弧度)周围的绝对最大旋转 0.349 0.001 0.524 是 MaxStepFrequency 最大步进频率(标准化，无单位) 1. 0. 1. 是 MinStepPeriod 最小步长(秒) 0.42 没有 MaxStepPeriod 最大步长(秒) 0.6 没有 梯状 沿Z(米)的峰值脚高 0.020 0.005 0.040 是 TorsoWx X(弧度)周围的峰值躯干旋转 0.000 -0.122 0.122 是 TorsoWy y(弧度)周围的峰值躯干旋转 0.000 -0.122 0.122 是 FootSeparation 沿Y(米)改变双脚之间的距离 0.1 没有 MinFootSeparation 沿Y的最小距离(米) 0.088 没有","comments":true,"tags":[{"name":"Nao","slug":"Nao","permalink":"https://pandamin18436220.github.io/tags/Nao/"},{"name":"Naoqi","slug":"Naoqi","permalink":"https://pandamin18436220.github.io/tags/Naoqi/"}]},{"title":"世界怎么了","date":"2020-02-07T13:15:03.511Z","path":"2020/02/07/随笔录之世界怎么了/","text":"大爱无疆，生死不在话下。拥有大爱和超出常人气魄胆量的人，如今都在疫情的一线用性命去和病毒搏斗，他们不是没有家人没有眼泪没有恐惧没有情绪，更不是因为他们有九条命。而是他们不仅仅只爱眼下围城里的专属物品，亲人、朋友。他们越过了所有人认知里的小世界，还爱着安全疆域之外的陌生人，所有的陌生人加起来就是祖国、是全人类，再大一点，其实可以说是动物世界。 如今只要是躺在病床上的无论黑发碧眼高矮胖瘦，温柔求救或是出言不逊口吐芬芳，被人抓着脖颈歇斯底里辱骂害怕到发抖也都会去医治挽救。我们常说救人是医生该做的事，但没有说冒着搭进自己性命的危险也是该做的事。如果我们仍口口声声说他们是在上班，那不好意思，班是可以请假的，更可以离职，换一个班上。在所有的危难时刻里挺身而出的职业都不算做是职业，而是人类的帕修斯。 只有爱能给人带来无边的勇气，忘却生死和利益。那一刻他们不是活在某一个城市，而是活在了宇宙中心，他们似乎比我们高了好几个维度，夏虫不可语于冰。只有看到他们抽出3分钟吃顿饭的时候才恍惚觉得他们不是神。 小爱围城，生死是头等大事。每个家庭就是一个小围城。我们都在汲汲营营的生存，在这一隅天地里付出自己的爱得到对方的情。我们思考的事情是如何让围城里的人能够过得更好，不至于死的太快或太惨。围城外的人是我们的攀比对象，也是我们成败的见证对象。我们可能会活的有些自私，我们可能只帮自己人。 无爱恶魔，混迹人间。有些“人”，甚至连自己围城里的人或物都不爱，具体能有多不爱，要看情势有多严峻，把他们逼到什么地步。因为还是不能杀人的，如果可以，我猜他们应该会建议一把火把病毒区连人带房都烧了，别怪我为什么这样猜测，当谣言说猫狗会传染后第一时间就是将它们丢弃或弄死。和谁的情都是情，和人是，和动物更是。我们爱自己的宠物，就是真心爱着，是自己人。只有虚假的感情才能瞬间去裁决生死，因为不会让自己伤心，他们根本就没有心。 我很难过在这样特殊情况下的很多事情。难过所有被连累逝去的生命；难过所有无法休息拿命搏斗的人；难过一座美丽的城市却成了恐慌的代名词。 自私一点的难过是，爱的人过家门而不能入，一句想念隔了几千公里。我很难过无法见你这件事。而越是危难时刻，我愈发想见你。 都在说疫情过后要如何如何，疫情过后我只想珍惜你和我的生命，做一对快乐的夏虫。 然而压死骆驼的稻草也似乎永远都不止一根，多少男孩心目中的神也的确回到了天堂。科比坠机的那天不知道又有多少眼泪在横飞。 我们为什么会这样的揪心难过，因为他是一代人的青春，是过去我们存活激情时刻留下的生命印证，从篮球连带着想起那些岁月，篮球场、汗流浃背的身影、看我们打球的姑娘、发疯般追过的曼巴精神，这些会让我们恍然隔世，原来我们曾那样活过啊！失去他，就好像失去了生命的一部分。始于科比的篮球，终于凌晨四点的洛杉矶。 理论是灰色的，生命之树常青。这是李文亮医生是微信签名。从他被处分，感染到平反。他说了实话，说了很多人不敢说的话。但却得到了不相称的惩罚！同一天，他的核酸检测结果出来了，阳性。他说：尘埃落定，终于确诊了，还配了个狗狗的表情。他在病房里看到许多网友的鼓励，在微博上感谢大家：谢谢大家的支持，我没有被吊销执照，请大家放心，我一定积极配合治疗，争取早日出院。再之前，工作群里号召医生们报名到防疫一线时，他还说了一句：我好了也报名。但他却被宣告死亡… 澳大利亚大火，应该给人类和这个星球留下哪些教训？因为人广地稀，所以死亡的人员并不多（但也至少28人死亡）。不过造成了极大的生态灾难：至少10亿只动物丧生火海。这么多的野生动物被烧死，对本来就相对脆弱的澳洲生态系统一定会造成难以弥补的损害。从去年9月开始，澳大利亚的山火已经整整燃烧了四个多月，迄今仍未看到熄灭的迹象。 美国流感疫情严重，据报道，今年美国的流感季相对往年不仅来得早，而且爆发速度快快，流感最先在东南部数州出现后迅速扩散，迄今没有减缓的迹象。包括南方地区、西部的部分地区、纽约市和华盛顿，现流感已扩散至46个州。 这些天的足不出户，让我发了足够久的呆，我思考着这一切，不知该拿什么心情收场。人类的悲欢在此刻是相通的吧，我想。","comments":true,"tags":[{"name":"随笔录","slug":"随笔录","permalink":"https://pandamin18436220.github.io/tags/%E9%9A%8F%E7%AC%94%E5%BD%95/"}]},{"title":"PIL库","date":"2020-02-07T12:41:48.226Z","path":"2020/02/07/PIL库/","text":"��-\u0000-\u0000-\u0000\u0000\u0000t\u0000i\u0000t\u0000l\u0000e\u0000:\u0000 \u0000P\u0000I\u0000L\u0000�^\u0000\u0000d\u0000a\u0000t\u0000a\u0000:\u0000 \u00002\u00000\u00002\u00000\u0000-\u00000\u00002\u0000-\u00000\u00007\u0000 \u00001\u00007\u0000:\u00004\u00000\u0000:\u00000\u00000\u0000\u0000\u0000t\u0000a\u0000g\u0000s\u0000:\u0000 \u0000[\u0000p\u0000y\u0000t\u0000h\u0000o\u0000n\u0000,\u0000P\u0000I\u0000L\u0000]\u0000\u0000\u0000-\u0000-\u0000-\u0000\u0000\u0000#\u0000#\u0000 \u0000P\u0000I\u0000L\u0000�v\\O(u\u0000\u0000\u0000\u0000�[�N�V�PƋ+R �’Yϑ�v�]\\O(W�N�V�P�v\u0004Y\u0006t �\u0004Y\u0006tHe�g}Y ���HNMb���}Y0WƋ+R ��Vdk �o�}Y�v�V�P\u0004Y\u0006t/fƋ+R�v�W@x\u00020(WP\u0000y\u0000t\u0000h\u0000o\u0000n\u0000-N � g\u0000NN\u0018O�y�v�V�P\u0004Y\u0006tFh�g �1/fP\u0000I\u0000L\u0000�^\u00020FO,g�{�e�z;N��eg�N�~P\u0000I\u0000L\u0000-N�vI\u0000m\u0000a\u0000g\u0000e\u0000!jWW�v�vsQ�Qpe ��Y�gO؏��N��f\u001aY ��S�N�p�Q�[�e�ech���cۏL�f[`N\u00020\u0000\u0000�v�O�c0R�V�P�v\u0004Y\u0006t�]\\O ��_\u001aY\u000f\\\u0019O4O�N\u001aO�c0RO\u0000p\u0000e\u0000n\u0000C\u0000v\u0000�^N_N gُN�R��\u0017T\u001f�\u0000\u0000&lt;\u0000!\u0000-\u0000-\u0000m\u0000o\u0000r\u0000e\u0000-\u0000-\u0000&gt;\u0000\u0000\u0000#\u0000#\u0000#\u0000#\u0000 \u0000��\u0011b�N��HQeg�k��\u0000N N�N�N�v:S+R\u0000\u0000\u0000\u0000|\u0000 \u0000!jWWT�y \u0000|\u0000 \u0000�Qpe \u0000|\u0000 \u0000\\O(u|\u0000\u0000\u0000|\u0000 \u0000:\u0000-\u0000-\u0000-\u0000-\u0000:\u0000 \u0000|\u0000 \u0000:\u0000-\u0000-\u0000-\u0000-\u0000:\u0000 \u0000|\u0000 \u0000:\u0000-\u0000-\u0000-\u0000-\u0000:\u0000 \u0000|\u0000\u0000\u0000|\u0000O\u0000p\u0000e\u0000n\u0000C\u0000v\u0000|\u0000c\u0000v\u00002\u0000.\u0000i\u0000m\u0000s\u0000h\u0000o\u0000w\u0000(\u0000)\u0000|\u0000Ǒ(uB\u0000G\u0000R\u0000!j\u000f �\u001a�Ǐc\u0000v\u00002\u0000.\u0000i\u0000m\u0000r\u0000e\u0000a\u0000d\u0000(\u0000)\u0000���S|\u0000\u0000\u0000|\u0000m\u0000a\u0000t\u0000p\u0000l\u0000o\u0000t\u0000l\u0000i\u0000b\u0000.\u0000p\u0000y\u0000p\u0000l\u0000o\u0000t\u0000|\u0000 \u0000p\u0000l\u0000t\u0000.\u0000i\u0000m\u0000s\u0000h\u0000o\u0000w\u0000(\u0000)\u0000|\u0000 \u0000Ǒ(uR\u0000G\u0000B\u0000!j\u000f,\u0000 \u0000\u001a�Ǐp\u0000l\u0000t\u0000.\u0000i\u0000m\u0000r\u0000e\u0000a\u0000d\u0000(\u0000)\u0000���S|\u0000\u0000\u0000|\u0000P\u0000I\u0000L\u0000.\u0000I\u0000m\u0000a\u0000g\u0000e\u0000|\u0000i\u0000m\u0000g\u0000.\u0000s\u0000h\u0000o\u0000w\u0000(\u0000)\u0000|\u0000Ǒ(uR\u0000G\u0000B\u0000!j\u000f,\u0000 \u0000\u001a�ǏI\u0000m\u0000a\u0000g\u0000e\u0000.\u0000o\u0000p\u0000e\u0000n\u0000(\u0000)\u0000���S|\u0000\u0000\u0000\u0000\u0000#\u0000#\u0000#\u0000 \u0000o\u0000o\u0000p\u0000e\u0000n\u0000c\u0000v\u0000(\u0000B\u0000G\u0000R\u0000)\u0000&gt;f:y�VGr\u0000\u0000\u0000\u0000\u0000\u0000\u0000 \u0000 \u0000#\u0000 \u0000i\u0000m\u0000g\u0000:NB\u0000G\u0000R\u0000\u001a�S� \u0000 \u0000i\u0000m\u0000g\u0000 \u0000=\u0000 \u0000c\u0000v\u00002\u0000.\u0000i\u0000m\u0000r\u0000e\u0000a\u0000d\u0000(\u0000i\u0000m\u0000g\u0000_\u0000p\u0000a\u0000t\u0000h\u0000,\u0000 \u0000m\u0000o\u0000d\u0000e\u0000)\u0000 \u0000 \u0000#\u0000 \u0000m\u0000o\u0000d\u0000e\u0000 \u0000=\u0000 \u0000[\u00001\u0000,\u0000 \u00000\u0000,\u0000 \u0000-\u00001\u0000]\u0000�O!kh�:yi_r�\u00010pp�^\u00010i_r�+\u0000a\u0000l\u0000p\u0000h\u0000a\u0000 � \u0000؞��:N1\u0000;\u0000 \u0000 \u0000c\u0000v\u00002\u0000.\u0000i\u0000m\u0000s\u0000h\u0000o\u0000w\u0000(\u0000&#39;\u0000t\u0000e\u0000s\u0000t\u0000&#39;\u0000,\u0000 \u0000i\u0000m\u0000g\u0000)\u0000 \u0000 \u0000c\u0000v\u00002\u0000.\u0000w\u0000a\u0000i\u0000t\u0000K\u0000e\u0000y\u0000(\u00000\u0000)\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000#\u0000 \u0000�O\u0001c�Vb_Lub� ��v0RO(W��z��eQ�N\u000faW[&amp;{\u0000\u0000c\u0000v\u00002\u0000.\u0000d\u0000e\u0000s\u0000t\u0000r\u0000o\u0000y\u0000A\u0000l\u0000l\u0000W\u0000i\u0000n\u0000d\u0000o\u0000w\u0000s\u0000(\u0000)\u0000\u0000\u0000\u0000\u0000\u0000 \u0000 \u0000 \u0000 \u0000#\u0000#\u0000#\u0000 \u0000P\u0000I\u0000L\u0000.\u0000I\u0000m\u0000a\u0000g\u0000e\u0000(\u0000R\u0000G\u0000B\u0000)\u0000&gt;f:y�VGr \u0000 \u0000 \u0000 \u0000\u0000\u0000\u0000\u0000\u0000i\u0000m\u0000g\u0000 \u0000=\u0000 \u0000I\u0000m\u0000a\u0000g\u0000e\u0000.\u0000o\u0000p\u0000e\u0000n\u0000(\u0000i\u0000m\u0000g\u0000_\u0000p\u0000a\u0000t\u0000h\u0000)\u0000\u0000\u0000i\u0000m\u0000g\u0000.\u0000s\u0000h\u0000o\u0000w\u0000(\u0000)\u0000\u0000\u0000\u0000\u0000\u0000 \u0000 \u0000 \u0000 \u0000#\u0000#\u0000#\u0000 \u0000P\u0000I\u0000L\u0000.\u0000I\u0000m\u0000a\u0000g\u0000e\u0000l�O\u0000p\u0000e\u0000n\u0000c\u0000v\u0000 \u0000 \u0000 \u0000 \u0000\u0000\u0000\u0000\u0000\u0000c\u0000v\u00002\u0000_\u0000i\u0000m\u0000g\u0000 \u0000=\u0000 \u0000c\u0000v\u00002\u0000.\u0000c\u0000v\u0000t\u0000C\u0000o\u0000l\u0000o\u0000r\u0000(\u0000n\u0000u\u0000m\u0000p\u0000y\u0000.\u0000a\u0000s\u0000a\u0000r\u0000r\u0000a\u0000y\u0000(\u0000I\u0000m\u0000g\u0000_\u0000i\u0000m\u0000g\u0000)\u0000,\u0000c\u0000v\u00002\u0000.\u0000C\u0000O\u0000L\u0000O\u0000R\u0000_\u0000R\u0000G\u0000B\u00002\u0000B\u0000G\u0000R\u0000)\u0000\u0000\u0000\u0000\u0000\u0000 \u0000 \u0000 \u0000 \u0000#\u0000#\u0000#\u0000 \u0000O\u0000p\u0000e\u0000n\u0000c\u0000v\u0000l�P\u0000I\u0000L\u0000.\u0000I\u0000m\u0000a\u0000g\u0000e\u0000 \u0000 \u0000 \u0000 \u0000\u0000\u0000\u0000\u0000\u0000p\u0000i\u0000l\u0000_\u0000i\u0000m\u0000g\u0000 \u0000=\u0000 \u0000I\u0000m\u0000a\u0000g\u0000e\u0000.\u0000f\u0000r\u0000o\u0000m\u0000a\u0000r\u0000r\u0000a\u0000y\u0000(\u0000c\u0000v\u00002\u0000.\u0000c\u0000v\u0000t\u0000C\u0000o\u0000l\u0000o\u0000r\u0000(\u0000c\u0000v\u0000_\u0000i\u0000m\u0000g\u0000,\u0000c\u0000v\u00002\u0000.\u0000C\u0000O\u0000L\u0000O\u0000R\u0000_\u0000B\u0000G\u0000R\u00002\u0000R\u0000G\u0000B\u0000)\u0000)\u0000\u0000\u0000\u0000\u0000`\u0000\u0000\u0000\u0000\u0000#\u0000#\u0000#\u0000#\u0000 \u0000 Nb��N�I\u0000m\u0000a\u0000g\u0000e\u0000!jWW�vsQ�Qpe\u0000\u0000I\u0000m\u0000a\u0000g\u0000e\u0000!jWW/f(WP\u0000y\u0000t\u0000h\u0000o\u0000n\u0000 \u0000P\u0000I\u0000L\u0000�V�P\u0004Y\u0006t-N8^���v!jWW ��[�V�PۏL��W@x�d\\O�v�R���W,g��\u0005S+T�Ndk!jWW�Q\u00020�Yo\u0000p\u0000e\u0000n\u0000\u00010s\u0000a\u0000v\u0000e\u0000\u00010c\u0000o\u0000n\u0000v\u0000e\u0000r\u0000\u00010s\u0000h\u0000o\u0000w\u0000&amp; I{�R��\u00020\u0000\u0000\u0000\u0000|\u0000 \u0000{|!jWW?\u0000|\u0000 \u0000\\O(u|\u0000\u0000\u0000|\u0000 \u0000:\u0000-\u0000-\u0000-\u0000-\u0000:\u0000 \u0000|\u0000 \u0000:\u0000-\u0000-\u0000-\u0000-\u0000:\u0000 \u0000|\u0000\u0000\u0000|\u0000o\u0000p\u0000e\u0000n\u0000{||\u0000i\u0000m\u0000 \u0000=\u0000 \u0000I\u0000m\u0000a\u0000g\u0000e\u0000.\u0000o\u0000p\u0000e\u0000n\u0000(\u0000\u001c �e�NX[(W�v\u001d )\u0000|\u0000\u0000\u0000|\u0000S\u0000a\u0000v\u0000e\u0000{||\u0000i\u0000m\u0000.\u0000s\u0000a\u0000v\u0000e\u0000(\u0000\u001c �e�N�OX[_\u001d )\u0000|\u0000\u0000\u0000|\u0000S\u0000i\u0000z\u0000e\u0000{||\u0000i\u0000m\u0000.\u0000s\u0000i\u0000z\u0000e\u0000 \u0000:\\�[�Oo`|\u0000\u0000\u0000|\u0000n\u0000e\u0000w\u0000{||\u0000i\u0000m\u0000=\u0000 \u0000I\u0000m\u0000a\u0000g\u0000e\u0000.\u0000n\u0000e\u0000w\u0000(\u0000\u001c \u001a�S�R\u0000G\u0000B\u0000\u001d ,\u0000 \u0000(\u0000:\\�[)\u0000,\u0000 \u0000\u001c ��r�\u001d )\u0000|\u0000\u0000\u0000|\u0000S\u0000p\u0000l\u0000i\u0000t\u0000{||\u0000r\u0000,\u0000g\u0000,\u0000b\u0000 \u0000=\u0000 \u0000i\u0000m\u0000.\u0000s\u0000p\u0000l\u0000i\u0000t\u0000(\u0000)\u0000 \u0000\u0006R�y\u001c R\u0000G\u0000B\u0000\u001d �V�P\u0006\\�N\u001fu NN�e�v�V�P �\u0006R+R�[�^�S�Y�V�P�v�kN\u001a�S�\b��~ ��~ �݄ �|\u0000\u0000\u0000|\u0000M\u0000e\u0000r\u0000g\u0000e\u0000{||\u0000I\u0000m\u0000a\u0000g\u0000e\u0000.\u0000m\u0000e\u0000r\u0000g\u0000e\u0000(\u0000\u001c R\u0000G\u0000B\u0000\u001d ,\u0000[\u0000r\u0000,\u0000g\u0000,\u0000b\u0000]\u0000)\u0000 \u0000\bTv^ N*N\u001a�S�|\u0000\u0000\u0000|\u0000c\u0000o\u0000n\u0000v\u0000e\u0000r\u0000t\u0000{||\u0000\u0006\\S_MR�V�Pl�bc:NvQ�N!j\u000f ��~��� w�S����c|\u0000\u0000\u0000\u0000\u0000[\u0000�[�e�ech]\u0000(\u0000h\u0000t\u0000t\u0000p\u0000s\u0000:\u0000/\u0000/\u0000p\u0000i\u0000l\u0000l\u0000o\u0000w\u0000-\u0000c\u0000n\u0000.\u0000r\u0000e\u0000a\u0000d\u0000t\u0000h\u0000e\u0000d\u0000o\u0000c\u0000s\u0000.\u0000i\u0000o\u0000/\u0000z\u0000h\u0000_\u0000C\u0000N\u0000/\u0000l\u0000a\u0000t\u0000e\u0000s\u0000t\u0000/\u0000r\u0000e\u0000f\u0000e\u0000r\u0000e\u0000n\u0000c\u0000e\u0000/\u0000i\u0000n\u0000d\u0000e\u0000x\u0000.\u0000h\u0000t\u0000m\u0000l\u0000)\u0000\u0000\u0000\u0000\u0000[\u0000�S�`���c]\u0000(\u0000h\u0000t\u0000t\u0000p\u0000s\u0000:\u0000/\u0000/\u0000b\u0000l\u0000o\u0000g\u0000.\u0000c\u0000s\u0000d\u0000n\u0000.\u0000n\u0000e\u0000t\u0000/\u0000z\u0000h\u0000a\u0000n\u0000g\u0000z\u0000i\u0000j\u0000u\u0000/\u0000a\u0000r\u0000t\u0000i\u0000c\u0000l\u0000e\u0000/\u0000d\u0000e\u0000t\u0000a\u0000i\u0000l\u0000s\u0000/\u00007\u00009\u00001\u00002\u00003\u00002\u00007\u00005\u0000)\u0000\u0000\u0000","comments":true,"tags":[]},{"title":"sys库","date":"2020-02-07T12:02:38.353Z","path":"2020/02/07/sys库/","text":"sys的作用sys模块主要是针对与Python解释器相关的变量和方法，不是主机操作系统。 sys函数 作用 sys.argv 获取命令行参数列表，第一个元素是程序本身 sys.exit(n) 退出Python程序，exit(0)表示正常退出。当参数非0时，会引发一个SystemExit异常，可以在程序中捕获该异常 sys.version 获取Python解释程器的版本信息 sys.maxsize 最大的Int值，64位平台是2**63 - 1 sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.platform 返回操作系统平台名称 sys.stdin 输入相关 sys.stdout 输出相关 sys.stderr 错误相关 sys.exc_info() 返回异常信息三元元组 sys.getdefaultencoding() 获取系统当前编码，默认为utf-8 sys.setdefaultencoding() 设置系统的默认编码 sys.getfilesystemencoding() 获取文件系统使用编码方式，默认是utf-8 sys.modules 以字典的形式返回所有当前Python环境中已经导入的模块 sys.builtin_module_names 返回一个列表，包含所有已经编译到Python解释器里的模块的名字 sys.copyright 当前Python的版权信息 sys.flags 命令行标识状态信息列表。只读。 sys.getrefcount(object) 返回对象的引用数量 sys.getrecursionlimit() 返回Python最大递归深度，默认1000 sys.getsizeof(object[, default]) 返回对象的大小 sys.getswitchinterval() 返回线程切换时间间隔，默认0.005秒 sys.setswitchinterval(interval) 设置线程切换的时间间隔，单位秒 sys.getwindowsversion() 返回当前windwos系统的版本信息 sys.hash_info 返回Python默认的哈希方法的参数 sys.implementation 当前正在运行的Python解释器的具体实现，比如CPython sys.thread_info 当前线程信息 官方文档链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"sys","slug":"sys","permalink":"https://pandamin18436220.github.io/tags/sys/"}]},{"title":"OS库","date":"2020-02-07T11:36:01.637Z","path":"2020/02/07/os库/","text":"OS的作用OS模块提供了一些方便使用操作系统相关功能的函数。 OS函数 作用 os.sep 取代操作系统特定的路径分隔符 os.name 指示你正在使用的工作平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’。 os.getcwd 得到当前工作目录，即当前python脚本工作的目录路径。 os.getenv()和os.putenv() 分别用来读取和设置环境变量 os.listdir() 返回指定目录下的所有文件和目录名 os.remove(file) 删除一个文件 os.stat（file） 获得文件属性 os.chmod(file) 修改文件权限和时间戳 os.mkdir(name) 创建目录 os.rmdir(name) 删除目录 os.removedirs（r“c：\\python”） 删除多个目录 os.system() 运行shell命令 os.exit() 终止当前进程 os.linesep 给出当前平台的行终止符。例如，Windows使用’\\r\\n’，Linux使用’\\n’而Mac使用’\\r’ os.path.split() 返回一个路径的目录名和文件名 os.path.isfile()和os.path.isdir() 分别检验给出的路径是一个目录还是文件 os.path.existe() 检验给出的路径是否真的存在 os.listdir(dirname) 列出dirname下的目录和文件 os.getcwd() 获得当前工作目录 os.curdir 返回当前目录（’.’） os.chdir(dirname) 改变工作目录到dirname os.path.isdir(name): 判断name是不是目录，不是目录就返回false os.path.isfile(name) 判断name这个文件是否存在，不存在返回false os.path.exists(name) 判断是否存在文件或目录name os.path.getsize(name) 或得文件大小，如果name是目录返回0L os.path.abspath(name) 获得绝对路径 os.path.isabs() 判断是否为绝对路径 os.path.normpath(path) 规范path字符串形式 os.path.split(name) 分割文件名与目录（事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在） os.path.splitext() 分离文件名和扩展名 os.path.join(path,name) 连接目录与文件名或目录 os.path.basename(path) 返回文件名 os.path.dirname(path) 返回文件路径 官方文档链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"OS","slug":"OS","permalink":"https://pandamin18436220.github.io/tags/OS/"}]},{"title":"Numpy库","date":"2020-02-07T08:33:20.147Z","path":"2020/02/07/numpy库/","text":"Numpy的作用Numpy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。 Numpy库与数组的区别python中可以使用列表保存一组值，可将列表当数组使用。另外，python中有array模块，但它不支持多维数组。所以无论是列表还是array模块都没有科学运算函数，不适合做矩阵等科学计算。 numpy没有使用python本身的数组机制，而是提供了ndarray对象，该对象不仅能方便地存取数组，而且拥有丰富的数组计算函数。Numpy的基本使用下面介绍Numpy的基础知识与相关函数 创建数组及使用 12345678910111213141516171819202122232425262728#定义了一个二维数组，大小为（2，3）&gt;&gt;&gt; x=np.array([ [1.0,0.0,0.0], [0.,1.,2.] ])&gt;&gt;&gt; xarray([[1., 0., 0.], [0., 1., 2.]])#数组维度数&gt;&gt;&gt; x.ndim2#数组的维数，返回的格式(n,m),其中n为行数，m为列数&gt;&gt;&gt; x.shape(2, 3)#数组元素的总数&gt;&gt;&gt; x.size6#数组元素类型&gt;&gt;&gt; x.dtype#64位浮点型dtype('float64')#每个元素占有的字节大小 &gt;&gt;&gt; x.itemsize 8#数组元素的缓冲区&gt;&gt;&gt; x.data&lt;memory at 0x00000205227DAC18&gt; 知识点扩展: 创建序列数组的函数arrange和linspace。（range函数类似） arange(a,b,c) 参数表示(开始值，结束值，步长) linspace(a,b,c) 参数表示(开始值，结束值，元素数量) 调用reshape()可以指定形状 123456789101112&gt;&gt;&gt; arange(6).reshape(2,3)array([ [ 0, 1, 2], [ 3, 4, 5], [10, 11, 12] ])&gt;&gt;&gt; arange(1,5,2) array([1, 3, 5])&gt;&gt;&gt; arange(0,1,0.5) array([0. , 0.5, 1])&gt;&gt;&gt; linspace(0,2,9) array([0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) 特殊数组 zeros数组：全零数组，元素全为零。 ones数组：全1数组，元素全为1。 empty数组：空数组，元素全近似为0。 1234567891011121314151617181920212223242526&gt;&gt;&gt; zeros((3,4)) array([ [0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.] ])&gt;&gt;&gt; ones((2,3,4),dtype=int16) array([ [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ], [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] ], dtype=int16)&gt;&gt;&gt; empty((5,3)) array([ [6.23042070e-307, 1.42417221e-306, 1.37961641e-306], [1.11261027e-306, 1.11261502e-306, 1.42410839e-306], [7.56597770e-307, 6.23059726e-307, 1.42419530e-306], [7.56599128e-307, 1.11260144e-306, 6.89812281e-307], [2.22522596e-306, 2.22522596e-306, 2.56761491e-312] ]) 数组索引 Numpy数组通过索引访问12345678910111213141516171819&gt;&gt;&gt; c=arange(24).reshape(2,3,4)&gt;&gt;&gt; print(c)[ [ [ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] ] [ [12 13 14 15] [16 17 18 19] [20 21 22 23] ]]&gt;&gt;&gt; print(c[1,2,:]) [20 21 22 23]&gt;&gt;&gt; print(c[0,1,2]) 6 数组运算 数组的加减乘除以及乘方运算方式为:相应位置的元素分别进行运算。12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; a=array([20,30,40,50])&gt;&gt;&gt; aa=arange(1,5)&gt;&gt;&gt; a/aa array([20. , 15. , 13.33333333, 12.5 ])&gt;&gt;&gt; b=arange(4)&gt;&gt;&gt; b array([0, 1, 2, 3])&gt;&gt;&gt; c=a-b&gt;&gt;&gt; c array([20, 29, 38, 47])&gt;&gt;&gt; b**2 array([0, 1, 4, 9], dtype=int32)&gt;&gt;&gt; A=array([ [1,1], [0,1] ])&gt;&gt;&gt; B=array([ [2,0], [3,4] ])&gt;&gt;&gt; A*B array([ [2, 0], [0, 4] ])&gt;&gt;&gt; A.sum() 3&gt;&gt;&gt; A.min() 0&gt;&gt;&gt; A.max() 1 数组的拷贝 拷贝有浅拷贝和深拷贝两种; 浅拷贝通过数组变量的赋值完成,浅拷贝只拷贝数组的引用，如果对拷贝进行修改，源数组也将修改; 深拷贝使用数组对象的copy方法，会复制一份和源数组一样的数组，新数组与源数组会存放在不同内存位置，因此对新数组的修改不会影响源数组。 案例一(浅拷贝)1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; a=ones((2,3))&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 1.] ])&gt;&gt;&gt; b=a&gt;&gt;&gt; b[1,2]=2&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 2.] ])&gt;&gt;&gt; b array([ [1., 1., 1.], [1., 1., 2.] ])案例二(深拷贝)&gt;&gt;&gt; a=ones((2,3))&gt;&gt;&gt; b=a.copy()&gt;&gt;&gt; b[1,2]=2&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 1.] ])&gt;&gt;&gt; b array([ [1., 1., 1.], [1., 1., 2.] ]) 创建矩阵 矩阵与数组的区别Numpy的矩阵对象与数组对象相似。其不同之处在于，矩阵对象的计算遵循矩阵数学运算律。矩阵使用matrix函数创建。1234567891011121314151617&gt;&gt;&gt; A=matrix('1.0 2.0;3.0 4.0')&gt;&gt;&gt; A matrix([ [1., 2.], [3., 4.] ])&gt;&gt;&gt; B=matrix([ [1.0,2.0], [3.0,4.0] ])&gt;&gt;&gt; B matrix([ [1., 2.], [3., 4.] ])&gt;&gt;&gt; type(A) &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt; 矩阵运算 123456789101112131415161718&gt;&gt;&gt; A.T #转置 matrix([ [1., 3.], [2., 4.] ])&gt;&gt;&gt; x=matrix('5.0 7.0')&gt;&gt;&gt; y=x.T&gt;&gt;&gt; y matrix([ [5.], [7.] ])&gt;&gt;&gt; print(A*y) #矩阵乘法 [[26.] [38.]]&gt;&gt;&gt; print(A.I) #逆矩阵 [[-2. 1. ] [ 1.5 -0.5]] Numpy线性代数相关函数 numpy.dot() 此函数返回两个数组的点积。 对于二维向量，其等效于矩阵乘法。 对于一维数组，它是向量的内积。 对于 N 维数组，它是a的最后一个轴上的和与b的倒数第二个轴的乘积。 12345&gt;&gt;&gt; a=np.array([[1,2],[3,4]])&gt;&gt;&gt; b=np.array([[11,12],[13,14]])&gt;&gt;&gt; np.dot(a,b) array([[37, 40], #[[1*11+2*13, 1*12+2*14],[3*11+4*13, 3*12+4*14]] [85, 92]]) numpy.vdot() 此函数返回两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数id是多维数组，它会被展开。 12&gt;&gt;&gt; np.vdot(a,b) 130 #1*11+2*12+3*13+4*14=130 numpy.inner() 此函数返回一维数组的向量内积。 对于更高的维度，它返回最后一个轴上的和的乘积。 1234&gt;&gt;&gt; x=np.array([1,2,3])&gt;&gt;&gt; y=np.array([0,1,0])&gt;&gt;&gt; print(np.inner(x,y)) 2 # 等价于 1*0+2*1+3*0 numpy.matmul() 函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。 另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。 #对二维数组（列表），就相当于矩阵乘法 123456789101112131415161718192021&gt;&gt;&gt; a=[[1,0],[0,1]]&gt;&gt;&gt; b=[[4,1],[2,2]]&gt;&gt;&gt; print(np.matmul(a,b))[[4 1][2 2]]#二维和一维运算&gt;&gt;&gt; a=[[1,0],[0,1]]&gt;&gt;&gt; b=[1,2]&gt;&gt;&gt; print(np.matmul(a,b)) [1 2]&gt;&gt;&gt; print(np.matmul(b,a)) [1 2]#维度大于2的&gt;&gt;&gt; a=np.arange(8).reshape(2,2,2)&gt;&gt;&gt; b=np.arange(4).reshape(2,2)&gt;&gt;&gt; print(np.matmul(a,b)) [[[ 2 3] [ 6 11]] [[10 19] [14 27]]] numpy.linalg.det() 行列式在线性代数中是非常有用的值。 它从方阵的对角元素计算。 对于 2×2 矩阵，它是左上和右下元素的乘积与其他两个的乘积的差。 换句话说，对于矩阵[[a，b]，[c，d]]，行列式计算为ad-bc。 较大的方阵被认为是 2×2 矩阵的组合。 numpy.linalg.det()函数计算输入矩阵的行列式。 123456789101112&gt;&gt;&gt; a=np.array([[1,2],[3,4]])&gt;&gt;&gt; print(np.linalg.det(a)) -2.0000000000000004&gt;&gt;&gt; b=np.array([[6,1,1],[4,-2,5],[2,8,7]])&gt;&gt;&gt; print(b) [[ 6 1 1] [ 4 -2 5] [ 2 8 7]]&gt;&gt;&gt; print(np.linalg.det(b)) -306.0&gt;&gt;&gt; print(6*(-2*7-5*8)-1*(4*7-5*2)+(4*8- -2*2)) -306 numpy.linalg.solve() 该函数给出了矩阵形式的线性方程的解。 1234567891011121314151617181920212223&gt;&gt;&gt; x=np.array([[1,2],[3,4]])&gt;&gt;&gt; y=np.linalg.inv(x)&gt;&gt;&gt; x array([[1, 2], [3, 4]])&gt;&gt;&gt; y array([[-2. , 1. ], [ 1.5, -0.5]])&gt;&gt;&gt; np.dot(x,y) array([[1.0000000e+00, 0.0000000e+00], [8.8817842e-16, 1.0000000e+00]]) a=np.array([[1,1,1],[0,2,5],[2,5,-1]]) print('数组a:') print(a) ainv=np.linalg.inv(a) print('a的逆矩阵') print(ainv) print('矩阵b:') b=np.array([[6],[-4],[27]]) print(b) print('计算：A^(-1)B:') x=np.linalg.solve(a,b) print(x) 数组分割 使用hsplit你能将数组沿着它的Y轴分割，或者指定返回相同形状数组的个数，或者指定在哪些列后发生分割。vsplit沿着X轴分割。12345678910111213141516171819202122232425262728293031323334&gt;&gt;&gt; a = floor(10*random.random((2,12)))&gt;&gt;&gt; a array([ [ 8., 8., 3., 9., 0., 4., 3., 0., 0., 6., 4., 4.], [ 0., 3., 2., 9., 6., 0., 4., 5., 7., 5., 1., 4.] ])&gt;&gt;&gt; hsplit(a,3) # Split a into 3 [array([ [ 8., 8., 3., 9.], [ 0., 3., 2., 9.] ]), array([ [ 0., 4., 3., 0.], [ 6., 0., 4., 5.] ]), array([ [ 0., 6., 4., 4.], [ 7., 5., 1., 4.]] )]&gt;&gt;&gt; hsplit(a,(3,4)) # Split a after the third and the fourth column [ array([ [ 8., 8., 3.], [ 0., 3., 2.] ]), array([ [ 9.], [ 9.] ]), array([ [ 0., 4., 3., 0., 0., 6., 4., 4.], [ 6., 0., 4., 5., 7., 5., 1., 4.] ]) ] 官方文档链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"https://pandamin18436220.github.io/tags/numpy/"}]},{"title":"Argparse库","date":"2020-02-07T06:23:41.010Z","path":"2020/02/07/argparse库/","text":"Argparse的作用python中argparse库是一个命令行参数的解析工具，利用这个库可以在命令行运行脚本时，设置参数，从而灵活的设置脚本中需要的参数。下面总结一下argparse库的使用方法。简而言之: 学会了该库的基本使用，就不必再代码里修改参数！ Argparse的基本使用下面演示Argparse三个基本函数 创建parse对象（函数一） #导入argparse库 import argparse #创建对象 这里使用description参数，我们可以输入想要的提示信息。 parser = argparse.ArgumentParser(description=&apos;add some useful information here....&apos;) ArgumentParser对象保存了所有必要的信息，用于将命令行参数解析为相应的python数据类型。 添加参数信息（函数二） 创建了ArgumentParser对象之后，就可以使用add_argument()方法来添加参数,其输入参数如下，其中[]中的参数为可选参数，作用为设置参数的一些属性。 带 - 的为可选参数(optional parameter) 不带 - 的为必选参数(positional parametrer) ArgumentParser.add_argument(name or flags…[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest]) 下面总结一下，add_argument()方法中常用的一些属性 属性值 作用 type 指定参数存储时的类型，可为int、float、str等 action 参数的处理方法，在命令行遇到此参数时要采取的基本操作类型 nargs 参数的数量，应该使用的命令行参数的数量 const 参数的常量值，某些动作和选择所需的常量值 default 参数的默认值，如果命令行中不存在的参数，则生成的值 choices 参数的取值范围，参数允许值的范围 action 参数的处理方法，在命令行遇到此参数时要采取的基本操作类型 requires 参数是否可以忽略不写，进队可选参数有效 help 参数的说明信息，简单描述参数的作用 metavar 参数在说明信息usage(用法)中的名称，用法消息中的名称 dest 对象的属性名，要添加到返回值的对象的属性的名称 案例一: 12345678910import argparse# 创建解析对象, description是对其描述parser = argparse.ArgumentParser(description=\"测试使用 argparse 库\")# 向parser对象添加你要关注的命令行参数和选项, 这里的两个参数，一个为长参数：--parm1，一个为短参数:-p1parser.add_argument(\"--param1\", \"-p1\", type=str)# 对命令行参数进行解析args = parser.parse_args()print(args)# 输出具体的参数值print(args.param1) 案例二:12345678910111213import argparse# 创建解析对象, description是对其描述parser = argparse.ArgumentParser(description=\"测试使用 argparse 库\")# 向parser对象添加你要关注的命令行参数和选项, 这里的两个参数，一个为长参数：--parm1，一个为短参数:-p1parser.add_argument(\"--param1\", \"-p1\", type=str)parser.add_argument(\"--param2\", \"-p2\", type=int, help=\"参数2需要输入0~20整数\", choices=range(21))# 参数值为int型，传入多个值时，返回的是一个列表parser.add_argument(\"--param3\", \"-p3\", type=int, nargs=\"+\", help=\"list类型，可以接收1~n个值\")# 对命令行参数进行解析args = parser.parse_args()print(args)# 输出具体的参数值print(args.param1,\"\\n\", args.param2,\"\\n\", args.param3) 我们可以通过 --param1 来指定参数1， 也可以使用短参 -p1来指定参数1 add_argument的部分参数介绍如下： type: 指定类型 required: 参数是否必填，如果为True则必须要传入对应的值 help: python test.py -h 会出现对应help的内容 nargs: 指定这个参数后面的值有多少个，默认为1, 也可以写正则表达式符号：+(一个或者多个) , *(没有或者多个), 数字 choices: 设置参数的范围 解析参数(函数三)添加完参数后，最后调用parse_args()方法，将会返回一个命名空间(namespace)，之后我们就可以调用各个设置好的参数啦 def parse_arg(): parser = argparse.ArgumentParser(description=&apos;描述内容&apos;) parser.add_argument(&apos;--param1&apos;, type=int,help=&apos;add some helpful message here.&apos;) parser.add_argument(&apos;--param2&apos;, type=int) parser.add_argument(&apos;--param3&apos;, type=float) args = parser.parse_args() #命名空间namespace return args官方文档链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"Argparse","slug":"Argparse","permalink":"https://pandamin18436220.github.io/tags/Argparse/"}]},{"title":"OpenCv基本函数","date":"2020-02-05T07:38:15.137Z","path":"2020/02/05/opencv基本函数/","text":"本篇文章附有opencv的基本函数使用和基本操作代码 导入库-*- coding: utf-8 -*- import cv2 #opencv2库 import numpy as np #numpy库 import matplotlib.pyplot as plt #类似于matlab工具读入图像函数为：cv2.imread(文件名[,显示控制参数]) 返回值：一个图像 功能：读取图像 当显示控制参数为 1/cv2.IMREAD_UNCHANGED 不改变 0/cv2.IMREAD_GRAYSCALE 图像灰度 -1/cv2.IMREAD_COLOR 图像彩度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426 o=cv2.imread('C:\\\\Users\\\\Pandamin\\\\Desktop\\\\image\\\\1.jpg',0) ## 保存图像 函数为：cv2.imwrite(文件地址，文件名) 返回值：无 功能：保存图像## 访问像素 函数为：img[位置[,通道数]] 返回值：该位置的像素 功能：得到该位置的图像，也可以更改其值## 使用numpy访问像素 函数为：img.itemset((位置[,通道数]),设置像素值) 返回值：该位置的像素 功能：得到该位置的图像，也可以更改其值## 获取图像属性 函数为：cv2.shape 返回值：返回行数，列数[,通道数] 功能：略## 函数为：cv2.size 返回值：返回行数*列数[*通道数] 功能：略## 函数为：cv2.dtype 返回值：返回图像的数据类型(unit8) 功能：略## 感兴趣区域(截取图像img中200:400到200:400的像素) 函数为：face=img[200:400,200:400] 返回值：截取后的图像 功能：略## 通道拆分和合并 函数为：b,g,r=cv2.split(图像名) 返回值：该图像b,g,r三个通道值 功能：获取三个通道的值## 函数为：m=cv2.merge([b,g,r]) 返回值：三个通道合成后的图像 功能：略## 图像加法 函数为：cv2.add(a,b) 返回值：是将a,b图像的对应像素点%255得到加法之后的图像 功能：略## 图像融合 函数为：cv2.addWeighted(图像1，图像1的系数，图像2，图像2的系数，亮度调节值) 返回值：融合后的图像 功能：可以将将两个残缺图像(且残缺的位置不同),融合为一个完整图像## 类型转换 函数为：cv2.cvtColor(图像名,cv2.COLOR_BGR2RGB) 返回值：由BGR通道转化到RGB通道的图像 功能：略 函数为：cv2.cvtColor(图像名,cv2.COLOR_GRAY2BGR) 返回值：由灰度类型转化到BGR通道的图像## 图像缩放 函数为：cv2.resize(src[,dsize=None],fx,fy) 返回值：缩放后的图像 参数：dsize缩放大小(列，行)，如果dsize=None,则可以通过fx(水平),fy(垂直)去缩放 功能：略## 图像旋转 函数为：cv2.flip(src,flipCode) 返回值：旋转后的图像 flipCode&gt;0 返回以Y轴为对称旋转 flipCode=0 返回以x轴为对称旋转 flipCode&lt;0 返回以x,y轴同时翻转## 阈值分割 二进制阈值化 函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_BINARY) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为白色，暗的处理为黑色。## 反二进制阈值化 函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_BINARY_INV) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为黑色，暗的处理为白色。## 截断阈值化 函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_TRUNC) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为阈值，暗的处理为不变。## 反阈值化为0 函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_TOZERO_INV) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为黑色0，暗的处理为不变。## 阈值化为0 函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_TOZERO) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为不变，暗的处理为黑色。## 均值滤波 函数为：cv2.blur(src,核大小) 返回值：返回均值化后的图像(图像更加平滑) 参数：核大小是以宽度＆高度形式表示的元组 功能：使图像更加平滑## 方框滤波 函数为：cv2.boxFilter(src,目标图像深度,核大小[,normalize属性=1]) 返回值：处理后的图像 参数： 目标图像深度为int类型的目标图像深度，通常使用“-1”表示与原始图像一致 核大小：（n,n）表示有n列n行 normalize=true时，进行归一化处理,与均值滤波相同 normalize=false时，很容易溢出,像素值易大于255,得到白色的图像## 高斯滤波 函数为：GaussianBlur(src,ksize,sigmaX) 返回值：略 参数： ksize：为核大小(n,n),必须为奇数 sigmaX：X方向方差，控制权重，一般sigmaX=0,其会自动算一个方差## 中值滤波 函数为：cv2.medianBlur(src,ksize) 参数： ksize：必须为比1大的奇数且只要写一个数值n，不要写(n,n)## 图像腐蚀 函数为：cv2.erode(src,kernel[,iterations=1]) 参数： kernel为卷积核,np.ones((n,n),np.unit8), 通过numpy的ones函数生成n*n的数值，其类型为unit8的卷积核 iterations为迭代次数## 图像膨胀 函数为：cv2.dilate(src,kernel[,iterations=1]) 参数： kernel为卷积核,np.ones((n,n),np.unit8), 通过numpy的ones函数生成n*n的数值，其类型为unit8的卷积核 iterations为迭代次数## 开运算：先进行腐蚀操作+膨胀操作，其作用去除噪声并保持原有的形状 函数为：cv2.morphologyEx(img,cv2.MORPH_OPEN,kernel) 参数： cv2.MORPH_OPEN 开运算 kernel 卷积核## 闭运算：先进行膨胀+腐蚀操作，其作用去掉物体内的小黑点 函数为：cv2.morphologyEx(img,cv2.MORPH_CLOSE,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_CLOSE 闭运算 kernel 卷积核## 梯度运算：将一个图像分别进行膨胀，腐蚀操作并将其相减，得到轮廓信息 函数为：cv2.morphologyEx(img,cv2.MORPH_GRADIENT,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_GRADIENT 梯度运算 kernel 卷积核## 礼帽(顶帽)运算：礼帽图像=原图像-开运算图像(去除噪声)，得到噪声图像 函数为：cv2.morphologyEx(img,cv2.MORPH_TOPHAT,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_TOPHAT 礼帽运算 kernel 卷积核## 黑帽图像处理：黑帽图像=闭运算图像-元素图像，得到图像内部的小黑点 函数为：cv2.morphologyEx(img,cv2.MORPH_BLACKHAT,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_BLACKHAT 黑帽运算 kernel 卷积核## 计算图像梯度,寻找边界(左右像素值差=0不是边界，!=0为边界，对其结果取绝对值) sobel算子：|左-右|+|下-上| 函数为：cv2.Sobel(src,dddpth,dx,dy,[ksize]) 参数： dddpth：处理结果图像深度，通常情况下，可以设置为-1，表示与原图像的深度一致。 但是在计算的时候可能会出现负值，会发生信息丢失，所以需要更高的数据类型 即dddpth取cv2.CV_64F,取绝对值后，再转换为np.unit8类型 取绝对值通过cv2.convertScaleAbs(scr[,alpha[,beta]]) 其作用是将原始图像转化为256色位图 dx:计算x方向的边界[dx=1,dy=0] dy:计算y方向的边界[dx=0,dy=1] 通过函数cv2.addWeighted(sobel_dx，图像1的系数，sobel_dy，图像2的系数，亮度调节值) ksize=-1时，等价于Scharr算子 scharr算子：|左-右|+|下-上| 函数为：cv2.Scharr(src,cv2.CV_64F,dx,dy) dx:计算x方向的边界dx=Scharrx(src,ddpeth,dx=1,dy=0) dy:计算y方向的边界dy=Scharry(src,ddpeth,dx=0,dy=1) 通过函数cv2.addWeighted(dx，图像1的系数，dy，图像2的系数，亮度调节值) ##且要满足dx&gt;=0&amp;&amp;dy&gt;=0&amp;&amp;&amp;dx+dy==1 参数值：略 拉普拉斯算子：|左-右|+|左-右|+|下-上|+|下-上| 函数为：cv2.Laplacian(src,dddpth) 即dddpth取cv2.CV_64F,取绝对值后，再转换为np.unit8类型 取绝对值通过cv2.convertScaleAbs(scr[,alpha[,beta]]) 其作用是将原始图像转化为256色位图 参数值：略## canny边缘检测 函数为：cv2.Canny(src,阈值1,阈值2) 参数值：阈值1minVal,阈值2maxVal,两个阈值是来控制边界信息的丰富程度的， 阈值越小得到图像的边界越丰富，越细致## 图像金字塔 pyrDown(图像向下取样，变成原来的1/4)，pyrUp(图像向下取样，变成原来4倍) 函数为：cv2.pyrDown(src) cv2.pyrUp(src) 参数值：略 取样可逆性研究：经过放到缩小图像是否不变？不一样，图像的清晰度变差## 拉普拉斯金字塔 函数为：Li=Gi-PyrUp(PyrDown(Gi)) 参数值：Gi原始图像，Li拉普拉斯图像 例如： od=cv2.pyrDown(o) odu=cv2.pyrUp(od) lapPyr=o-odu 拉普拉斯金字塔图像第0层 o1=od o1d=cv2.pyrDown(o1) o1du=cv2.pyrUp(o1d) lapPyr1=o1-o1du 拉普拉斯金字塔图像第1层 即拉普拉斯图像+向下取样图像=原始图像## 计算轮廓的面积 函数为：cv2.contourArea(cnt， True) 参数值：cnt为输入的单个轮廓值## 计算轮廓的周长 函数为：cv2.arcLength(cnt， True) 参数值：cnt为输入的单个轮廓值## 用于获得轮廓的近似值，使用cv2.drawCountors进行画图操作 函数为：cv2.aprroxPolyDP(cnt, epsilon， True) 参数值：cnt为输入的轮廓值， epsilon为阈值T，通常使用轮廓的周长作为阈值，True表示的是轮廓是闭合的## 获得外接矩形 函数为：x, y, w, h = cv2.boudingrect(cnt) 参数值：x，y, w, h 分别表示外接矩形的x轴和y轴的坐标，以及矩形的宽和高， cnt表示输入的轮廓值## 生成最小外接矩形 函数为：cv2.minAreaRect(cnt) 参数为：cnt为输入的轮廓值。[是点集数组或向量（里面存放的是点的坐标），并且这个点集中的元素不定个数。] 返回值：返回一个Box2D结构rect:（rect[0]中心(x,y), (rect[1][0]宽,rect[1][1]高),rect[2]旋转角度）## 根据坐标在图像上画出矩形 函数为：cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2) 参数值: img表示传入的图片， (x, y)表示左上角的位置, （x+w， y+h）表示加上右下角的位置，（0, 255, 0)表示颜色，2表示线条的粗细## 获得外接圆的位置信息 函数为：(x, y), radius = cv2.minEnclosingCircle(cnt) 参数值: (x, y)表示外接圆的圆心，radius表示外接圆的半径， cnt表示输入的轮廓## 根据坐标在图上画出圆 函数为：cv2.Cricle(img, center, radius, (0, 255, 0), 2) 参数值:img表示需要画的图片，center表示圆的中心点，radius表示圆的半径, (0, 255, 0)表示颜色， 2表示线条的粗细## 查找检测物体的轮廓 函数为：cv2.findContours(image, mode, method[, contours[, hierarchy[, offset ]]]) 参数值： 第一个参数是寻找轮廓的图像；二值图像 第二个参数表示轮廓的检索模式，有四种（本文介绍的都是新的cv2接口）： cv2.RETR_EXTERNAL表示只检测外轮廓 cv2.RETR_LIST检测的轮廓不建立等级关系 cv2.RETR_CCOMP建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。 cv2.RETR_TREE建立一个等级树结构的轮廓。 第三个参数method为轮廓的近似办法 cv2.CHAIN_APPROX_NONE存储所有的轮廓点，相邻的两个点的像素位置差不超过1，即max（abs（x1-x2），abs（y2-y1））==1 cv2.CHAIN_APPROX_SIMPLE压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息 cv2.CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法 返回值： 一个是轮廓本身，还有一个是每条轮廓对应的属性， 可返回一个可选的hiararchy结果。[这是一个ndarray，其中的元素个数和轮廓个数相同; 每个轮廓contours[i]对应4个hierarchy元素hierarchy[i][0] ~hierarchy[i][3]; 分别表示后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号，如果没有对应项，则该值为负数] （返回一个list，list中每个元素都是图像中的一个轮廓，用numpy中的ndarray表示）## 图像轮廓：边界与轮廓的区别，轮廓是指连续的边界 函数为:cv2.drawContours(src,contours,contourldx,color[,thickness]) 参数值： contours：需要绘制的边缘数组 contourldx:需要绘制的边缘索引，如果全部绘制为-1 color:绘制的颜色，为BGR格式的Scalar thinckness:绘制的密度，即轮廓画笔的粗细## 绘制直方图 函数为：plt.hist(src.ravel(),256) 参数值：将src转化为一维数组 像素级一般为256,为八位的图像的灰度级：[0,255]## 使用Opencv统计直方图 函数为：hist=cv2.calcHist(images,channels,mask,histSize,ranges[,accumulate]) 通过函数plt.plot(hist，color='g/b/r')绘制出来 参数值： images:原始图像 channels：指定通道 mask：掩码图像，统计整幅图像的直方图为None histSize：BINS的数量,一般为[256]--灰度图像 ranges：像素值范围RANGE，一般为[0,255] accumulate:累计标识 返回值：返回一个直方图hist## 使用掩码直方图：先通过zeros生成全黑图像，在截取相应区域为白色 函数为：mask=np.zeros(src.shape,np.unit8) mask[200:400,200:400]=255 参数值：src.shape元素图像的大小，np.unit8为八位的位图 返回值：略## 直方图均值化原理：色彩的细节更加丰富 函数为：equ=cv2.qualizeHist(src) 参数值：略 返回值：略## subplot函数：一个窗口显示多个图像 函数为：plt.subplot(n行,n列,窗口序列) 例如：plt.subplot(121),plt.hist(img.ravel(),256) plt.subplot(122),plt.hist(img.ravel(),256) 函数为：imshow(x,cmap=None) 参数值：x为需要绘制的图像 cmap为颜色图谱，默认为RGB(A)颜色空间 若要显示灰度图像：cmap=plt.cm,gray 若雅显示彩色图像:如果是通过python读进来的，则不需要处理RGB 如果是通过opencv读进来的，则其默认BGR,要调整色彩空间 使用默认值，显示彩色图像 plt.subplot(221) plt.imshow(scr_color),plt.axis('off')## 使用gray参数，显示彩色图像 plt.subplot(222) plt.imshow(src_color,cmap=plt.cm.gray),plt.axis('off')## 使用默认值，显示彩色度图像 plt.subplot(223) plt.imshow(src_gray),plt.axis('off')## 使用gray参数，显示灰度图像【灰度图像+灰度类型才可以显示灰度图像】 plt.subplot(224) plt.imshow(src_gray,cmap=plt.cm.gray),plt.axis('off')#设置直方图没有坐标## 傅里叶变换 函数为：f=np.fft.fft2(src) 返回值：返回一个复数的数组## 移动到中心位置：将零频率分量移动到频谱中心 函数为：fshift=np.fft.fftshift(f) 将复数数组转化为灰度图像--&gt;20*np.log(np.abs(fshift))设置频谱的范围## 逆傅里叶变换 函数为：ifshift=np.fft.ifftshift(f) iimg=np.fft.ifft2(ishift) iimg=np.abs(iimg)## 显示图像，删除所有窗口 函数为：cv2.imshow(窗口名，图像名) cv2.waitKey([,delay]) cv2.destroyAllWindows() 参数值： delay: delay&gt;0 等待delay毫秒 delay&lt;0 等待键盘单击 delay=0 无限等待## 参考代码一-- coding: utf-8 --import cv2 #opencv2库import numpy as npimport time#读取图片o=cv2.imread(‘C:/Users/Pandamin/Desktop/img/1.jpg’,1)#o1=cv2.imread(‘C:/Users/Pandamin/Desktop/img/1.jpg’,0)#cv2.imshow(‘src’,o)#cv2.imshow(‘src1’,o1)‘’’frameWidth=o[0]frameHeight=o[1]frameChannels=o[2]frameArray=np.frombuffer(o[6],dtype=np.unit8).reshape([frameHeight,frameWidth,frameChannels])‘’’#转化成HSVhue_image = cv2.cvtColor(o, cv2.COLOR_BGR2HSV)#cv2.imshow(‘hue_image’, hue_image) #双阈值化处理low_range = np.array([160, 83, 100])high_range = np.array([180, 255, 255])#OpenCV中的inRange()函数可实现二值化功能（这点类似threshold()函数）#更关键的是可以同时针对多通道进行操作，使用起来非常方便！#将两阈值范围内的设置为白色，不在的设置为黑色,具有双阈值化操作th = cv2.inRange(hue_image, low_range, high_range)#cv2.imshow(‘HSV_hueimgae’, th)#th = cv2.inRange(o, low_range, high_range)#cv2.imshow(‘HSV_o’, th) #二进制阈值化处理(只能够将大于阈值的显示白色，小于阈值的显示黑色，前提是灰度图像)#r,b=cv2.threshold(hue_image,127,255,cv2.THRESH_BINARY)#cv2.imshow(‘threshold_hue’, b)r,b=cv2.threshold(th,127,255,cv2.THRESH_BINARY)cv2.imshow(‘threshold_o’, b) 平滑处理gaus=cv2.GaussianBlur(th,(7,7),1.5)#cv2.imshow(‘result’, gaus)‘’’ 腐蚀eroded = cv2.erode(gaus, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (4, 4)), iterations=2)cv2.imshow(‘result腐蚀’, eroded) 膨胀dilated = cv2.dilate(eroded, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3)), iterations=2)cv2.imshow(‘result膨胀’, dilated)‘’’#开运算kernel=np.ones((5,5))openA=cv2.morphologyEx(gaus,cv2.MORPH_OPEN,kernel)cv2.imshow(‘open’, openA) #梯度运算openA=cv2.Canny(openA,30,100)cv2.imshow(‘open1’, openA) Hough Circle‘’’cv2.HoughCircles(image,method,dp,minDist[, circles[,param1, param2[,minRadius[,maxRadius]]]]])image 不用多说，输入矩阵method cv2.HOUGH_GRADIENT 也就是霍夫圆检测，梯度法dp 计数器的分辨率图像像素分辨率与参数空间分辨率的比值（官方文档上写的是图像分辨率与累加器分辨率的比值，它把参数空间认为是一个累加器，毕竟里面存储的都是经过的像素点的数量），dp=1，则参数空间与图像像素空间（分辨率）一样大，dp=2，参数空间的分辨率只有像素空间的一半大minDist 圆心之间最小距离，如果距离太小，会产生很多相交的圆，如果距离太大，则会漏掉正确的圆param1 canny检测的双阈值中的高阈值，低阈值是它的一半param2 最小投票数（基于圆心的投票数）minRadius 需要检测圆的最小半径maxRadius 需要检测圆的最大半径‘’’circles = cv2.HoughCircles(openA, cv2.HOUGH_GRADIENT, 1, 60, param1=15, param2=7, minRadius=5, maxRadius=50) 绘制if circles is not None: for x,y,radius in circles[0]: #x, y, radius = circles[0][0] center = (x, y) cv2.circle(o, center, radius, (0, 255, 0), 2)‘’’#从图像中底部往上跨越，找到相邻2像素且在中心的红色，并标志（此处可以添加误差，以减少寻找时间）for i in range(476,0,-2): if b[i][320]!=0 and b[i+2][320]!=0: cv2.line(img,(0,i),(640,i),(255,255,0),2) flag=1 break‘’’cv2.imshow(‘result’, o)cv2.waitKey()cv2.destroyAllWindows() 12## 参考代码二 import cv2import numpy as np def cv_show(img, name): cv2.imshow(name, img) cv2.waitKey(0) cv2.destroyAllWindows() 第一步读入图片img = cv2.imread(‘car.png’) 第二步：对图片做灰度变化gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) 第三步：对图片做二值变化ret, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY) 第四步：获得图片的轮廓值Binary, contours, h = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) 第五步：在图片中画出图片的轮廓值draw_img = img.copy()ret = cv2.drawContours(draw_img, contours, -1, (0, 0, 255), 2) 第六步：画出带有轮廓的原始图片cv_show(ret, ‘ret’) 使用另外一个图进行轮廓的测试第一步：载入图片，灰度化和二值化处理,使用cv2.findContours找出轮廓, 使用cv2.drawContours进行画图操作img = cv2.imread(‘contours.png’)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)ret, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY) binary, contours, h = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) draw_img = img.copy() 参数说明,draw_img 需要作图的原始图像， contours表示轮廓， 0表示轮廓索引， (0, 0, 255)表示颜色， 2表示线条粗细ret = cv2.drawContours(draw_img, contours, 0, (0, 0, 255), 2)cv_show(ret, ‘ret’) 取出单个的轮廓值cnt = contours[0] 第二步：计算轮廓的面积area = cv2.contourArea(cnt) 第三步： 计算轮廓的周长length= cv2.arcLength(cnt, True) print(area, length) 轮廓近似img = cv2.imread(‘contours2.png’)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)ret, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY) Binary, contours, h = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) cnt = contours[0] 使用周长的倍数作为阈值，阈值越小，图像的轮廓近似与轮廓越近似epsilon = 0.1 * cv2.arcLength(cnt, True) approx = cv2.approxPolyDP(cnt, epsilon, True) draw_img = img.copy()ret = cv2.drawContours(draw_img, [approx], -1, (0, 0, 255), 2)cv_show(ret, ‘ret’) 外接矩阵img = cv2.imread(‘contours.png’)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)res, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY) binary, contours, h = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) cnt = contours[0] x, y, w, h = cv2.boundingRect(cnt) ret = cv2.rectangle(img, (x, y), (x+w, y+h), (0, 0, 255), 2)cv_show(ret, ‘ret’) print(‘矩形面积 / 外接矩形面积’, cv2.contourArea(cnt) / (w*h)) 外接圆(x, y), radius = cv2.minEnclosingCircle(cnt)center = (int(x), int(y))radius = int(radius)ret = cv2.circle(ret, center, radius, (0, 255, 0), 2)cv_show(ret, ‘ret’)```","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"OpenCv","slug":"OpenCv","permalink":"https://pandamin18436220.github.io/tags/OpenCv/"}]},{"title":"Markdown的基本使用","date":"2020-02-04T05:53:24.883Z","path":"2020/02/04/Markdowm的基本使用/","text":"二级标题 粗体文本 斜体文本 粗斜体文本 * 无序列表 有序列表 你好(前面有四个空格/Tab) 用&gt;表示区块 二级区块 1表示代码部分使用链接 表头 表头 表头 表头 表头 表头","comments":true,"tags":[{"name":"Markdowm","slug":"Markdowm","permalink":"https://pandamin18436220.github.io/tags/Markdowm/"}]}]