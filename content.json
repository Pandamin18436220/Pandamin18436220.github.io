[{"title":"世界怎么了","date":"2020-02-07T13:15:03.511Z","path":"2020/02/07/随笔录之世界怎么了/","text":"大爱无疆，生死不在话下。拥有大爱和超出常人气魄胆量的人，如今都在疫情的一线用性命去和病毒搏斗，他们不是没有家人没有眼泪没有恐惧没有情绪，更不是因为他们有九条命。而是他们不仅仅只爱眼下围城里的专属物品，亲人、朋友。他们越过了所有人认知里的小世界，还爱着安全疆域之外的陌生人，所有的陌生人加起来就是祖国、是全人类，再大一点，其实可以说是动物世界。 如今只要是躺在病床上的无论黑发碧眼高矮胖瘦，温柔求救或是出言不逊口吐芬芳，被人抓着脖颈歇斯底里辱骂害怕到发抖也都会去医治挽救。我们常说救人是医生该做的事，但没有说冒着搭进自己性命的危险也是该做的事。如果我们仍口口声声说他们是在上班，那不好意思，班是可以请假的，更可以离职，换一个班上。在所有的危难时刻里挺身而出的职业都不算做是职业，而是人类的帕修斯。 只有爱能给人带来无边的勇气，忘却生死和利益。那一刻他们不是活在某一个城市，而是活在了宇宙中心，他们似乎比我们高了好几个维度，夏虫不可语于冰。只有看到他们抽出3分钟吃顿饭的时候才恍惚觉得他们不是神。 小爱围城，生死是头等大事。每个家庭就是一个小围城。我们都在汲汲营营的生存，在这一隅天地里付出自己的爱得到对方的情。我们思考的事情是如何让围城里的人能够过得更好，不至于死的太快或太惨。围城外的人是我们的攀比对象，也是我们成败的见证对象。我们可能会活的有些自私，我们可能只帮自己人。 无爱恶魔，混迹人间。有些“人”，甚至连自己围城里的人或物都不爱，具体能有多不爱，要看情势有多严峻，把他们逼到什么地步。因为还是不能杀人的，如果可以，我猜他们应该会建议一把火把病毒区连人带房都烧了，别怪我为什么这样猜测，当谣言说猫狗会传染后第一时间就是将它们丢弃或弄死。和谁的情都是情，和人是，和动物更是。我们爱自己的宠物，就是真心爱着，是自己人。只有虚假的感情才能瞬间去裁决生死，因为不会让自己伤心，他们根本就没有心。 我很难过在这样特殊情况下的很多事情。难过所有被连累逝去的生命；难过所有无法休息拿命搏斗的人；难过一座美丽的城市却成了恐慌的代名词。 自私一点的难过是，爱的人过家门而不能入，一句想念隔了几千公里。我很难过无法见你这件事。而越是危难时刻，我愈发想见你。 都在说疫情过后要如何如何，疫情过后我只想珍惜你和我的生命，做一对快乐的夏虫。 然而压死骆驼的稻草也似乎永远都不止一根，多少男孩心目中的神也的确回到了天堂。科比坠机的那天不知道又有多少眼泪在横飞。 我们为什么会这样的揪心难过，因为他是一代人的青春，是过去我们存活激情时刻留下的生命印证，从篮球连带着想起那些岁月，篮球场、汗流浃背的身影、看我们打球的姑娘、发疯般追过的曼巴精神，这些会让我们恍然隔世，原来我们曾那样活过啊！失去他，就好像失去了生命的一部分。始于科比的篮球，终于凌晨四点的洛杉矶。 理论是灰色的，生命之树常青。这是李文亮医生是微信签名。从他被处分，感染到平反。他说了实话，说了很多人不敢说的话。但却得到了不相称的惩罚！同一天，他的核酸检测结果出来了，阳性。他说：尘埃落定，终于确诊了，还配了个狗狗的表情。他在病房里看到许多网友的鼓励，在微博上感谢大家：谢谢大家的支持，我没有被吊销执照，请大家放心，我一定积极配合治疗，争取早日出院。再之前，工作群里号召医生们报名到防疫一线时，他还说了一句：我好了也报名。但他却被宣告死亡… 澳大利亚大火，应该给人类和这个星球留下哪些教训？因为人广地稀，所以死亡的人员并不多（但也至少28人死亡）。不过造成了极大的生态灾难：至少10亿只动物丧生火海。这么多的野生动物被烧死，对本来就相对脆弱的澳洲生态系统一定会造成难以弥补的损害。从去年9月开始，澳大利亚的山火已经整整燃烧了四个多月，迄今仍未看到熄灭的迹象。 美国流感疫情严重，据报道，今年美国的流感季相对往年不仅来得早，而且爆发速度快快，流感最先在东南部数州出现后迅速扩散，迄今没有减缓的迹象。包括南方地区、西部的部分地区、纽约市和华盛顿，现流感已扩散至46个州。 这些天的足不出户，让我发了足够久的呆，我思考着这一切，不知该拿什么心情收场。人类的悲欢在此刻是相通的吧，我想。","comments":true,"tags":[{"name":"随笔录","slug":"随笔录","permalink":"https://pandamin18436220.github.io/tags/%E9%9A%8F%E7%AC%94%E5%BD%95/"}]},{"title":"PIL库","date":"2020-02-07T12:41:48.226Z","path":"2020/02/07/python的PIL库/","text":"PIL的作用sys模块主要是针对与Python解释器相关的变量和方法，不是主机操作系统。 sys函数 作用 sys.argv 获取命令行参数列表，第一个元素是程序本身 sys.exit(n) 退出Python程序，exit(0)表示正常退出。当参数非0时，会引发一个SystemExit异常，可以在程序中捕获该异常 sys.version 获取Python解释程器的版本信息 sys.maxsize 最大的Int值，64位平台是2**63 - 1 sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.platform 返回操作系统平台名称 sys.stdin 输入相关 sys.stdout 输出相关 sys.stderr 错误相关 sys.exc_info() 返回异常信息三元元组 sys.getdefaultencoding() 获取系统当前编码，默认为utf-8 sys.setdefaultencoding() 设置系统的默认编码 sys.getfilesystemencoding() 获取文件系统使用编码方式，默认是utf-8 sys.modules 以字典的形式返回所有当前Python环境中已经导入的模块 sys.builtin_module_names 返回一个列表，包含所有已经编译到Python解释器里的模块的名字 sys.copyright 当前Python的版权信息 sys.flags 命令行标识状态信息列表。只读。 sys.getrefcount(object) 返回对象的引用数量 sys.getrecursionlimit() 返回Python最大递归深度，默认1000 sys.getsizeof(object[, default]) 返回对象的大小 sys.getswitchinterval() 返回线程切换时间间隔，默认0.005秒 sys.setswitchinterval(interval) 设置线程切换的时间间隔，单位秒 sys.getwindowsversion() 返回当前windwos系统的版本信息 sys.hash_info 返回Python默认的哈希方法的参数 sys.implementation 当前正在运行的Python解释器的具体实现，比如CPython sys.thread_info 当前线程信息 官方文档链接 https://blog.csdn.net/zhangziju/article/details/79123275 https://blog.csdn.net/on_theway10/article/details/91814197","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"PIL","slug":"PIL","permalink":"https://pandamin18436220.github.io/tags/PIL/"}]},{"title":"sys库","date":"2020-02-07T12:02:38.353Z","path":"2020/02/07/python的sys库/","text":"sys的作用sys模块主要是针对与Python解释器相关的变量和方法，不是主机操作系统。 sys函数 作用 sys.argv 获取命令行参数列表，第一个元素是程序本身 sys.exit(n) 退出Python程序，exit(0)表示正常退出。当参数非0时，会引发一个SystemExit异常，可以在程序中捕获该异常 sys.version 获取Python解释程器的版本信息 sys.maxsize 最大的Int值，64位平台是2**63 - 1 sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.platform 返回操作系统平台名称 sys.stdin 输入相关 sys.stdout 输出相关 sys.stderr 错误相关 sys.exc_info() 返回异常信息三元元组 sys.getdefaultencoding() 获取系统当前编码，默认为utf-8 sys.setdefaultencoding() 设置系统的默认编码 sys.getfilesystemencoding() 获取文件系统使用编码方式，默认是utf-8 sys.modules 以字典的形式返回所有当前Python环境中已经导入的模块 sys.builtin_module_names 返回一个列表，包含所有已经编译到Python解释器里的模块的名字 sys.copyright 当前Python的版权信息 sys.flags 命令行标识状态信息列表。只读。 sys.getrefcount(object) 返回对象的引用数量 sys.getrecursionlimit() 返回Python最大递归深度，默认1000 sys.getsizeof(object[, default]) 返回对象的大小 sys.getswitchinterval() 返回线程切换时间间隔，默认0.005秒 sys.setswitchinterval(interval) 设置线程切换的时间间隔，单位秒 sys.getwindowsversion() 返回当前windwos系统的版本信息 sys.hash_info 返回Python默认的哈希方法的参数 sys.implementation 当前正在运行的Python解释器的具体实现，比如CPython sys.thread_info 当前线程信息 官方文档链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"sys","slug":"sys","permalink":"https://pandamin18436220.github.io/tags/sys/"}]},{"title":"OS库","date":"2020-02-07T11:36:01.637Z","path":"2020/02/07/python的os库/","text":"OS的作用OS模块提供了一些方便使用操作系统相关功能的函数。 OS函数 作用 os.sep 取代操作系统特定的路径分隔符 os.name 指示你正在使用的工作平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’。 os.getcwd 得到当前工作目录，即当前python脚本工作的目录路径。 os.getenv()和os.putenv() 分别用来读取和设置环境变量 os.listdir() 返回指定目录下的所有文件和目录名 os.remove(file) 删除一个文件 os.stat（file） 获得文件属性 os.chmod(file) 修改文件权限和时间戳 os.mkdir(name) 创建目录 os.rmdir(name) 删除目录 os.removedirs（r“c：\\python”） 删除多个目录 os.system() 运行shell命令 os.exit() 终止当前进程 os.linesep 给出当前平台的行终止符。例如，Windows使用’\\r\\n’，Linux使用’\\n’而Mac使用’\\r’ os.path.split() 返回一个路径的目录名和文件名 os.path.isfile()和os.path.isdir() 分别检验给出的路径是一个目录还是文件 os.path.existe() 检验给出的路径是否真的存在 os.listdir(dirname) 列出dirname下的目录和文件 os.getcwd() 获得当前工作目录 os.curdir 返回当前目录（’.’） os.chdir(dirname) 改变工作目录到dirname os.path.isdir(name): 判断name是不是目录，不是目录就返回false os.path.isfile(name) 判断name这个文件是否存在，不存在返回false os.path.exists(name) 判断是否存在文件或目录name os.path.getsize(name) 或得文件大小，如果name是目录返回0L os.path.abspath(name) 获得绝对路径 os.path.isabs() 判断是否为绝对路径 os.path.normpath(path) 规范path字符串形式 os.path.split(name) 分割文件名与目录（事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在） os.path.splitext() 分离文件名和扩展名 os.path.join(path,name) 连接目录与文件名或目录 os.path.basename(path) 返回文件名 os.path.dirname(path) 返回文件路径 官方文档链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"OS","slug":"OS","permalink":"https://pandamin18436220.github.io/tags/OS/"}]},{"title":"Numpy库","date":"2020-02-07T08:33:20.147Z","path":"2020/02/07/python的numpy库/","text":"Numpy的作用Numpy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。 Numpy库与数组的区别python中可以使用列表保存一组值，可将列表当数组使用。另外，python中有array模块，但它不支持多维数组。所以无论是列表还是array模块都没有科学运算函数，不适合做矩阵等科学计算。 numpy没有使用python本身的数组机制，而是提供了ndarray对象，该对象不仅能方便地存取数组，而且拥有丰富的数组计算函数。Numpy的基本使用下面介绍Numpy的基础知识与相关函数 创建数组及使用 12345678910111213141516171819202122232425262728#定义了一个二维数组，大小为（2，3）&gt;&gt;&gt; x=np.array([ [1.0,0.0,0.0], [0.,1.,2.] ])&gt;&gt;&gt; xarray([[1., 0., 0.], [0., 1., 2.]])#数组维度数&gt;&gt;&gt; x.ndim2#数组的维数，返回的格式(n,m),其中n为行数，m为列数&gt;&gt;&gt; x.shape(2, 3)#数组元素的总数&gt;&gt;&gt; x.size6#数组元素类型&gt;&gt;&gt; x.dtype#64位浮点型dtype('float64')#每个元素占有的字节大小 &gt;&gt;&gt; x.itemsize 8#数组元素的缓冲区&gt;&gt;&gt; x.data&lt;memory at 0x00000205227DAC18&gt; 知识点扩展: 创建序列数组的函数arrange和linspace。（range函数类似） arange(a,b,c) 参数表示(开始值，结束值，步长) linspace(a,b,c) 参数表示(开始值，结束值，元素数量) 调用reshape()可以指定形状 123456789101112&gt;&gt;&gt; arange(6).reshape(2,3)array([ [ 0, 1, 2], [ 3, 4, 5], [10, 11, 12] ])&gt;&gt;&gt; arange(1,5,2) array([1, 3, 5])&gt;&gt;&gt; arange(0,1,0.5) array([0. , 0.5, 1])&gt;&gt;&gt; linspace(0,2,9) array([0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) 特殊数组 zeros数组：全零数组，元素全为零。 ones数组：全1数组，元素全为1。 empty数组：空数组，元素全近似为0。 1234567891011121314151617181920212223242526&gt;&gt;&gt; zeros((3,4)) array([ [0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.] ])&gt;&gt;&gt; ones((2,3,4),dtype=int16) array([ [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ], [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] ], dtype=int16)&gt;&gt;&gt; empty((5,3)) array([ [6.23042070e-307, 1.42417221e-306, 1.37961641e-306], [1.11261027e-306, 1.11261502e-306, 1.42410839e-306], [7.56597770e-307, 6.23059726e-307, 1.42419530e-306], [7.56599128e-307, 1.11260144e-306, 6.89812281e-307], [2.22522596e-306, 2.22522596e-306, 2.56761491e-312] ]) 数组索引 Numpy数组通过索引访问12345678910111213141516171819&gt;&gt;&gt; c=arange(24).reshape(2,3,4)&gt;&gt;&gt; print(c)[ [ [ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] ] [ [12 13 14 15] [16 17 18 19] [20 21 22 23] ]]&gt;&gt;&gt; print(c[1,2,:]) [20 21 22 23]&gt;&gt;&gt; print(c[0,1,2]) 6 数组运算 数组的加减乘除以及乘方运算方式为:相应位置的元素分别进行运算。12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; a=array([20,30,40,50])&gt;&gt;&gt; aa=arange(1,5)&gt;&gt;&gt; a/aa array([20. , 15. , 13.33333333, 12.5 ])&gt;&gt;&gt; b=arange(4)&gt;&gt;&gt; b array([0, 1, 2, 3])&gt;&gt;&gt; c=a-b&gt;&gt;&gt; c array([20, 29, 38, 47])&gt;&gt;&gt; b**2 array([0, 1, 4, 9], dtype=int32)&gt;&gt;&gt; A=array([ [1,1], [0,1] ])&gt;&gt;&gt; B=array([ [2,0], [3,4] ])&gt;&gt;&gt; A*B array([ [2, 0], [0, 4] ])&gt;&gt;&gt; A.sum() 3&gt;&gt;&gt; A.min() 0&gt;&gt;&gt; A.max() 1 数组的拷贝 拷贝有浅拷贝和深拷贝两种; 浅拷贝通过数组变量的赋值完成,浅拷贝只拷贝数组的引用，如果对拷贝进行修改，源数组也将修改; 深拷贝使用数组对象的copy方法，会复制一份和源数组一样的数组，新数组与源数组会存放在不同内存位置，因此对新数组的修改不会影响源数组。 案例一(浅拷贝)1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; a=ones((2,3))&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 1.] ])&gt;&gt;&gt; b=a&gt;&gt;&gt; b[1,2]=2&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 2.] ])&gt;&gt;&gt; b array([ [1., 1., 1.], [1., 1., 2.] ])案例二(深拷贝)&gt;&gt;&gt; a=ones((2,3))&gt;&gt;&gt; b=a.copy()&gt;&gt;&gt; b[1,2]=2&gt;&gt;&gt; a array([ [1., 1., 1.], [1., 1., 1.] ])&gt;&gt;&gt; b array([ [1., 1., 1.], [1., 1., 2.] ]) 创建矩阵 矩阵与数组的区别Numpy的矩阵对象与数组对象相似。其不同之处在于，矩阵对象的计算遵循矩阵数学运算律。矩阵使用matrix函数创建。1234567891011121314151617&gt;&gt;&gt; A=matrix('1.0 2.0;3.0 4.0')&gt;&gt;&gt; A matrix([ [1., 2.], [3., 4.] ])&gt;&gt;&gt; B=matrix([ [1.0,2.0], [3.0,4.0] ])&gt;&gt;&gt; B matrix([ [1., 2.], [3., 4.] ])&gt;&gt;&gt; type(A) &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt; 矩阵运算 123456789101112131415161718&gt;&gt;&gt; A.T #转置 matrix([ [1., 3.], [2., 4.] ])&gt;&gt;&gt; x=matrix('5.0 7.0')&gt;&gt;&gt; y=x.T&gt;&gt;&gt; y matrix([ [5.], [7.] ])&gt;&gt;&gt; print(A*y) #矩阵乘法 [[26.] [38.]]&gt;&gt;&gt; print(A.I) #逆矩阵 [[-2. 1. ] [ 1.5 -0.5]] Numpy线性代数相关函数 numpy.dot() 此函数返回两个数组的点积。 对于二维向量，其等效于矩阵乘法。 对于一维数组，它是向量的内积。 对于 N 维数组，它是a的最后一个轴上的和与b的倒数第二个轴的乘积。 12345&gt;&gt;&gt; a=np.array([[1,2],[3,4]])&gt;&gt;&gt; b=np.array([[11,12],[13,14]])&gt;&gt;&gt; np.dot(a,b) array([[37, 40], #[[1*11+2*13, 1*12+2*14],[3*11+4*13, 3*12+4*14]] [85, 92]]) numpy.vdot() 此函数返回两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数id是多维数组，它会被展开。 12&gt;&gt;&gt; np.vdot(a,b) 130 #1*11+2*12+3*13+4*14=130 numpy.inner() 此函数返回一维数组的向量内积。 对于更高的维度，它返回最后一个轴上的和的乘积。 1234&gt;&gt;&gt; x=np.array([1,2,3])&gt;&gt;&gt; y=np.array([0,1,0])&gt;&gt;&gt; print(np.inner(x,y)) 2 # 等价于 1*0+2*1+3*0 numpy.matmul() 函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。 另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。 #对二维数组（列表），就相当于矩阵乘法 123456789101112131415161718192021&gt;&gt;&gt; a=[[1,0],[0,1]]&gt;&gt;&gt; b=[[4,1],[2,2]]&gt;&gt;&gt; print(np.matmul(a,b))[[4 1][2 2]]#二维和一维运算&gt;&gt;&gt; a=[[1,0],[0,1]]&gt;&gt;&gt; b=[1,2]&gt;&gt;&gt; print(np.matmul(a,b)) [1 2]&gt;&gt;&gt; print(np.matmul(b,a)) [1 2]#维度大于2的&gt;&gt;&gt; a=np.arange(8).reshape(2,2,2)&gt;&gt;&gt; b=np.arange(4).reshape(2,2)&gt;&gt;&gt; print(np.matmul(a,b)) [[[ 2 3] [ 6 11]] [[10 19] [14 27]]] numpy.linalg.det() 行列式在线性代数中是非常有用的值。 它从方阵的对角元素计算。 对于 2×2 矩阵，它是左上和右下元素的乘积与其他两个的乘积的差。 换句话说，对于矩阵[[a，b]，[c，d]]，行列式计算为ad-bc。 较大的方阵被认为是 2×2 矩阵的组合。 numpy.linalg.det()函数计算输入矩阵的行列式。 123456789101112&gt;&gt;&gt; a=np.array([[1,2],[3,4]])&gt;&gt;&gt; print(np.linalg.det(a)) -2.0000000000000004&gt;&gt;&gt; b=np.array([[6,1,1],[4,-2,5],[2,8,7]])&gt;&gt;&gt; print(b) [[ 6 1 1] [ 4 -2 5] [ 2 8 7]]&gt;&gt;&gt; print(np.linalg.det(b)) -306.0&gt;&gt;&gt; print(6*(-2*7-5*8)-1*(4*7-5*2)+(4*8- -2*2)) -306 numpy.linalg.solve() 该函数给出了矩阵形式的线性方程的解。 1234567891011121314151617181920212223&gt;&gt;&gt; x=np.array([[1,2],[3,4]])&gt;&gt;&gt; y=np.linalg.inv(x)&gt;&gt;&gt; x array([[1, 2], [3, 4]])&gt;&gt;&gt; y array([[-2. , 1. ], [ 1.5, -0.5]])&gt;&gt;&gt; np.dot(x,y) array([[1.0000000e+00, 0.0000000e+00], [8.8817842e-16, 1.0000000e+00]]) a=np.array([[1,1,1],[0,2,5],[2,5,-1]]) print('数组a:') print(a) ainv=np.linalg.inv(a) print('a的逆矩阵') print(ainv) print('矩阵b:') b=np.array([[6],[-4],[27]]) print(b) print('计算：A^(-1)B:') x=np.linalg.solve(a,b) print(x) 数组分割 使用hsplit你能将数组沿着它的Y轴分割，或者指定返回相同形状数组的个数，或者指定在哪些列后发生分割。vsplit沿着X轴分割。12345678910111213141516171819202122232425262728293031323334&gt;&gt;&gt; a = floor(10*random.random((2,12)))&gt;&gt;&gt; a array([ [ 8., 8., 3., 9., 0., 4., 3., 0., 0., 6., 4., 4.], [ 0., 3., 2., 9., 6., 0., 4., 5., 7., 5., 1., 4.] ])&gt;&gt;&gt; hsplit(a,3) # Split a into 3 [array([ [ 8., 8., 3., 9.], [ 0., 3., 2., 9.] ]), array([ [ 0., 4., 3., 0.], [ 6., 0., 4., 5.] ]), array([ [ 0., 6., 4., 4.], [ 7., 5., 1., 4.]] )]&gt;&gt;&gt; hsplit(a,(3,4)) # Split a after the third and the fourth column [ array([ [ 8., 8., 3.], [ 0., 3., 2.] ]), array([ [ 9.], [ 9.] ]), array([ [ 0., 4., 3., 0., 0., 6., 4., 4.], [ 6., 0., 4., 5., 7., 5., 1., 4.] ]) ] 官方文档链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"https://pandamin18436220.github.io/tags/numpy/"}]},{"title":"Argparse库","date":"2020-02-07T06:23:41.010Z","path":"2020/02/07/python的argparse库/","text":"Argparse的作用python中argparse库是一个命令行参数的解析工具，利用这个库可以在命令行运行脚本时，设置参数，从而灵活的设置脚本中需要的参数。下面总结一下argparse库的使用方法。简而言之: 学会了该库的基本使用，就不必再代码里修改参数！ Argparse的基本使用下面演示Argparse三个基本函数 创建parse对象（函数一） #导入argparse库 import argparse #创建对象 这里使用description参数，我们可以输入想要的提示信息。 parser = argparse.ArgumentParser(description=&apos;add some useful information here....&apos;) ArgumentParser对象保存了所有必要的信息，用于将命令行参数解析为相应的python数据类型。 添加参数信息（函数二） 创建了ArgumentParser对象之后，就可以使用add_argument()方法来添加参数,其输入参数如下，其中[]中的参数为可选参数，作用为设置参数的一些属性。 带 - 的为可选参数(optional parameter) 不带 - 的为必选参数(positional parametrer) ArgumentParser.add_argument(name or flags…[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest]) 下面总结一下，add_argument()方法中常用的一些属性 属性值 作用 type 指定参数存储时的类型，可为int、float、str等 action 参数的处理方法，在命令行遇到此参数时要采取的基本操作类型 nargs 参数的数量，应该使用的命令行参数的数量 const 参数的常量值，某些动作和选择所需的常量值 default 参数的默认值，如果命令行中不存在的参数，则生成的值 choices 参数的取值范围，参数允许值的范围 action 参数的处理方法，在命令行遇到此参数时要采取的基本操作类型 requires 参数是否可以忽略不写，进队可选参数有效 help 参数的说明信息，简单描述参数的作用 metavar 参数在说明信息usage(用法)中的名称，用法消息中的名称 dest 对象的属性名，要添加到返回值的对象的属性的名称 案例一: 12345678910import argparse# 创建解析对象, description是对其描述parser = argparse.ArgumentParser(description=\"测试使用 argparse 库\")# 向parser对象添加你要关注的命令行参数和选项, 这里的两个参数，一个为长参数：--parm1，一个为短参数:-p1parser.add_argument(\"--param1\", \"-p1\", type=str)# 对命令行参数进行解析args = parser.parse_args()print(args)# 输出具体的参数值print(args.param1) 案例二:12345678910111213import argparse# 创建解析对象, description是对其描述parser = argparse.ArgumentParser(description=\"测试使用 argparse 库\")# 向parser对象添加你要关注的命令行参数和选项, 这里的两个参数，一个为长参数：--parm1，一个为短参数:-p1parser.add_argument(\"--param1\", \"-p1\", type=str)parser.add_argument(\"--param2\", \"-p2\", type=int, help=\"参数2需要输入0~20整数\", choices=range(21))# 参数值为int型，传入多个值时，返回的是一个列表parser.add_argument(\"--param3\", \"-p3\", type=int, nargs=\"+\", help=\"list类型，可以接收1~n个值\")# 对命令行参数进行解析args = parser.parse_args()print(args)# 输出具体的参数值print(args.param1,\"\\n\", args.param2,\"\\n\", args.param3) 我们可以通过 --param1 来指定参数1， 也可以使用短参 -p1来指定参数1 add_argument的部分参数介绍如下： type: 指定类型 required: 参数是否必填，如果为True则必须要传入对应的值 help: python test.py -h 会出现对应help的内容 nargs: 指定这个参数后面的值有多少个，默认为1, 也可以写正则表达式符号：+(一个或者多个) , *(没有或者多个), 数字 choices: 设置参数的范围 解析参数(函数三)添加完参数后，最后调用parse_args()方法，将会返回一个命名空间(namespace)，之后我们就可以调用各个设置好的参数啦 def parse_arg(): parser = argparse.ArgumentParser(description=&apos;描述内容&apos;) parser.add_argument(&apos;--param1&apos;, type=int,help=&apos;add some helpful message here.&apos;) parser.add_argument(&apos;--param2&apos;, type=int) parser.add_argument(&apos;--param3&apos;, type=float) args = parser.parse_args() #命名空间namespace return args官方文档链接","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"Argparse","slug":"Argparse","permalink":"https://pandamin18436220.github.io/tags/Argparse/"}]},{"title":"OpenCv基本函数","date":"2020-02-05T07:38:15.137Z","path":"2020/02/05/opencv基本函数/","text":"导入库-*- coding: utf-8 -*- import cv2 #opencv2库 import numpy as np #numpy库 import matplotlib.pyplot as plt #类似于matlab工具 读入图像函数为：cv2.imread(文件名[,显示控制参数]) 返回值：一个图像 功能：读取图像 当显示控制参数为 0/cv2.IMREAD_UNCHANGED 不改变 -1/cv2.IMREAD_GRAYSCALE 图像灰度 1/cv2.IMREAD_COLOR 图像菜度 ``` o=cv2.imread(&apos;C:\\\\Users\\\\Pandamin\\\\Desktop\\\\image\\\\1.jpg&apos;,0)保存图像函数为：cv2.imwrite(文件地址，文件名) 返回值：无 功能：保存图像访问像素函数为：img[位置[,通道数]] 返回值：该位置的像素 功能：得到该位置的图像，也可以更改其值使用numpy访问像素函数为：img.itemset((位置[,通道数]),设置像素值) 返回值：该位置的像素 功能：得到该位置的图像，也可以更改其值获取图像属性函数为：cv2.shape 返回值：返回行数，列数[,通道数] 功能：略函数为：cv2.size返回值：返回行数*列数[*通道数] 功能：略函数为：cv2.dtype返回值：返回图像的数据类型(unit8) 功能：略感兴趣区域(截取图像img中200:400到200:400的像素)函数为：face=img[200:400,200:400] 返回值：截取后的图像 功能：略通道拆分和合并函数为：b,g,r=cv2.split(图像名) 返回值：该图像b,g,r三个通道值 功能：获取三个通道的值函数为：m=cv2.merge([b,g,r])返回值：三个通道合成后的图像 功能：略图像加法函数为：cv2.add(a,b) 返回值：是将a,b图像的对应像素点%255得到加法之后的图像 功能：略图像融合函数为：cv2.addWeighted(图像1，图像1的系数，图像2，图像2的系数，亮度调节值) 返回值：融合后的图像 功能：可以将将两个残缺图像(且残缺的位置不同),融合为一个完整图像类型转换函数为：cv2.cvtColor(图像名,cv2.COLOR_BGR2RGB) 返回值：由BGR通道转化到RGB通道的图像 功能：略 函数为：cv2.cvtColor(图像名,cv2.COLOR_GRAY2BGR) 返回值：由灰度类型转化到BGR通道的图像图像缩放函数为：cv2.resize(src[,dsize=None],fx,fy) 返回值：缩放后的图像 参数：dsize缩放大小(列，行)，如果dsize=None,则可以通过fx(水平),fy(垂直)去缩放 功能：略图像旋转函数为：cv2.flip(src,flipCode) 返回值：旋转后的图像 flipCode&gt;0 返回以Y轴为对称旋转 flipCode=0 返回以x轴为对称旋转 flipCode&lt;0 返回以x,y轴同时翻转阈值分割二进制阈值化 函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_BINARY) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为白色，暗的处理为黑色。反二进制阈值化函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_BINARY_INV) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为黑色，暗的处理为白色。截断阈值化函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_TRUNC) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为阈值，暗的处理为不变。反阈值化为0函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_TOZERO_INV) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为黑色0，暗的处理为不变。阈值化为0函数为：threshold(src,阈值,二值阈值化的最大值,cv2.THRESH_TOZERO) 返回值：有两个，一个是阈值,一个是处理之后的结果。 功能：把图像中亮的处理为不变，暗的处理为黑色。均值滤波函数为：cv2.blur(src,核大小) 返回值：返回均值化后的图像(图像更加平滑) 参数：核大小是以宽度＆高度形式表示的元组 功能：使图像更加平滑方框滤波函数为：cv2.boxFilter(src,目标图像深度,核大小[,normalize属性=1]) 返回值：处理后的图像 参数： 目标图像深度为int类型的目标图像深度，通常使用“-1”表示与原始图像一致 核大小：（n,n）表示有n列n行 normalize=true时，进行归一化处理,与均值滤波相同 normalize=false时，很容易溢出,像素值易大于255,得到白色的图像高斯滤波函数为：GaussianBlur(src,ksize,sigmaX) 返回值：略 参数： ksize：为核大小(n,n),必须为奇数 sigmaX：X方向方差，控制权重，一般sigmaX=0,其会自动算一个方差中值滤波函数为：cv2.medianBlur(src,ksize) 参数： ksize：必须为比1大的奇数且只要写一个数值n，不要写(n,n)图像腐蚀函数为：cv2.erode(src,kernel[,iterations=1]) 参数： kernel为卷积核,np.ones((n,n),np.unit8), 通过numpy的ones函数生成n*n的数值，其类型为unit8的卷积核 iterations为迭代次数图像膨胀函数为：cv2.dilate(src,kernel[,iterations=1]) 参数： kernel为卷积核,np.ones((n,n),np.unit8), 通过numpy的ones函数生成n*n的数值，其类型为unit8的卷积核 iterations为迭代次数开运算：先进行腐蚀操作+膨胀操作，其作用去除噪声并保持原有的形状函数为：cv2.morphologyEx(img,cv2.MORPH_OPEN,kernel) 参数： cv2.MORPH_OPEN 开运算 kernel 卷积核闭运算：先进行膨胀+腐蚀操作，其作用去掉物体内的小黑点函数为：cv2.morphologyEx(img,cv2.MORPH_CLOSE,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_CLOSE 闭运算 kernel 卷积核梯度运算：将一个图像分别进行膨胀，腐蚀操作并将其相减，得到轮廓信息函数为：cv2.morphologyEx(img,cv2.MORPH_GRADIENT,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_GRADIENT 梯度运算 kernel 卷积核礼帽(顶帽)运算：礼帽图像=原图像-开运算图像(去除噪声)，得到噪声图像函数为：cv2.morphologyEx(img,cv2.MORPH_TOPHAT,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_TOPHAT 礼帽运算 kernel 卷积核黑帽图像处理：黑帽图像=闭运算图像-元素图像，得到图像内部的小黑点函数为：cv2.morphologyEx(img,cv2.MORPH_BLACKHAT,kernel) morphologyEx是形态学的一组函数，根据参数不同实现不同操作 参数： cv2.MORPH_BLACKHAT 黑帽运算 kernel 卷积核计算图像梯度,寻找边界(左右像素值差=0不是边界，!=0为边界，对其结果取绝对值)sobel算子：|左-右|+|下-上| 函数为：cv2.Sobel(src,dddpth,dx,dy,[ksize]) 参数： dddpth：处理结果图像深度，通常情况下，可以设置为-1，表示与原图像的深度一致。 但是在计算的时候可能会出现负值，会发生信息丢失，所以需要更高的数据类型 即dddpth取cv2.CV_64F,取绝对值后，再转换为np.unit8类型 取绝对值通过cv2.convertScaleAbs(scr[,alpha[,beta]]) 其作用是将原始图像转化为256色位图 dx:计算x方向的边界[dx=1,dy=0] dy:计算y方向的边界[dx=0,dy=1] 通过函数cv2.addWeighted(sobel_dx，图像1的系数，sobel_dy，图像2的系数，亮度调节值) ksize=-1时，等价于Scharr算子 scharr算子：|左-右|+|下-上| 函数为：cv2.Scharr(src,cv2.CV_64F,dx,dy) dx:计算x方向的边界dx=Scharrx(src,ddpeth,dx=1,dy=0) dy:计算y方向的边界dy=Scharry(src,ddpeth,dx=0,dy=1) 通过函数cv2.addWeighted(dx，图像1的系数，dy，图像2的系数，亮度调节值) ##且要满足dx&gt;=0&amp;&amp;dy&gt;=0&amp;&amp;&amp;dx+dy==1 参数值：略 拉普拉斯算子：|左-右|+|左-右|+|下-上|+|下-上| 函数为：cv2.Laplacian(src,dddpth) 即dddpth取cv2.CV_64F,取绝对值后，再转换为np.unit8类型 取绝对值通过cv2.convertScaleAbs(scr[,alpha[,beta]]) 其作用是将原始图像转化为256色位图 参数值：略canny边缘检测函数为：cv2.Canny(src,阈值1,阈值2) 参数值：阈值1minVal,阈值2maxVal,两个阈值是来控制边界信息的丰富程度的， 阈值越小得到图像的边界越丰富，越细致图像金字塔pyrDown(图像向下取样，变成原来的1/4)，pyrUp(图像向下取样，变成原来4倍) 函数为：cv2.pyrDown(src) cv2.pyrUp(src) 参数值：略 取样可逆性研究：经过放到缩小图像是否不变？不一样，图像的清晰度变差拉普拉斯金字塔函数为：Li=Gi-PyrUp(PyrDown(Gi)) 参数值：Gi原始图像，Li拉普拉斯图像 例如： od=cv2.pyrDown(o) odu=cv2.pyrUp(od) lapPyr=o-odu 拉普拉斯金字塔图像第0层 o1=od o1d=cv2.pyrDown(o1) o1du=cv2.pyrUp(o1d) lapPyr1=o1-o1du 拉普拉斯金字塔图像第1层 即拉普拉斯图像+向下取样图像=原始图像图像轮廓：边界与轮廓的区别，轮廓是指连续的边界函数为:cv2.drawContours(src,contours,contourldx,color[,thickness]) 参数值： contours：需要绘制的边缘数组 contourldx:需要绘制的边缘索引，如果全部绘制为-1 color:绘制的颜色，为BGR格式的Scalar thinckness:绘制的密度，即轮廓画笔的粗细绘制直方图函数为：plt.hist(src.ravel(),256) 参数值：将src转化为一维数组 像素级一般为256,为八位的图像的灰度级：[0,255]使用Opencv统计直方图函数为：hist=cv2.calcHist(images,channels,mask,histSize,ranges[,accumulate]) 通过函数plt.plot(hist，color=&apos;g/b/r&apos;)绘制出来 参数值： images:原始图像 channels：指定通道 mask：掩码图像，统计整幅图像的直方图为None histSize：BINS的数量,一般为[256]--灰度图像 ranges：像素值范围RANGE，一般为[0,255] accumulate:累计标识 返回值：返回一个直方图hist使用掩码直方图：先通过zeros生成全黑图像，在截取相应区域为白色函数为：mask=np.zeros(src.shape,np.unit8) mask[200:400,200:400]=255 参数值：src.shape元素图像的大小，np.unit8为八位的位图 返回值：略直方图均值化原理：色彩的细节更加丰富函数为：equ=cv2.qualizeHist(src) 参数值：略 返回值：略subplot函数：一个窗口显示多个图像函数为：plt.subplot(n行,n列,窗口序列) 例如：plt.subplot(121),plt.hist(img.ravel(),256) plt.subplot(122),plt.hist(img.ravel(),256) 函数为：imshow(x,cmap=None) 参数值：x为需要绘制的图像 cmap为颜色图谱，默认为RGB(A)颜色空间 若要显示灰度图像：cmap=plt.cm,gray 若雅显示彩色图像:如果是通过python读进来的，则不需要处理RGB 如果是通过opencv读进来的，则其默认BGR,要调整色彩空间 使用默认值，显示彩色图像 plt.subplot(221) plt.imshow(scr_color),plt.axis(&apos;off&apos;)使用gray参数，显示彩色图像plt.subplot(222) plt.imshow(src_color,cmap=plt.cm.gray),plt.axis(&apos;off&apos;)使用默认值，显示彩色度图像plt.subplot(223) plt.imshow(src_gray),plt.axis(&apos;off&apos;)使用gray参数，显示灰度图像【灰度图像+灰度类型才可以显示灰度图像】plt.subplot(224) plt.imshow(src_gray,cmap=plt.cm.gray),plt.axis(&apos;off&apos;)#设置直方图没有坐标傅里叶变换函数为：f=np.fft.fft2(src) 返回值：返回一个复数的数组移动到中心位置：将零频率分量移动到频谱中心函数为：fshift=np.fft.fftshift(f) 将复数数组转化为灰度图像--&gt;20*np.log(np.abs(fshift))设置频谱的范围逆傅里叶变换函数为：ifshift=np.fft.ifftshift(f) iimg=np.fft.ifft2(ishift) iimg=np.abs(iimg)显示图像，删除所有窗口函数为：cv2.imshow(窗口名，图像名) cv2.waitKey([,delay]) cv2.destroyAllWindows() 参数值： delay: delay&gt;0 等待delay毫秒 delay&lt;0 等待键盘单击 delay=0 无限等待","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://pandamin18436220.github.io/tags/python/"},{"name":"OpenCv","slug":"OpenCv","permalink":"https://pandamin18436220.github.io/tags/OpenCv/"}]},{"title":"Markdown的基本使用","date":"2020-02-04T05:53:24.883Z","path":"2020/02/04/Markdowm的基本使用/","text":"二级标题 粗体文本 斜体文本 粗斜体文本 * 无序列表 有序列表 你好(前面有四个空格/Tab) 用&gt;表示区块 二级区块 1表示代码部分使用链接 表头 表头 表头 表头 表头 表头","comments":true,"tags":[{"name":"Markdowm","slug":"Markdowm","permalink":"https://pandamin18436220.github.io/tags/Markdowm/"}]}]